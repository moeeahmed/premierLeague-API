// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../node_modules/core-js/modules/_global.js":[function(require,module,exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"../../node_modules/core-js/modules/_core.js":[function(require,module,exports) {
var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"../../node_modules/core-js/modules/_is-object.js":[function(require,module,exports) {
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"../../node_modules/core-js/modules/_an-object.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js"}],"../../node_modules/core-js/modules/_fails.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],"../../node_modules/core-js/modules/_descriptors.js":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/_dom-create.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/_ie8-dom-define.js":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_dom-create":"../../node_modules/core-js/modules/_dom-create.js"}],"../../node_modules/core-js/modules/_to-primitive.js":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js"}],"../../node_modules/core-js/modules/_object-dp.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_ie8-dom-define":"../../node_modules/core-js/modules/_ie8-dom-define.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js"}],"../../node_modules/core-js/modules/_property-desc.js":[function(require,module,exports) {
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],"../../node_modules/core-js/modules/_hide.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js"}],"../../node_modules/core-js/modules/_has.js":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],"../../node_modules/core-js/modules/_uid.js":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"../../node_modules/core-js/modules/_library.js":[function(require,module,exports) {
module.exports = false;

},{}],"../../node_modules/core-js/modules/_shared.js":[function(require,module,exports) {

var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"../../node_modules/core-js/modules/_core.js","./_global":"../../node_modules/core-js/modules/_global.js","./_library":"../../node_modules/core-js/modules/_library.js"}],"../../node_modules/core-js/modules/_function-to-string.js":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"../../node_modules/core-js/modules/_shared.js"}],"../../node_modules/core-js/modules/_redefine.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_has":"../../node_modules/core-js/modules/_has.js","./_uid":"../../node_modules/core-js/modules/_uid.js","./_function-to-string":"../../node_modules/core-js/modules/_function-to-string.js","./_core":"../../node_modules/core-js/modules/_core.js"}],"../../node_modules/core-js/modules/_a-function.js":[function(require,module,exports) {
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],"../../node_modules/core-js/modules/_ctx.js":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":"../../node_modules/core-js/modules/_a-function.js"}],"../../node_modules/core-js/modules/_export.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_core":"../../node_modules/core-js/modules/_core.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js"}],"../../node_modules/core-js/modules/_defined.js":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],"../../node_modules/core-js/modules/_to-object.js":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/_to-integer.js":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"../../node_modules/core-js/modules/_to-absolute-index.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"../../node_modules/core-js/modules/_to-integer.js"}],"../../node_modules/core-js/modules/_to-length.js":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"../../node_modules/core-js/modules/_to-integer.js"}],"../../node_modules/core-js/modules/_array-copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js"}],"../../node_modules/core-js/modules/_wks.js":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_shared":"../../node_modules/core-js/modules/_shared.js","./_uid":"../../node_modules/core-js/modules/_uid.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/_add-to-unscopables.js":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"../../node_modules/core-js/modules/_wks.js","./_hide":"../../node_modules/core-js/modules/_hide.js"}],"../../node_modules/core-js/modules/es6.array.copy-within.js":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-copy-within":"../../node_modules/core-js/modules/_array-copy-within.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/_array-fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js"}],"../../node_modules/core-js/modules/es6.array.fill.js":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-fill":"../../node_modules/core-js/modules/_array-fill.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/_cof.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],"../../node_modules/core-js/modules/_iobject.js":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"../../node_modules/core-js/modules/_cof.js"}],"../../node_modules/core-js/modules/_is-array.js":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":"../../node_modules/core-js/modules/_cof.js"}],"../../node_modules/core-js/modules/_array-species-constructor.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_is-array":"../../node_modules/core-js/modules/_is-array.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_array-species-create.js":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"../../node_modules/core-js/modules/_array-species-constructor.js"}],"../../node_modules/core-js/modules/_array-methods.js":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_iobject":"../../node_modules/core-js/modules/_iobject.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_array-species-create":"../../node_modules/core-js/modules/_array-species-create.js"}],"../../node_modules/core-js/modules/_strict-method.js":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.array.filter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../node_modules/core-js/modules/_strict-method.js"}],"../../node_modules/core-js/modules/es6.array.find.js":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/es6.array.find-index.js":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/_flatten-into-array.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_is-array":"../../node_modules/core-js/modules/_is-array.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/es7.array.flat-map.js":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_flatten-into-array":"../../node_modules/core-js/modules/_flatten-into-array.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_array-species-create":"../../node_modules/core-js/modules/_array-species-create.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/_iter-call.js":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/_iterators.js":[function(require,module,exports) {
module.exports = {};

},{}],"../../node_modules/core-js/modules/_is-array-iter.js":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_create-property.js":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js"}],"../../node_modules/core-js/modules/_classof.js":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"../../node_modules/core-js/modules/_cof.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/core.get-iterator-method.js":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":"../../node_modules/core-js/modules/_classof.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_core":"../../node_modules/core-js/modules/_core.js"}],"../../node_modules/core-js/modules/_iter-detect.js":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/es6.array.from.js":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_export":"../../node_modules/core-js/modules/_export.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_iter-call":"../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../node_modules/core-js/modules/_is-array-iter.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_create-property":"../../node_modules/core-js/modules/_create-property.js","./core.get-iterator-method":"../../node_modules/core-js/modules/core.get-iterator-method.js","./_iter-detect":"../../node_modules/core-js/modules/_iter-detect.js"}],"../../node_modules/core-js/modules/_to-iobject.js":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_iobject":"../../node_modules/core-js/modules/_iobject.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/_array-includes.js":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../node_modules/core-js/modules/es7.array.includes.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-includes":"../../node_modules/core-js/modules/_array-includes.js","./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js"}],"../../node_modules/core-js/modules/_iter-step.js":[function(require,module,exports) {
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],"../../node_modules/core-js/modules/_shared-key.js":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"../../node_modules/core-js/modules/_shared.js","./_uid":"../../node_modules/core-js/modules/_uid.js"}],"../../node_modules/core-js/modules/_object-keys-internal.js":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_has":"../../node_modules/core-js/modules/_has.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_array-includes":"../../node_modules/core-js/modules/_array-includes.js","./_shared-key":"../../node_modules/core-js/modules/_shared-key.js"}],"../../node_modules/core-js/modules/_enum-bug-keys.js":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],"../../node_modules/core-js/modules/_object-keys.js":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../node_modules/core-js/modules/_object-dps.js":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js"}],"../../node_modules/core-js/modules/_html.js":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/_object-create.js":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_object-dps":"../../node_modules/core-js/modules/_object-dps.js","./_enum-bug-keys":"../../node_modules/core-js/modules/_enum-bug-keys.js","./_shared-key":"../../node_modules/core-js/modules/_shared-key.js","./_dom-create":"../../node_modules/core-js/modules/_dom-create.js","./_html":"../../node_modules/core-js/modules/_html.js"}],"../../node_modules/core-js/modules/_set-to-string-tag.js":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_has":"../../node_modules/core-js/modules/_has.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_iter-create.js":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_object-gpo.js":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"../../node_modules/core-js/modules/_has.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_shared-key":"../../node_modules/core-js/modules/_shared-key.js"}],"../../node_modules/core-js/modules/_iter-define.js":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_library":"../../node_modules/core-js/modules/_library.js","./_export":"../../node_modules/core-js/modules/_export.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_iter-create":"../../node_modules/core-js/modules/_iter-create.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/es6.array.iterator.js":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"../../node_modules/core-js/modules/_add-to-unscopables.js","./_iter-step":"../../node_modules/core-js/modules/_iter-step.js","./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_iter-define":"../../node_modules/core-js/modules/_iter-define.js"}],"../../node_modules/core-js/modules/es6.array.map.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_strict-method":"../../node_modules/core-js/modules/_strict-method.js"}],"../../node_modules/core-js/modules/es6.array.of.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_create-property":"../../node_modules/core-js/modules/_create-property.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.array.slice.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_html":"../../node_modules/core-js/modules/_html.js","./_cof":"../../node_modules/core-js/modules/_cof.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.array.sort.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_strict-method":"../../node_modules/core-js/modules/_strict-method.js"}],"../../node_modules/core-js/modules/_set-species.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/es6.array.species.js":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"../../node_modules/core-js/modules/_set-species.js"}],"../../node_modules/core-js/modules/_date-to-primitive.js":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js"}],"../../node_modules/core-js/modules/es6.date.to-primitive.js":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"../../node_modules/core-js/modules/_wks.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_date-to-primitive":"../../node_modules/core-js/modules/_date-to-primitive.js"}],"../../node_modules/core-js/modules/es6.function.has-instance.js":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js"}],"../../node_modules/core-js/modules/es6.function.name.js":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js"}],"../../node_modules/core-js/modules/_redefine-all.js":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":"../../node_modules/core-js/modules/_redefine.js"}],"../../node_modules/core-js/modules/_an-instance.js":[function(require,module,exports) {
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],"../../node_modules/core-js/modules/_for-of.js":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_iter-call":"../../node_modules/core-js/modules/_iter-call.js","./_is-array-iter":"../../node_modules/core-js/modules/_is-array-iter.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./core.get-iterator-method":"../../node_modules/core-js/modules/core.get-iterator-method.js"}],"../../node_modules/core-js/modules/_meta.js":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_uid":"../../node_modules/core-js/modules/_uid.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_has":"../../node_modules/core-js/modules/_has.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/_validate-collection.js":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js"}],"../../node_modules/core-js/modules/_collection-strong.js":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../node_modules/core-js/modules/_for-of.js","./_iter-define":"../../node_modules/core-js/modules/_iter-define.js","./_iter-step":"../../node_modules/core-js/modules/_iter-step.js","./_set-species":"../../node_modules/core-js/modules/_set-species.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js"}],"../../node_modules/core-js/modules/_object-pie.js":[function(require,module,exports) {
exports.f = {}.propertyIsEnumerable;

},{}],"../../node_modules/core-js/modules/_object-gopd.js":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"../../node_modules/core-js/modules/_object-pie.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../node_modules/core-js/modules/_has.js","./_ie8-dom-define":"../../node_modules/core-js/modules/_ie8-dom-define.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js"}],"../../node_modules/core-js/modules/_set-proto.js":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js"}],"../../node_modules/core-js/modules/_inherit-if-required.js":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_set-proto":"../../node_modules/core-js/modules/_set-proto.js"}],"../../node_modules/core-js/modules/_collection.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_export":"../../node_modules/core-js/modules/_export.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_for-of":"../../node_modules/core-js/modules/_for-of.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_iter-detect":"../../node_modules/core-js/modules/_iter-detect.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js","./_inherit-if-required":"../../node_modules/core-js/modules/_inherit-if-required.js"}],"../../node_modules/core-js/modules/es6.map.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection-strong":"../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../node_modules/core-js/modules/_collection.js"}],"../../node_modules/core-js/modules/_math-log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"../../node_modules/core-js/modules/es6.math.acosh.js":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../node_modules/core-js/modules/_math-log1p.js"}],"../../node_modules/core-js/modules/es6.math.asinh.js":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.math.atanh.js":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/_math-sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"../../node_modules/core-js/modules/es6.math.cbrt.js":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-sign":"../../node_modules/core-js/modules/_math-sign.js"}],"../../node_modules/core-js/modules/es6.math.clz32.js":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.math.cosh.js":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/_math-expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"../../node_modules/core-js/modules/es6.math.expm1.js":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../node_modules/core-js/modules/_math-expm1.js"}],"../../node_modules/core-js/modules/_math-fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":"../../node_modules/core-js/modules/_math-sign.js"}],"../../node_modules/core-js/modules/es6.math.fround.js":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-fround":"../../node_modules/core-js/modules/_math-fround.js"}],"../../node_modules/core-js/modules/es6.math.hypot.js":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.math.imul.js":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.math.log1p.js":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-log1p":"../../node_modules/core-js/modules/_math-log1p.js"}],"../../node_modules/core-js/modules/es6.math.log10.js":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.math.log2.js":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.math.sign.js":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-sign":"../../node_modules/core-js/modules/_math-sign.js"}],"../../node_modules/core-js/modules/es6.math.sinh.js":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../node_modules/core-js/modules/_math-expm1.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.math.tanh.js":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_math-expm1":"../../node_modules/core-js/modules/_math-expm1.js"}],"../../node_modules/core-js/modules/es6.math.trunc.js":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/_object-gopn.js":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"../../node_modules/core-js/modules/_object-keys-internal.js","./_enum-bug-keys":"../../node_modules/core-js/modules/_enum-bug-keys.js"}],"../../node_modules/core-js/modules/_string-ws.js":[function(require,module,exports) {
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],"../../node_modules/core-js/modules/_string-trim.js":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_defined":"../../node_modules/core-js/modules/_defined.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_string-ws":"../../node_modules/core-js/modules/_string-ws.js"}],"../../node_modules/core-js/modules/es6.number.constructor.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_has":"../../node_modules/core-js/modules/_has.js","./_cof":"../../node_modules/core-js/modules/_cof.js","./_inherit-if-required":"../../node_modules/core-js/modules/_inherit-if-required.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_string-trim":"../../node_modules/core-js/modules/_string-trim.js","./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js"}],"../../node_modules/core-js/modules/es6.number.epsilon.js":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.number.is-finite.js":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/_is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js"}],"../../node_modules/core-js/modules/es6.number.is-integer.js":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_is-integer":"../../node_modules/core-js/modules/_is-integer.js"}],"../../node_modules/core-js/modules/es6.number.is-nan.js":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.number.is-safe-integer.js":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_is-integer":"../../node_modules/core-js/modules/_is-integer.js"}],"../../node_modules/core-js/modules/es6.number.max-safe-integer.js":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.number.min-safe-integer.js":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/_parse-float.js":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_string-trim":"../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../node_modules/core-js/modules/_string-ws.js"}],"../../node_modules/core-js/modules/es6.number.parse-float.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_parse-float":"../../node_modules/core-js/modules/_parse-float.js"}],"../../node_modules/core-js/modules/_parse-int.js":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_string-trim":"../../node_modules/core-js/modules/_string-trim.js","./_string-ws":"../../node_modules/core-js/modules/_string-ws.js"}],"../../node_modules/core-js/modules/es6.number.parse-int.js":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_parse-int":"../../node_modules/core-js/modules/_parse-int.js"}],"../../node_modules/core-js/modules/_object-gops.js":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"../../node_modules/core-js/modules/_object-assign.js":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../node_modules/core-js/modules/_object-pie.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_iobject":"../../node_modules/core-js/modules/_iobject.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.object.assign.js":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-assign":"../../node_modules/core-js/modules/_object-assign.js"}],"../../node_modules/core-js/modules/_object-forced-pam.js":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_library":"../../node_modules/core-js/modules/_library.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/es7.object.define-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../node_modules/core-js/modules/es7.object.define-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../node_modules/core-js/modules/_object-to-array.js":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_object-pie":"../../node_modules/core-js/modules/_object-pie.js"}],"../../node_modules/core-js/modules/es7.object.entries.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../node_modules/core-js/modules/_object-to-array.js"}],"../../node_modules/core-js/modules/_object-sap.js":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_core":"../../node_modules/core-js/modules/_core.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.object.freeze.js":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/_own-keys.js":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./_object-gops":"../../node_modules/core-js/modules/_object-gops.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_own-keys":"../../node_modules/core-js/modules/_own-keys.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_create-property":"../../node_modules/core-js/modules/_create-property.js"}],"../../node_modules/core-js/modules/_object-gopn-ext.js":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js"}],"../../node_modules/core-js/modules/es6.object.get-own-property-names.js":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"../../node_modules/core-js/modules/_object-sap.js","./_object-gopn-ext":"../../node_modules/core-js/modules/_object-gopn-ext.js"}],"../../node_modules/core-js/modules/es6.object.get-prototype-of.js":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es7.object.lookup-getter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../node_modules/core-js/modules/es7.object.lookup-setter.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-forced-pam":"../../node_modules/core-js/modules/_object-forced-pam.js"}],"../../node_modules/core-js/modules/es6.object.prevent-extensions.js":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.to-string.js":[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":"../../node_modules/core-js/modules/_classof.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js"}],"../../node_modules/core-js/modules/_same-value.js":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"../../node_modules/core-js/modules/es6.object.is.js":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_same-value":"../../node_modules/core-js/modules/_same-value.js"}],"../../node_modules/core-js/modules/es6.object.is-frozen.js":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.is-sealed.js":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.is-extensible.js":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.keys.js":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.seal.js":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_object-sap":"../../node_modules/core-js/modules/_object-sap.js"}],"../../node_modules/core-js/modules/es6.object.set-prototype-of.js":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_set-proto":"../../node_modules/core-js/modules/_set-proto.js"}],"../../node_modules/core-js/modules/es7.object.values.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-to-array":"../../node_modules/core-js/modules/_object-to-array.js"}],"../../node_modules/core-js/modules/_species-constructor.js":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_invoke.js":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],"../../node_modules/core-js/modules/_task.js":[function(require,module,exports) {


var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_invoke":"../../node_modules/core-js/modules/_invoke.js","./_html":"../../node_modules/core-js/modules/_html.js","./_dom-create":"../../node_modules/core-js/modules/_dom-create.js","./_global":"../../node_modules/core-js/modules/_global.js","./_cof":"../../node_modules/core-js/modules/_cof.js"}],"../../node_modules/core-js/modules/_microtask.js":[function(require,module,exports) {


var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_task":"../../node_modules/core-js/modules/_task.js","./_cof":"../../node_modules/core-js/modules/_cof.js"}],"../../node_modules/core-js/modules/_new-promise-capability.js":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":"../../node_modules/core-js/modules/_a-function.js"}],"../../node_modules/core-js/modules/_perform.js":[function(require,module,exports) {
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],"../../node_modules/core-js/modules/_user-agent.js":[function(require,module,exports) {

var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/_promise-resolve.js":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_new-promise-capability":"../../node_modules/core-js/modules/_new-promise-capability.js"}],"../../node_modules/core-js/modules/es6.promise.js":[function(require,module,exports) {


'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_library":"../../node_modules/core-js/modules/_library.js","./_global":"../../node_modules/core-js/modules/_global.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_classof":"../../node_modules/core-js/modules/_classof.js","./_export":"../../node_modules/core-js/modules/_export.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../node_modules/core-js/modules/_for-of.js","./_species-constructor":"../../node_modules/core-js/modules/_species-constructor.js","./_task":"../../node_modules/core-js/modules/_task.js","./_microtask":"../../node_modules/core-js/modules/_microtask.js","./_new-promise-capability":"../../node_modules/core-js/modules/_new-promise-capability.js","./_perform":"../../node_modules/core-js/modules/_perform.js","./_user-agent":"../../node_modules/core-js/modules/_user-agent.js","./_promise-resolve":"../../node_modules/core-js/modules/_promise-resolve.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js","./_set-species":"../../node_modules/core-js/modules/_set-species.js","./_core":"../../node_modules/core-js/modules/_core.js","./_iter-detect":"../../node_modules/core-js/modules/_iter-detect.js"}],"../../node_modules/core-js/modules/es7.promise.finally.js":[function(require,module,exports) {

// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_core":"../../node_modules/core-js/modules/_core.js","./_global":"../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../node_modules/core-js/modules/_species-constructor.js","./_promise-resolve":"../../node_modules/core-js/modules/_promise-resolve.js"}],"../../node_modules/core-js/modules/es6.reflect.apply.js":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_global":"../../node_modules/core-js/modules/_global.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/_bind.js":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_invoke":"../../node_modules/core-js/modules/_invoke.js"}],"../../node_modules/core-js/modules/es6.reflect.construct.js":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_a-function":"../../node_modules/core-js/modules/_a-function.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_bind":"../../node_modules/core-js/modules/_bind.js","./_global":"../../node_modules/core-js/modules/_global.js"}],"../../node_modules/core-js/modules/es6.reflect.define-property.js":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_export":"../../node_modules/core-js/modules/_export.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.reflect.delete-property.js":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.get.js":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../node_modules/core-js/modules/_has.js","./_export":"../../node_modules/core-js/modules/_export.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_export":"../../node_modules/core-js/modules/_export.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.has.js":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/es6.reflect.is-extensible.js":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.own-keys.js":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_own-keys":"../../node_modules/core-js/modules/_own-keys.js"}],"../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.reflect.set.js":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_has":"../../node_modules/core-js/modules/_has.js","./_export":"../../node_modules/core-js/modules/_export.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js"}],"../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_set-proto":"../../node_modules/core-js/modules/_set-proto.js"}],"../../node_modules/core-js/modules/_is-regexp.js":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_cof":"../../node_modules/core-js/modules/_cof.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_flags.js":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js"}],"../../node_modules/core-js/modules/es6.regexp.constructor.js":[function(require,module,exports) {

var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_inherit-if-required":"../../node_modules/core-js/modules/_inherit-if-required.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./_is-regexp":"../../node_modules/core-js/modules/_is-regexp.js","./_flags":"../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_set-species":"../../node_modules/core-js/modules/_set-species.js"}],"../../node_modules/core-js/modules/es6.regexp.flags.js":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_flags":"../../node_modules/core-js/modules/_flags.js"}],"../../node_modules/core-js/modules/_string-at.js":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/_advance-string-index.js":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"../../node_modules/core-js/modules/_string-at.js"}],"../../node_modules/core-js/modules/_regexp-exec-abstract.js":[function(require,module,exports) {
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":"../../node_modules/core-js/modules/_classof.js"}],"../../node_modules/core-js/modules/_regexp-exec.js":[function(require,module,exports) {
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":"../../node_modules/core-js/modules/_flags.js"}],"../../node_modules/core-js/modules/es6.regexp.exec.js":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_regexp-exec":"../../node_modules/core-js/modules/_regexp-exec.js","./_export":"../../node_modules/core-js/modules/_export.js"}],"../../node_modules/core-js/modules/_fix-re-wks.js":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./es6.regexp.exec":"../../node_modules/core-js/modules/es6.regexp.exec.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_defined":"../../node_modules/core-js/modules/_defined.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_regexp-exec":"../../node_modules/core-js/modules/_regexp-exec.js"}],"../../node_modules/core-js/modules/es6.regexp.match.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_advance-string-index":"../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../node_modules/core-js/modules/es6.regexp.replace.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_advance-string-index":"../../node_modules/core-js/modules/_advance-string-index.js","./_regexp-exec-abstract":"../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../node_modules/core-js/modules/es6.regexp.split.js":[function(require,module,exports) {
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_is-regexp":"../../node_modules/core-js/modules/_is-regexp.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_species-constructor":"../../node_modules/core-js/modules/_species-constructor.js","./_advance-string-index":"../../node_modules/core-js/modules/_advance-string-index.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_regexp-exec-abstract":"../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_regexp-exec":"../../node_modules/core-js/modules/_regexp-exec.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_fix-re-wks":"../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../node_modules/core-js/modules/es6.regexp.search.js":[function(require,module,exports) {
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_same-value":"../../node_modules/core-js/modules/_same-value.js","./_regexp-exec-abstract":"../../node_modules/core-js/modules/_regexp-exec-abstract.js","./_fix-re-wks":"../../node_modules/core-js/modules/_fix-re-wks.js"}],"../../node_modules/core-js/modules/es6.regexp.to-string.js":[function(require,module,exports) {

'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./es6.regexp.flags":"../../node_modules/core-js/modules/es6.regexp.flags.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_flags":"../../node_modules/core-js/modules/_flags.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_fails":"../../node_modules/core-js/modules/_fails.js"}],"../../node_modules/core-js/modules/es6.set.js":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection-strong":"../../node_modules/core-js/modules/_collection-strong.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../node_modules/core-js/modules/_collection.js"}],"../../node_modules/core-js/modules/_wks-ext.js":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/_wks-define.js":[function(require,module,exports) {

var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_core":"../../node_modules/core-js/modules/_core.js","./_library":"../../node_modules/core-js/modules/_library.js","./_wks-ext":"../../node_modules/core-js/modules/_wks-ext.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js"}],"../../node_modules/core-js/modules/_enum-keys.js":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_object-gops":"../../node_modules/core-js/modules/_object-gops.js","./_object-pie":"../../node_modules/core-js/modules/_object-pie.js"}],"../../node_modules/core-js/modules/es6.symbol.js":[function(require,module,exports) {

'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_has":"../../node_modules/core-js/modules/_has.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_export":"../../node_modules/core-js/modules/_export.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_shared":"../../node_modules/core-js/modules/_shared.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js","./_uid":"../../node_modules/core-js/modules/_uid.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_wks-ext":"../../node_modules/core-js/modules/_wks-ext.js","./_wks-define":"../../node_modules/core-js/modules/_wks-define.js","./_enum-keys":"../../node_modules/core-js/modules/_enum-keys.js","./_is-array":"../../node_modules/core-js/modules/_is-array.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_object-gopn-ext":"../../node_modules/core-js/modules/_object-gopn-ext.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js","./_object-gops":"../../node_modules/core-js/modules/_object-gops.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./_object-pie":"../../node_modules/core-js/modules/_object-pie.js","./_library":"../../node_modules/core-js/modules/_library.js","./_hide":"../../node_modules/core-js/modules/_hide.js"}],"../../node_modules/core-js/modules/es7.symbol.async-iterator.js":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"../../node_modules/core-js/modules/_wks-define.js"}],"../../node_modules/core-js/modules/_string-html.js":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/es6.string.anchor.js":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.big.js":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.blink.js":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.bold.js":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.code-point-at.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_string-at":"../../node_modules/core-js/modules/_string-at.js"}],"../../node_modules/core-js/modules/_string-context.js":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_is-regexp":"../../node_modules/core-js/modules/_is-regexp.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/_fails-is-regexp.js":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/core-js/modules/es6.string.ends-with.js":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../node_modules/core-js/modules/es6.string.fixed.js":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.fontcolor.js":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.fontsize.js":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.from-code-point.js":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js"}],"../../node_modules/core-js/modules/es6.string.includes.js":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_string-context":"../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../node_modules/core-js/modules/es6.string.italics.js":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.iterator.js":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_string-at":"../../node_modules/core-js/modules/_string-at.js","./_iter-define":"../../node_modules/core-js/modules/_iter-define.js"}],"../../node_modules/core-js/modules/es6.string.link.js":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/_string-repeat.js":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/_string-pad.js":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_string-repeat":"../../node_modules/core-js/modules/_string-repeat.js","./_defined":"../../node_modules/core-js/modules/_defined.js"}],"../../node_modules/core-js/modules/es7.string.pad-start.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_string-pad":"../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../node_modules/core-js/modules/_user-agent.js"}],"../../node_modules/core-js/modules/es7.string.pad-end.js":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_string-pad":"../../node_modules/core-js/modules/_string-pad.js","./_user-agent":"../../node_modules/core-js/modules/_user-agent.js"}],"../../node_modules/core-js/modules/es6.string.raw.js":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-iobject":"../../node_modules/core-js/modules/_to-iobject.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js"}],"../../node_modules/core-js/modules/es6.string.repeat.js":[function(require,module,exports) {
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_string-repeat":"../../node_modules/core-js/modules/_string-repeat.js"}],"../../node_modules/core-js/modules/es6.string.small.js":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.starts-with.js":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_string-context":"../../node_modules/core-js/modules/_string-context.js","./_fails-is-regexp":"../../node_modules/core-js/modules/_fails-is-regexp.js"}],"../../node_modules/core-js/modules/es6.string.strike.js":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.sub.js":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es6.string.sup.js":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":"../../node_modules/core-js/modules/_string-html.js"}],"../../node_modules/core-js/modules/es7.string.trim-left.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":"../../node_modules/core-js/modules/_string-trim.js"}],"../../node_modules/core-js/modules/es7.string.trim-right.js":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":"../../node_modules/core-js/modules/_string-trim.js"}],"../../node_modules/core-js/modules/_typed.js":[function(require,module,exports) {

var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_uid":"../../node_modules/core-js/modules/_uid.js"}],"../../node_modules/core-js/modules/_to-index.js":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js"}],"../../node_modules/core-js/modules/_typed-buffer.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_library":"../../node_modules/core-js/modules/_library.js","./_typed":"../../node_modules/core-js/modules/_typed.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../node_modules/core-js/modules/_to-index.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_array-fill":"../../node_modules/core-js/modules/_array-fill.js","./_set-to-string-tag":"../../node_modules/core-js/modules/_set-to-string-tag.js"}],"../../node_modules/core-js/modules/es6.typed.array-buffer.js":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_typed":"../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../node_modules/core-js/modules/_typed-buffer.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_global":"../../node_modules/core-js/modules/_global.js","./_species-constructor":"../../node_modules/core-js/modules/_species-constructor.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_set-species":"../../node_modules/core-js/modules/_set-species.js"}],"../../node_modules/core-js/modules/_typed-array.js":[function(require,module,exports) {
var global = arguments[3];
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_descriptors":"../../node_modules/core-js/modules/_descriptors.js","./_library":"../../node_modules/core-js/modules/_library.js","./_global":"../../node_modules/core-js/modules/_global.js","./_fails":"../../node_modules/core-js/modules/_fails.js","./_export":"../../node_modules/core-js/modules/_export.js","./_typed":"../../node_modules/core-js/modules/_typed.js","./_typed-buffer":"../../node_modules/core-js/modules/_typed-buffer.js","./_ctx":"../../node_modules/core-js/modules/_ctx.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_property-desc":"../../node_modules/core-js/modules/_property-desc.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_to-integer":"../../node_modules/core-js/modules/_to-integer.js","./_to-length":"../../node_modules/core-js/modules/_to-length.js","./_to-index":"../../node_modules/core-js/modules/_to-index.js","./_to-absolute-index":"../../node_modules/core-js/modules/_to-absolute-index.js","./_to-primitive":"../../node_modules/core-js/modules/_to-primitive.js","./_has":"../../node_modules/core-js/modules/_has.js","./_classof":"../../node_modules/core-js/modules/_classof.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_to-object":"../../node_modules/core-js/modules/_to-object.js","./_is-array-iter":"../../node_modules/core-js/modules/_is-array-iter.js","./_object-create":"../../node_modules/core-js/modules/_object-create.js","./_object-gpo":"../../node_modules/core-js/modules/_object-gpo.js","./_object-gopn":"../../node_modules/core-js/modules/_object-gopn.js","./core.get-iterator-method":"../../node_modules/core-js/modules/core.get-iterator-method.js","./_uid":"../../node_modules/core-js/modules/_uid.js","./_wks":"../../node_modules/core-js/modules/_wks.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_array-includes":"../../node_modules/core-js/modules/_array-includes.js","./_species-constructor":"../../node_modules/core-js/modules/_species-constructor.js","./es6.array.iterator":"../../node_modules/core-js/modules/es6.array.iterator.js","./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_iter-detect":"../../node_modules/core-js/modules/_iter-detect.js","./_set-species":"../../node_modules/core-js/modules/_set-species.js","./_array-fill":"../../node_modules/core-js/modules/_array-fill.js","./_array-copy-within":"../../node_modules/core-js/modules/_array-copy-within.js","./_object-dp":"../../node_modules/core-js/modules/_object-dp.js","./_object-gopd":"../../node_modules/core-js/modules/_object-gopd.js"}],"../../node_modules/core-js/modules/es6.typed.int8-array.js":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.uint8-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.int16-array.js":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.uint16-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.int32-array.js":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.uint32-array.js":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.float32-array.js":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/es6.typed.float64-array.js":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":"../../node_modules/core-js/modules/_typed-array.js"}],"../../node_modules/core-js/modules/_collection-weak.js":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"../../node_modules/core-js/modules/_redefine-all.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_an-object":"../../node_modules/core-js/modules/_an-object.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_an-instance":"../../node_modules/core-js/modules/_an-instance.js","./_for-of":"../../node_modules/core-js/modules/_for-of.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_has":"../../node_modules/core-js/modules/_has.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js"}],"../../node_modules/core-js/modules/es6.weak-map.js":[function(require,module,exports) {

'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_array-methods":"../../node_modules/core-js/modules/_array-methods.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_meta":"../../node_modules/core-js/modules/_meta.js","./_object-assign":"../../node_modules/core-js/modules/_object-assign.js","./_collection-weak":"../../node_modules/core-js/modules/_collection-weak.js","./_is-object":"../../node_modules/core-js/modules/_is-object.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../node_modules/core-js/modules/_collection.js"}],"../../node_modules/core-js/modules/es6.weak-set.js":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection-weak":"../../node_modules/core-js/modules/_collection-weak.js","./_validate-collection":"../../node_modules/core-js/modules/_validate-collection.js","./_collection":"../../node_modules/core-js/modules/_collection.js"}],"../../node_modules/core-js/modules/web.timers.js":[function(require,module,exports) {

// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_global":"../../node_modules/core-js/modules/_global.js","./_export":"../../node_modules/core-js/modules/_export.js","./_user-agent":"../../node_modules/core-js/modules/_user-agent.js"}],"../../node_modules/core-js/modules/web.immediate.js":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":"../../node_modules/core-js/modules/_export.js","./_task":"../../node_modules/core-js/modules/_task.js"}],"../../node_modules/core-js/modules/web.dom.iterable.js":[function(require,module,exports) {

var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./es6.array.iterator":"../../node_modules/core-js/modules/es6.array.iterator.js","./_object-keys":"../../node_modules/core-js/modules/_object-keys.js","./_redefine":"../../node_modules/core-js/modules/_redefine.js","./_global":"../../node_modules/core-js/modules/_global.js","./_hide":"../../node_modules/core-js/modules/_hide.js","./_iterators":"../../node_modules/core-js/modules/_iterators.js","./_wks":"../../node_modules/core-js/modules/_wks.js"}],"../../node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var define;
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],"../../node_modules/axios/lib/helpers/bind.js":[function(require,module,exports) {
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],"../../node_modules/axios/lib/utils.js":[function(require,module,exports) {
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

},{"./helpers/bind":"../../node_modules/axios/lib/helpers/bind.js"}],"../../node_modules/axios/lib/helpers/buildURL.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/core/InterceptorManager.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/helpers/normalizeHeaderName.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/core/AxiosError.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;

},{"../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/defaults/transitional.js":[function(require,module,exports) {
'use strict';

module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],"../../node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../node_modules/node-libs-browser/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../node_modules/base64-js/index.js","ieee754":"../../node_modules/ieee754/index.js","isarray":"../../node_modules/isarray/index.js","buffer":"../../node_modules/node-libs-browser/node_modules/buffer/index.js"}],"../../node_modules/axios/lib/helpers/toFormData.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
'use strict';

var utils = require('../utils');

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;

},{"../utils":"../../node_modules/axios/lib/utils.js","buffer":"../../node_modules/node-libs-browser/node_modules/buffer/index.js"}],"../../node_modules/axios/lib/core/settle.js":[function(require,module,exports) {
'use strict';

var AxiosError = require('./AxiosError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};

},{"./AxiosError":"../../node_modules/axios/lib/core/AxiosError.js"}],"../../node_modules/axios/lib/helpers/cookies.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/helpers/isAbsoluteURL.js":[function(require,module,exports) {
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],"../../node_modules/axios/lib/helpers/combineURLs.js":[function(require,module,exports) {
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],"../../node_modules/axios/lib/core/buildFullPath.js":[function(require,module,exports) {
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/isAbsoluteURL":"../../node_modules/axios/lib/helpers/isAbsoluteURL.js","../helpers/combineURLs":"../../node_modules/axios/lib/helpers/combineURLs.js"}],"../../node_modules/axios/lib/helpers/parseHeaders.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/helpers/isURLSameOrigin.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/cancel/CanceledError.js":[function(require,module,exports) {
'use strict';

var AxiosError = require('../core/AxiosError');
var utils = require('../utils');

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;

},{"../core/AxiosError":"../../node_modules/axios/lib/core/AxiosError.js","../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/helpers/parseProtocol.js":[function(require,module,exports) {
'use strict';

module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};

},{}],"../../node_modules/axios/lib/adapters/xhr.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var transitionalDefaults = require('../defaults/transitional');
var AxiosError = require('../core/AxiosError');
var CanceledError = require('../cancel/CanceledError');
var parseProtocol = require('../helpers/parseProtocol');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};

},{"./../utils":"../../node_modules/axios/lib/utils.js","./../core/settle":"../../node_modules/axios/lib/core/settle.js","./../helpers/cookies":"../../node_modules/axios/lib/helpers/cookies.js","./../helpers/buildURL":"../../node_modules/axios/lib/helpers/buildURL.js","../core/buildFullPath":"../../node_modules/axios/lib/core/buildFullPath.js","./../helpers/parseHeaders":"../../node_modules/axios/lib/helpers/parseHeaders.js","./../helpers/isURLSameOrigin":"../../node_modules/axios/lib/helpers/isURLSameOrigin.js","../defaults/transitional":"../../node_modules/axios/lib/defaults/transitional.js","../core/AxiosError":"../../node_modules/axios/lib/core/AxiosError.js","../cancel/CanceledError":"../../node_modules/axios/lib/cancel/CanceledError.js","../helpers/parseProtocol":"../../node_modules/axios/lib/helpers/parseProtocol.js"}],"../../node_modules/axios/lib/helpers/null.js":[function(require,module,exports) {
// eslint-disable-next-line strict
module.exports = null;

},{}],"../../node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"../../node_modules/axios/lib/defaults/index.js":[function(require,module,exports) {
var process = require("process");
'use strict';

var utils = require('../utils');
var normalizeHeaderName = require('../helpers/normalizeHeaderName');
var AxiosError = require('../core/AxiosError');
var transitionalDefaults = require('./transitional');
var toFormData = require('../helpers/toFormData');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('../adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('../adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: require('./env/FormData')
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

},{"../utils":"../../node_modules/axios/lib/utils.js","../helpers/normalizeHeaderName":"../../node_modules/axios/lib/helpers/normalizeHeaderName.js","../core/AxiosError":"../../node_modules/axios/lib/core/AxiosError.js","./transitional":"../../node_modules/axios/lib/defaults/transitional.js","../helpers/toFormData":"../../node_modules/axios/lib/helpers/toFormData.js","../adapters/xhr":"../../node_modules/axios/lib/adapters/xhr.js","../adapters/http":"../../node_modules/axios/lib/adapters/xhr.js","./env/FormData":"../../node_modules/axios/lib/helpers/null.js","process":"../../node_modules/process/browser.js"}],"../../node_modules/axios/lib/core/transformData.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');
var defaults = require('../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"./../utils":"../../node_modules/axios/lib/utils.js","../defaults":"../../node_modules/axios/lib/defaults/index.js"}],"../../node_modules/axios/lib/cancel/isCancel.js":[function(require,module,exports) {
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],"../../node_modules/axios/lib/core/dispatchRequest.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var CanceledError = require('../cancel/CanceledError');

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"./../utils":"../../node_modules/axios/lib/utils.js","./transformData":"../../node_modules/axios/lib/core/transformData.js","../cancel/isCancel":"../../node_modules/axios/lib/cancel/isCancel.js","../defaults":"../../node_modules/axios/lib/defaults/index.js","../cancel/CanceledError":"../../node_modules/axios/lib/cancel/CanceledError.js"}],"../../node_modules/axios/lib/core/mergeConfig.js":[function(require,module,exports) {
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

},{"../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/env/data.js":[function(require,module,exports) {
module.exports = {
  "version": "0.27.2"
};
},{}],"../../node_modules/axios/lib/helpers/validator.js":[function(require,module,exports) {
'use strict';

var VERSION = require('../env/data').version;
var AxiosError = require('../core/AxiosError');

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../env/data":"../../node_modules/axios/lib/env/data.js","../core/AxiosError":"../../node_modules/axios/lib/core/AxiosError.js"}],"../../node_modules/axios/lib/core/Axios.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var buildFullPath = require('./buildFullPath');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;

},{"./../utils":"../../node_modules/axios/lib/utils.js","../helpers/buildURL":"../../node_modules/axios/lib/helpers/buildURL.js","./InterceptorManager":"../../node_modules/axios/lib/core/InterceptorManager.js","./dispatchRequest":"../../node_modules/axios/lib/core/dispatchRequest.js","./mergeConfig":"../../node_modules/axios/lib/core/mergeConfig.js","./buildFullPath":"../../node_modules/axios/lib/core/buildFullPath.js","../helpers/validator":"../../node_modules/axios/lib/helpers/validator.js"}],"../../node_modules/axios/lib/cancel/CancelToken.js":[function(require,module,exports) {
'use strict';

var CanceledError = require('./CanceledError');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./CanceledError":"../../node_modules/axios/lib/cancel/CanceledError.js"}],"../../node_modules/axios/lib/helpers/spread.js":[function(require,module,exports) {
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],"../../node_modules/axios/lib/helpers/isAxiosError.js":[function(require,module,exports) {
'use strict';

var utils = require('./../utils');

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

},{"./../utils":"../../node_modules/axios/lib/utils.js"}],"../../node_modules/axios/lib/axios.js":[function(require,module,exports) {
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = require('./cancel/CanceledError');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;
axios.toFormData = require('./helpers/toFormData');

// Expose AxiosError class
axios.AxiosError = require('../lib/core/AxiosError');

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./utils":"../../node_modules/axios/lib/utils.js","./helpers/bind":"../../node_modules/axios/lib/helpers/bind.js","./core/Axios":"../../node_modules/axios/lib/core/Axios.js","./core/mergeConfig":"../../node_modules/axios/lib/core/mergeConfig.js","./defaults":"../../node_modules/axios/lib/defaults/index.js","./cancel/CanceledError":"../../node_modules/axios/lib/cancel/CanceledError.js","./cancel/CancelToken":"../../node_modules/axios/lib/cancel/CancelToken.js","./cancel/isCancel":"../../node_modules/axios/lib/cancel/isCancel.js","./env/data":"../../node_modules/axios/lib/env/data.js","./helpers/toFormData":"../../node_modules/axios/lib/helpers/toFormData.js","../lib/core/AxiosError":"../../node_modules/axios/lib/core/AxiosError.js","./helpers/spread":"../../node_modules/axios/lib/helpers/spread.js","./helpers/isAxiosError":"../../node_modules/axios/lib/helpers/isAxiosError.js"}],"../../node_modules/axios/index.js":[function(require,module,exports) {
module.exports = require('./lib/axios');
},{"./lib/axios":"../../node_modules/axios/lib/axios.js"}],"alert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showAlert = exports.hideAlert = void 0;
/* eslint-disable */

var hideAlert = function hideAlert() {
  var el = document.querySelector('.alert');
  if (el) el.parentElement.removeChild(el);
};
exports.hideAlert = hideAlert;
var showAlert = function showAlert(type, msg) {
  hideAlert();
  var markup = "<div class=\"alert alert--".concat(type, "\">").concat(msg, "</div>");
  document.querySelector('body').insertAdjacentHTML('afterbegin', markup);
  window.setTimeout(hideAlert, 3000);
};
exports.showAlert = showAlert;
},{}],"authentication.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.signUp = exports.setNewPassword = exports.reset = exports.logout = exports.login = exports.deleteAccount = void 0;
var _axios = _interopRequireDefault(require("axios"));
var _alert = require("./alert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var signUp = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, email, password, passwordConfirm) {
    var res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0, _axios.default)({
              method: 'POST',
              url: '/api/v1/user/signup',
              data: {
                name: name,
                email: email,
                password: password,
                passwordConfirm: passwordConfirm
              }
            });
          case 3:
            res = _context.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', 'Sign up successful, Welcome!');
              window.setTimeout(function () {
                location.assign('/');
              }, 1500);
            }
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            (0, _alert.showAlert)('error', _context.t0.response.data.message);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return function signUp(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
exports.signUp = signUp;
var login = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(email, password) {
    var res;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return (0, _axios.default)({
              method: 'POST',
              url: '/api/v1/user/login',
              data: {
                email: email,
                password: password
              }
            });
          case 3:
            res = _context2.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', "Welcome ".concat(res.data.data.user.name.split(' ')[0]));
              window.setTimeout(function () {
                location.assign('/');
              }, 1500);
            }
            _context2.next = 10;
            break;
          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            (0, _alert.showAlert)('error', _context2.t0.response.data.message);
          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return function login(_x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();
exports.login = login;
var logout = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var res;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return (0, _axios.default)({
              method: 'POST',
              url: '/api/v1/user/logout'
            });
          case 3:
            res = _context3.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', 'Logging out');
              window.setTimeout(function () {
                location.reload(true);
                location.assign('/');
              }, 1500);
            }
            _context3.next = 10;
            break;
          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            (0, _alert.showAlert)('error', 'Error logging out: try again');
          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 7]]);
  }));
  return function logout() {
    return _ref3.apply(this, arguments);
  };
}();
exports.logout = logout;
var reset = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(email) {
    var res;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return (0, _axios.default)({
              method: 'POST',
              url: '/api/v1/user/forgotPassword',
              data: {
                email: email
              }
            });
          case 3:
            res = _context4.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', 'Reset link has been sent to your email');
            }
            _context4.next = 10;
            break;
          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            (0, _alert.showAlert)('error', _context4.t0.response.data.message);
          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 7]]);
  }));
  return function reset(_x7) {
    return _ref4.apply(this, arguments);
  };
}();
exports.reset = reset;
var setNewPassword = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(obj) {
    var res;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return (0, _axios.default)({
              method: 'PATCH',
              url: '/api/v1/user/resetPassword',
              data: obj
            });
          case 3:
            res = _context5.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', 'New Password set. Log in again');
              window.setTimeout(function () {
                location.reload(true);
                location.assign('/');
              }, 1500);
            }
            _context5.next = 10;
            break;
          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](0);
            (0, _alert.showAlert)('error', _context5.t0.response.data.message);
          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[0, 7]]);
  }));
  return function setNewPassword(_x8) {
    return _ref5.apply(this, arguments);
  };
}();
exports.setNewPassword = setNewPassword;
var deleteAccount = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    var res;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            _context6.next = 3;
            return (0, _axios.default)({
              method: 'DELETE',
              url: '/api/v1/user/deleteAccount'
            });
          case 3:
            res = _context6.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', 'Account Deleted');
              window.setTimeout(function () {
                location.reload(true);
                location.assign('/');
              }, 1500);
            }
            _context6.next = 10;
            break;
          case 7:
            _context6.prev = 7;
            _context6.t0 = _context6["catch"](0);
            (0, _alert.showAlert)('error', _context6.t0.response.data.message);
          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[0, 7]]);
  }));
  return function deleteAccount() {
    return _ref6.apply(this, arguments);
  };
}();
exports.deleteAccount = deleteAccount;
},{"axios":"../../node_modules/axios/index.js","./alert":"alert.js"}],"update.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStatistics = exports.updateScores = exports.updatePassword = exports.updateDetails = void 0;
var _axios = _interopRequireDefault(require("axios"));
var _alert = require("./alert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var updateDetails = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(obj) {
    var res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return (0, _axios.default)({
              method: 'PATCH',
              url: '/api/v1/user/updateDetails',
              data: obj
            });
          case 3:
            res = _context.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', "Details Updated");
              window.setTimeout(function () {
                location.assign('/account/settings');
              }, 1500);
            }
            _context.next = 10;
            break;
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            (0, _alert.showAlert)('error', _context.t0.error.message);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return function updateDetails(_x) {
    return _ref.apply(this, arguments);
  };
}();
exports.updateDetails = updateDetails;
var updatePassword = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(obj) {
    var res;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return (0, _axios.default)({
              method: 'PATCH',
              url: '/api/v1/user/updatePassword',
              data: obj
            });
          case 3:
            res = _context2.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', "Updated Password");
            }
            _context2.next = 10;
            break;
          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            (0, _alert.showAlert)('error', _context2.t0.response.data.message);
          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return function updatePassword(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
exports.updatePassword = updatePassword;
var updateScores = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(objArr) {
    var res;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return (0, _axios.default)({
              method: 'PATCH',
              url: '/api/v1/fixture/updateFixture',
              data: objArr
            });
          case 3:
            res = _context3.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', "Updated ".concat(objArr.length, " fixture").concat(objArr.length != 1 ? 's' : ''));
              window.setTimeout(function () {
                location.assign('/admin/update-scores');
              }, 1500);
            }
            _context3.next = 10;
            break;
          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            (0, _alert.showAlert)('error', _context3.t0.response.data.message);
          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 7]]);
  }));
  return function updateScores(_x3) {
    return _ref3.apply(this, arguments);
  };
}();
exports.updateScores = updateScores;
var updateStatistics = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fixtureIDs) {
    var res;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return (0, _axios.default)({
              method: 'PATCH',
              url: '/api/v1/fixture/updateStatistics',
              data: fixtureIDs
            });
          case 3:
            res = _context4.sent;
            if (res.data.status === 'success') {
              (0, _alert.showAlert)('success', "Updated ".concat(fixtureIDs.length, " fixture").concat(fixtureIDs.length != 1 ? 's' : ''));
              window.setTimeout(function () {
                location.assign('/admin/update-stats');
              }, 1500);
            }
            _context4.next = 10;
            break;
          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](0);
            (0, _alert.showAlert)('error', _context4.t0.response.data.message);
          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 7]]);
  }));
  return function updateStatistics(_x4) {
    return _ref4.apply(this, arguments);
  };
}();
exports.updateStatistics = updateStatistics;
},{"axios":"../../node_modules/axios/index.js","./alert":"alert.js"}],"../../node_modules/moment/moment.js":[function(require,module,exports) {
var define;
var global = arguments[3];
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        return name.match('^[^/\\\\]*$') != null;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.4';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

},{}],"../../node_modules/chart.js/dist/chunks/helpers.segment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.$ = unclipArea;
exports.B = exports.A = void 0;
exports.C = _isPointInArea;
exports.D = getAngleFromPoint;
exports.E = toPadding;
exports.F = each;
exports.G = getMaximumSize;
exports.H = void 0;
exports.I = _getParentNode;
exports.J = readUsedSize;
exports.K = void 0;
exports.L = throttled;
exports.M = _isDomSupported;
exports.N = _factorize;
exports.O = finiteOrDefault;
exports.P = void 0;
exports.Q = callback;
exports.R = _addGrace;
exports.S = _limitValue;
exports.T = void 0;
exports.U = toDegrees;
exports.V = _measureText;
exports.W = _int16Range;
exports.X = _alignPixel;
exports.Y = clipArea;
exports.Z = renderText;
exports._ = _arrayUnique;
exports.a = resolve;
exports.a$ = fontString;
exports.a0 = toFont;
exports.a3 = exports.a2 = exports.a1 = void 0;
exports.a4 = merge;
exports.a5 = _capitalize;
exports.a7 = exports.a6 = void 0;
exports.a8 = _attachContext;
exports.a9 = _createResolver;
exports.aA = overrideTextDirection;
exports.aB = void 0;
exports.aC = restoreTextDirection;
exports.aD = drawPointLegend;
exports.aE = distanceBetweenPoints;
exports.aF = noop;
exports.aG = _setMinAndMaxByKey;
exports.aH = niceNum;
exports.aI = almostWhole;
exports.aJ = almostEquals;
exports.aK = _decimalPlaces;
exports.aM = exports.aL = void 0;
exports.aN = _longestText;
exports.aO = _filterBetween;
exports.aP = _lookup;
exports.aQ = isPatternOrGradient;
exports.aR = getHoverColor;
exports.aS = clone$1;
exports.aT = _merger;
exports.aU = _mergerIf;
exports.aV = _deprecated;
exports.aW = _splitKey;
exports.aX = toFontString;
exports.aY = splineCurve;
exports.aZ = splineCurveMonotone;
exports.a_ = getStyle;
exports.aa = _descriptors;
exports.ab = mergeIf;
exports.ac = void 0;
exports.ad = debounce;
exports.ae = retinaScale;
exports.af = clearCanvas;
exports.ag = void 0;
exports.ah = _elementsEqual;
exports.ai = _isClickEvent;
exports.aj = _isBetween;
exports.ak = _readValueToProps;
exports.al = _updateBezierControlPoints;
exports.am = _computeSegments;
exports.an = _boundSegments;
exports.ao = _steppedInterpolation;
exports.ap = _bezierInterpolation;
exports.aq = _pointInLine;
exports.ar = _steppedLineTo;
exports.as = _bezierCurveTo;
exports.at = drawPoint;
exports.au = addRoundedRectPath;
exports.av = toTRBL;
exports.aw = toTRBLCorners;
exports.ax = _boundSegment;
exports.ay = _normalizeAngle;
exports.az = getRtlAdapter;
exports.b = isArray;
exports.b0 = toLineHeight;
exports.b5 = exports.b4 = exports.b3 = exports.b2 = exports.b1 = void 0;
exports.b6 = _angleDiff;
exports.c = color;
exports.e = exports.d = void 0;
exports.f = resolveObjectKey;
exports.g = isNumberFinite;
exports.h = void 0;
exports.i = isObject;
exports.j = createContext;
exports.k = isNullOrUndef;
exports.l = listenArrayEvents;
exports.n = exports.m = void 0;
exports.o = formatNumber;
exports.p = _angleBetween;
exports.q = _getStartAndCountOfVisiblePoints;
exports.s = exports.r = void 0;
exports.t = toRadians;
exports.u = unlistenArrayEvents;
exports.v = valueOrDefault;
exports.w = _scaleRangesChanged;
exports.x = isNumber;
exports.y = _parseObjectDataRadialScale;
exports.z = getRelativePosition;
/*!
 * Chart.js v4.0.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/**
 * @namespace Chart.helpers
 */ /**
    * An empty function that can be used, for example, for optional callback.
    */
function noop() {
  /* noop */}
/**
 * Returns a unique id, sequentially generated from a global variable.
 */
const uid = (() => {
  let id = 0;
  return () => id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */
exports.ac = uid;
function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
    return true;
  }
  return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */
function isNumberFinite(value) {
  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */
function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
exports.m = toPercentage;
const toDimension = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */
exports.n = toDimension;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return merge(target, source, {
    merger: _mergerIf
  });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
/**
 * @private
 */
function _deprecated(scope, value, previous, current) {
  if (value !== undefined) {
    console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
  }
}
// resolveObjectKey resolver cache
const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  '': v => v,
  // default resolvers
  x: o => o.x,
  y: o => o.y
};
/**
 * @private
 */
function _splitKey(key) {
  const parts = key.split('.');
  const keys = [];
  let tmp = '';
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith('\\')) {
      tmp = tmp.slice(0, -1) + '.';
    } else {
      keys.push(tmp);
      tmp = '';
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return obj => {
    for (const k of keys) {
      if (k === '') {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
/**
 * @private
 */
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = value => typeof value !== 'undefined';
exports.h = defined;
const isFunction = value => typeof value === 'function';
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
exports.a7 = isFunction;
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
/**
 * @param e - The event
 * @private
 */
exports.ag = setsEqual;
function _isClickEvent(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

/**
 * @alias Chart.helpers.math
 * @namespace
 */
const PI = Math.PI;
exports.P = PI;
const TAU = 2 * PI;
exports.T = TAU;
const PITAU = TAU + PI;
exports.b1 = PITAU;
const INFINITY = Number.POSITIVE_INFINITY;
exports.b2 = INFINITY;
const RAD_PER_DEG = PI / 180;
exports.b3 = RAD_PER_DEG;
const HALF_PI = PI / 2;
exports.H = HALF_PI;
const QUARTER_PI = PI / 4;
exports.b4 = QUARTER_PI;
const TWO_THIRDS_PI = PI * 2 / 3;
exports.b5 = TWO_THIRDS_PI;
const log10 = Math.log10;
exports.aM = log10;
const sign = Math.sign;
exports.s = sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
  }

  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || (index => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */
const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? index => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : index => table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */
exports.B = _lookupByKey;
const _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */
exports.A = _rlookupByKey;
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach(key => {
    const method = '_onData' + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach(object => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach(key => {
    delete array[key];
  });
  delete array._chartjs;
}
/**
 * @param items
 */
function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }
  if (set.size === ilen) {
    return items;
  }
  return Array.from(set);
}
function fontString(pixelSize, fontStyle, fontFamily) {
  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
/**
* Request animation polyfill
*/
const requestAnimFrame = function () {
  if (typeof window === 'undefined') {
    return function (callback) {
      return callback();
    };
  }
  return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */
exports.r = requestAnimFrame;
function throttled(fn, thisArg) {
  let ticking = false;
  return function (...args) {
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
/**
 * Debounces calling `fn` for `delay` ms
 */
function debounce(fn, delay) {
  let timeout;
  return function (...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */
const _toLeftRightCenter = align => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */
exports.a1 = _toLeftRightCenter;
const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */
exports.a2 = _alignStartEnd;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */
exports.aB = _textX;
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const {
      iScale,
      _parsed
    } = meta;
    const axis = iScale.axis;
    const {
      min,
      max,
      minDefined,
      maxDefined
    } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
      // @ts-expect-error Need to type _parsed
      _lookupByKey(_parsed, iScale.axis, min).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
      // @ts-expect-error Need to type _parsed
      _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */
function _scaleRangesChanged(meta) {
  const {
    xScale,
    yScale,
    _scaleRanges
  } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
const atEdge = t => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */
const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: t => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
var effects$1 = effects;

/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
exports.e = effects$1;
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
const map$1 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15
};
const hex = [...'0123456789ABCDEF'];
const h1 = b => hex[b & 0xF];
const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = b => (b & 0xF0) >> 4 === (b & 0xF);
const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : '';
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
const map = {
  x: 'dark',
  Z: 'light',
  Y: 're',
  X: 'blu',
  W: 'gr',
  V: 'medium',
  U: 'slate',
  A: 'ee',
  T: 'ol',
  S: 'or',
  B: 'ra',
  C: 'lateg',
  D: 'ights',
  R: 'in',
  Q: 'turquois',
  E: 'hi',
  P: 'ro',
  O: 'al',
  N: 'le',
  M: 'de',
  L: 'yello',
  F: 'en',
  K: 'ch',
  G: 'arks',
  H: 'ea',
  I: 'ightg',
  J: 'wh'
};
const names$1 = {
  OiceXe: 'f0f8ff',
  antiquewEte: 'faebd7',
  aqua: 'ffff',
  aquamarRe: '7fffd4',
  azuY: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '0',
  blanKedOmond: 'ffebcd',
  Xe: 'ff',
  XeviTet: '8a2be2',
  bPwn: 'a52a2a',
  burlywood: 'deb887',
  caMtXe: '5f9ea0',
  KartYuse: '7fff00',
  KocTate: 'd2691e',
  cSO: 'ff7f50',
  cSnflowerXe: '6495ed',
  cSnsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: 'ffff',
  xXe: '8b',
  xcyan: '8b8b',
  xgTMnPd: 'b8860b',
  xWay: 'a9a9a9',
  xgYF: '6400',
  xgYy: 'a9a9a9',
  xkhaki: 'bdb76b',
  xmagFta: '8b008b',
  xTivegYF: '556b2f',
  xSange: 'ff8c00',
  xScEd: '9932cc',
  xYd: '8b0000',
  xsOmon: 'e9967a',
  xsHgYF: '8fbc8f',
  xUXe: '483d8b',
  xUWay: '2f4f4f',
  xUgYy: '2f4f4f',
  xQe: 'ced1',
  xviTet: '9400d3',
  dAppRk: 'ff1493',
  dApskyXe: 'bfff',
  dimWay: '696969',
  dimgYy: '696969',
  dodgerXe: '1e90ff',
  fiYbrick: 'b22222',
  flSOwEte: 'fffaf0',
  foYstWAn: '228b22',
  fuKsia: 'ff00ff',
  gaRsbSo: 'dcdcdc',
  ghostwEte: 'f8f8ff',
  gTd: 'ffd700',
  gTMnPd: 'daa520',
  Way: '808080',
  gYF: '8000',
  gYFLw: 'adff2f',
  gYy: '808080',
  honeyMw: 'f0fff0',
  hotpRk: 'ff69b4',
  RdianYd: 'cd5c5c',
  Rdigo: '4b0082',
  ivSy: 'fffff0',
  khaki: 'f0e68c',
  lavFMr: 'e6e6fa',
  lavFMrXsh: 'fff0f5',
  lawngYF: '7cfc00',
  NmoncEffon: 'fffacd',
  ZXe: 'add8e6',
  ZcSO: 'f08080',
  Zcyan: 'e0ffff',
  ZgTMnPdLw: 'fafad2',
  ZWay: 'd3d3d3',
  ZgYF: '90ee90',
  ZgYy: 'd3d3d3',
  ZpRk: 'ffb6c1',
  ZsOmon: 'ffa07a',
  ZsHgYF: '20b2aa',
  ZskyXe: '87cefa',
  ZUWay: '778899',
  ZUgYy: '778899',
  ZstAlXe: 'b0c4de',
  ZLw: 'ffffe0',
  lime: 'ff00',
  limegYF: '32cd32',
  lRF: 'faf0e6',
  magFta: 'ff00ff',
  maPon: '800000',
  VaquamarRe: '66cdaa',
  VXe: 'cd',
  VScEd: 'ba55d3',
  VpurpN: '9370db',
  VsHgYF: '3cb371',
  VUXe: '7b68ee',
  VsprRggYF: 'fa9a',
  VQe: '48d1cc',
  VviTetYd: 'c71585',
  midnightXe: '191970',
  mRtcYam: 'f5fffa',
  mistyPse: 'ffe4e1',
  moccasR: 'ffe4b5',
  navajowEte: 'ffdead',
  navy: '80',
  Tdlace: 'fdf5e6',
  Tive: '808000',
  TivedBb: '6b8e23',
  Sange: 'ffa500',
  SangeYd: 'ff4500',
  ScEd: 'da70d6',
  pOegTMnPd: 'eee8aa',
  pOegYF: '98fb98',
  pOeQe: 'afeeee',
  pOeviTetYd: 'db7093',
  papayawEp: 'ffefd5',
  pHKpuff: 'ffdab9',
  peru: 'cd853f',
  pRk: 'ffc0cb',
  plum: 'dda0dd',
  powMrXe: 'b0e0e6',
  purpN: '800080',
  YbeccapurpN: '663399',
  Yd: 'ff0000',
  Psybrown: 'bc8f8f',
  PyOXe: '4169e1',
  saddNbPwn: '8b4513',
  sOmon: 'fa8072',
  sandybPwn: 'f4a460',
  sHgYF: '2e8b57',
  sHshell: 'fff5ee',
  siFna: 'a0522d',
  silver: 'c0c0c0',
  skyXe: '87ceeb',
  UXe: '6a5acd',
  UWay: '708090',
  UgYy: '708090',
  snow: 'fffafa',
  sprRggYF: 'ff7f',
  stAlXe: '4682b4',
  tan: 'd2b48c',
  teO: '8080',
  tEstN: 'd8bfd8',
  tomato: 'ff6347',
  Qe: '40e0d0',
  viTet: 'ee82ee',
  JHt: 'f5deb3',
  wEte: 'ffffff',
  wEtesmoke: 'f5f5f5',
  Lw: 'ffff00',
  LwgYF: '9acd32'
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {
    r: 0,
    g: 0,
    b: 0,
    a: 255
  };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {
        r: input[0],
        g: input[1],
        b: input[2],
        a: 255
      };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
function index_esm(input) {
  return new Color(input);
}
function isPatternOrGradient(value) {
  if (value && typeof value === 'object') {
    const type = value.toString();
    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors = ['color', 'borderColor', 'backgroundColor'];
function applyAnimationsDefaults(defaults) {
  defaults.set('animation', {
    delay: undefined,
    duration: 1000,
    easing: 'easeOutQuart',
    fn: undefined,
    from: undefined,
    loop: undefined,
    to: undefined,
    type: undefined
  });
  defaults.describe('animation', {
    _fallback: false,
    _indexable: false,
    _scriptable: name => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
  });
  defaults.set('animations', {
    colors: {
      type: 'color',
      properties: colors
    },
    numbers: {
      type: 'number',
      properties: numbers
    }
  });
  defaults.describe('animations', {
    _fallback: 'animation'
  });
  defaults.set('transitions', {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: 'transparent'
        },
        visible: {
          type: 'boolean',
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: 'transparent'
        },
        visible: {
          type: 'boolean',
          easing: 'linear',
          fn: v => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults) {
  defaults.set('layout', {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
const formatters = {
  values(value) {
    return isArray(value) ? value : '' + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return '';
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
exports.aL = Ticks;
function applyScaleDefaults(defaults) {
  defaults.set('scale', {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: 'ticks',
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0.0,
      width: 1
    },
    title: {
      display: false,
      text: '',
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: '',
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: 'center',
      crossAlign: 'near',
      showLabelBackdrop: false,
      backdropColor: 'rgba(255, 255, 255, 0.75)',
      backdropPadding: 2
    }
  });
  defaults.route('scale.ticks', 'color', '', 'color');
  defaults.route('scale.grid', 'color', '', 'borderColor');
  defaults.route('scale.border', 'color', '', 'borderColor');
  defaults.route('scale.title', 'color', '', 'color');
  defaults.describe('scale', {
    _fallback: false,
    _scriptable: name => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
    _indexable: name => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
  });
  defaults.describe('scales', {
    _fallback: 'scale'
  });
  defaults.describe('scale.ticks', {
    _scriptable: name => name !== 'backdropPadding' && name !== 'callback',
    _indexable: name => name !== 'backdropPadding'
  });
}
const overrides = Object.create(null);
exports.a3 = overrides;
const descriptors = Object.create(null);
exports.a6 = descriptors;
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split('.');
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ''), scope);
}
class Defaults {
  constructor(_descriptors, _appliers) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};
    this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach(apply => apply(this));
  }
}
var defaults = /* #__PURE__ */new Defaults({
  _scriptable: name => !name.startsWith('on'),
  _indexable: name => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);
exports.d = defaults;
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === 'object') {
    type = style.toString();
    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case 'triangle':
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case 'rectRounded':
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case 'rect':
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case 'rectRot':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case 'crossRot':
      rad += QUARTER_PI;
    case 'cross':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case 'star':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case 'line':
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case 'dash':
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function addRoundedRectPath(ctx, rect) {
  const {
    x,
    y,
    w,
    h,
    radius
  } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
    * Converts the given line height `value` in pixels for a specific font `size`.
    * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
    * @param size - The font size (in pixels) used to resolve relative `value`.
    * @returns The effective line height in pixels (size * 1.2 if value is invalid).
    * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
    * @since 2.7.0
    */
function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case 'px':
      return value;
    case '%':
      value /= 100;
      break;
  }
  return size * value;
}
const numberOrZero = v => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */
function toTRBL(value) {
  return _readValueToProps(value, {
    top: 'y',
    right: 'x',
    bottom: 'y',
    left: 'x'
  });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */
function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = undefined;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === undefined) {
      continue;
    }
    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }
    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */
function _addGrace(minmax, grace, beginAtZero) {
  const {
    min,
    max
  } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
/**
 * Create a context inheriting parentContext
 * @param parentContext
 * @param context
 * @returns
 */
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }
  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: scope => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults = {
  scriptable: true,
  indexable: true
}) {
  const {
    _scriptable = defaults.scriptable,
    _indexable = defaults.indexable,
    _allKeys = defaults.allKeys
  } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const {
    _proxy,
    _context,
    _subProxy,
    _descriptors: descriptors
  } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const {
    _proxy,
    _context,
    _subProxy,
    _stack
  } = target;
  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const {
    _proxy,
    _context,
    _subProxy,
    _descriptors: descriptors
  } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter(s => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set), [''], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }
  return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const {
    iScale
  } = meta;
  const {
    key = 'r'
  } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index = i + start;
    item = data[index];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = indexAxis => indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  // Props to Rob Spencer at scaled innovation for his post on splining between points
  // http://scaledinnovation.com/analytics/splines/aboutSplines.html
  // This function must also respect "skipped" points
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  // If all points are the same, s01 & s02 will be inf
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01; // scaling factor for triangle Ta
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
/**
 * Adjust tangents to ensure monotonic properties
 */
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
/**
 * This function calculates BÃ©zier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */
function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  // Calculate slopes (deltaK) and initialize tangents (mK)
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
/**
 * @private
 */
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  // Only consider points that are drawn in case the spanGaps option is used
  if (options.spanGaps) {
    points = points.filter(pt => !pt.skip);
  }
  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}

/**
 * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
 * necessary to avoid duplicates with `export * from './helpers`; see
 * https://github.com/microsoft/TypeScript/issues/46011
 * @typedef { import("../core/core.controller").default } dom.Chart
 * @typedef { import('../../types').ChartEvent } ChartEvent
 */ /**
    * @private
    */
function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * @private
 */
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }
  return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf('%') !== -1) {
      // percentage * size in dimension
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = element => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ['top', 'right', 'bottom', 'left'];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {
    offsetX,
    offsetY
  } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */
function getRelativePosition(event, chart) {
  if ('native' in event) {
    return event;
  }
  const {
    canvas,
    currentDevicePixelRatio
  } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {
    x,
    y,
    box
  } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {
    width,
    height
  } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect(); // this is the border box of the container
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = v => Math.round(v * 10) / 10;
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {
    width,
    height
  } = containerSize;
  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    // https://github.com/chartjs/Chart.js/issues/4659
    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  // If no style has been set on the canvas, the render size is used as display size,
  // making the chart visually bigger, so let's enforce it to the "correct" values.
  // See https://github.com/chartjs/Chart.js/issues/3575
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */
const supportsEventListenerOptions = function () {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {
    // continue regardless of error
  }
  return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */
exports.K = supportsEventListenerOptions;
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}

/**
 * @private
 */
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
/**
 * @private
 */
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
/**
 * @private
 */
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
const getRightToLeftAdapter = function (rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === 'center') {
        return align;
      }
      return align === 'right' ? 'left' : 'right';
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function () {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {},
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: x => x
  };
}
function normalizeSegment({
  start,
  end,
  count,
  loop,
  style
}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const {
    property,
    start: startBound,
    end: endBound
  } = bounds;
  const {
    between,
    normalize
  } = propertyFn(property);
  const count = points.length;
  let {
    start,
    end,
    loop
  } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const {
    property,
    start: startBound,
    end: endBound
  } = bounds;
  const count = points.length;
  const {
    compare,
    between,
    normalize
  } = propertyFn(property);
  const {
    start,
    end,
    loop,
    style
  } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const {
    start,
    end
  } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{
      start,
      end,
      loop
    }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const {
    _datasetIndex: datasetIndex,
    options: {
      spanGaps
    }
  } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}
},{}],"../../node_modules/chart.js/dist/chart.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubTitle = exports.ScatterController = exports.Scale = exports.RadialLinearScale = exports.RadarController = exports.PolarAreaController = exports.PointElement = exports.PieController = exports.LogarithmicScale = exports.LinearScale = exports.LineElement = exports.LineController = exports.Legend = exports.Interaction = exports.Filler = exports.Element = exports.DoughnutController = exports.DomPlatform = exports.Decimation = exports.DatasetController = exports.Colors = exports.Chart = exports.CategoryScale = exports.BubbleController = exports.BasicPlatform = exports.BasePlatform = exports.BarElement = exports.BarController = exports.ArcElement = exports.Animations = exports.Animation = void 0;
Object.defineProperty(exports, "Ticks", {
  enumerable: true,
  get: function () {
    return _helpersSegment.aL;
  }
});
exports._adapters = exports.Tooltip = exports.Title = exports.TimeSeriesScale = exports.TimeScale = void 0;
exports._detectPlatform = _detectPlatform;
exports.controllers = exports.animator = void 0;
Object.defineProperty(exports, "defaults", {
  enumerable: true,
  get: function () {
    return _helpersSegment.d;
  }
});
exports.scales = exports.registry = exports.registerables = exports.plugins = exports.layouts = exports.elements = void 0;
var _helpersSegment = require("./chunks/helpers.segment.js");
/*!
 * Chart.js v4.0.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */

class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = _helpersSegment.r.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, 'progress');
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, 'complete');
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), 'complete');
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = /* #__PURE__ */new Animator();
exports.animator = animator;
const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = (0, _helpersSegment.c)(from || transparent);
    const c1 = c0.valid && (0, _helpersSegment.c)(to || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = (0, _helpersSegment.a)([cfg.to, to, currentValue, cfg.from]);
    const from = (0, _helpersSegment.a)([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = _helpersSegment.e[cfg.easing] || _helpersSegment.e.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = (0, _helpersSegment.a)([cfg.to, to, currentValue, cfg.from]);
      this._from = (0, _helpersSegment.a)([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
exports.Animation = Animation;
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!(0, _helpersSegment.i)(config)) {
      return;
    }
    const animationOptions = Object.keys(_helpersSegment.d.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];
      if (!(0, _helpersSegment.i)(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      ((0, _helpersSegment.b)(cfg.properties) && cfg.properties || [key]).forEach(prop => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {});
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === '$') {
        continue;
      }
      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
exports.Animations = Animations;
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if ((0, _helpersSegment.i)(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if ((0, _helpersSegment.g)(otherValue) && (singleMode || value === 0 || (0, _helpersSegment.s)(value) === (0, _helpersSegment.s)(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const {
    min,
    max,
    minDefined,
    maxDefined
  } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const {
    chart,
    _cachedMeta: meta
  } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {
    iScale,
    vScale,
    index: datasetIndex
  } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {
      [iAxis]: index,
      [vAxis]: value
    } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return (0, _helpersSegment.j)(parent, {
    active: false,
    dataset: undefined,
    datasetIndex: index,
    index,
    mode: 'default',
    type: 'dataset'
  });
}
function createDataContext(parent, index, element) {
  return (0, _helpersSegment.j)(parent, {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = mode => mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
class DatasetController {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = undefined;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
    const xid = meta.xAxisID = (0, _helpersSegment.v)(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = (0, _helpersSegment.v)(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = (0, _helpersSegment.v)(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      (0, _helpersSegment.u)(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if ((0, _helpersSegment.i)(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        (0, _helpersSegment.u)(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        (0, _helpersSegment.l)(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const {
      _cachedMeta: meta,
      _data: data
    } = this;
    const {
      iScale,
      _stacked
    } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if ((0, _helpersSegment.b)(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if ((0, _helpersSegment.i)(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const {
      iScale,
      vScale
    } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const {
      xScale,
      yScale
    } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const {
      xScale,
      yScale
    } = meta;
    const {
      xAxisKey = 'x',
      yAxisKey = 'y'
    } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse((0, _helpersSegment.f)(item, xAxisKey), index),
        y: yScale.parse((0, _helpersSegment.f)(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const {
      min: otherMin,
      max: otherMax
    } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !(0, _helpersSegment.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if ((0, _helpersSegment.g)(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || 'default');
    meta._clip = toClip((0, _helpersSegment.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {}
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = 'default', index) {
    const active = mode === 'active';
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && (0, _helpersSegment.h)(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names = Object.keys(_helpersSegment.d.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = arr => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, 'reset');
    }
  }
  updateElements(element, start, count, mode) {}
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(['_removeElements', start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(['_insertElements', start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }
}
exports.DatasetController = DatasetController;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = (0, _helpersSegment._)(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if ((0, _helpersSegment.h)(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = undefined;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if ((0, _helpersSegment.k)(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if ((0, _helpersSegment.b)(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return (0, _helpersSegment.s)(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }
  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const {
    start,
    end,
    reverse,
    top,
    bottom
  } = borderProps(properties);
  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, {
  inflateAmount
}, ratio) {
  properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  static id = 'bar';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'base', 'width', 'height']
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: 'category',
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: 'linear',
        beginAtZero: true
      }
    }
  };
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const {
      iScale,
      vScale
    } = meta;
    const {
      xAxisKey = 'x',
      yAxisKey = 'y'
    } = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse((0, _helpersSegment.f)(obj, iAxisKey), i);
      parsed.push(parseValue((0, _helpersSegment.f)(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {
      iScale,
      vScale
    } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === 'reset';
    const {
      index,
      _cachedMeta: {
        vScale
      }
    } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || (0, _helpersSegment.k)(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const {
      iScale
    } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter(meta => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = meta => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if ((0, _helpersSegment.k)(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== undefined && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(undefined);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== undefined ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const {
      _cachedMeta: {
        vScale,
        _stacked
      },
      options: {
        base: baseValue,
        minBarLength
      }
    } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && (0, _helpersSegment.s)(value) !== (0, _helpersSegment.s)(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !(0, _helpersSegment.k)(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = (0, _helpersSegment.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = (0, _helpersSegment.v)(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
exports.BarController = BarController;
class BubbleController extends DatasetController {
  static id = 'bubble';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'point',
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'borderWidth', 'radius']
      }
    }
  };
  static overrides = {
    scales: {
      x: {
        type: 'linear'
      },
      y: {
        type: 'linear'
      }
    }
  };
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = (0, _helpersSegment.v)(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = (0, _helpersSegment.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const {
      xScale,
      yScale
    } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index] || '',
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale
    } = this._cachedMeta;
    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== 'active') {
      values.radius = 0;
    }
    values.radius += (0, _helpersSegment.v)(parsed && parsed._custom, radius);
    return values;
  }
}
exports.BubbleController = BubbleController;
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < _helpersSegment.T) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => (0, _helpersSegment.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => (0, _helpersSegment.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(_helpersSegment.H, startY, endY);
    const minX = calcMin(_helpersSegment.P, startX, endX);
    const minY = calcMin(_helpersSegment.P + _helpersSegment.H, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
class DoughnutController extends DatasetController {
  static id = 'doughnut';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'arc',
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
      }
    },
    cutout: '50%',
    rotation: 0,
    circumference: 360,
    radius: '100%',
    spacing: 0,
    indexAxis: 'r'
  };
  static descriptors = {
    _scriptable: name => name !== 'spacing',
    _indexable: name => name !== 'spacing'
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const {
                labels: {
                  pointStyle,
                  color
                }
              } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color,
                  lineWidth: style.borderWidth,
                  pointStyle: pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  };
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }
  linkScales() {}
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = i => +data[i];
      if ((0, _helpersSegment.i)(data[start])) {
        const {
          key = 'value'
        } = this._parsing;
        getter = i => +(0, _helpersSegment.f)(data[i], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return (0, _helpersSegment.t)(this.options.rotation - 90);
  }
  _getCircumference() {
    return (0, _helpersSegment.t)(this.options.circumference);
  }
  _getRotationExtents() {
    let min = _helpersSegment.T;
    let max = -_helpersSegment.T;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const {
      chartArea
    } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min((0, _helpersSegment.m)(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const {
      circumference,
      rotation
    } = this._getRotationExtents();
    const {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = (0, _helpersSegment.n)(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / _helpersSegment.T);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return _helpersSegment.T * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = (0, _helpersSegment.o)(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max((0, _helpersSegment.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
exports.DoughnutController = DoughnutController;
class LineController extends DatasetController {
  static id = 'line';
  static defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    showLine: true,
    spanGaps: false
  };
  static overrides = {
    scales: {
      _index_: {
        type: 'category'
      },
      _value_: {
        type: 'linear'
      }
    }
  };
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const {
      dataset: line,
      data: points = [],
      _dataset
    } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {
      start,
      count
    } = (0, _helpersSegment.q)(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if ((0, _helpersSegment.w)(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale,
      _stacked,
      _dataset
    } = this._cachedMeta;
    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {
      spanGaps,
      segment
    } = this.options;
    const maxGapLength = (0, _helpersSegment.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = (0, _helpersSegment.k)(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
exports.LineController = LineController;
class PolarAreaController extends DatasetController {
  static id = 'polarArea';
  static defaults = {
    dataElementType: 'arc',
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
      }
    },
    indexAxis: 'r',
    startAngle: 0
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const {
                labels: {
                  pointStyle,
                  color
                }
              } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color,
                  lineWidth: style.borderWidth,
                  pointStyle: pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = (0, _helpersSegment.o)(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _helpersSegment.y.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index) => {
      const parsed = this.getParsed(index).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _helpersSegment.P;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? (0, _helpersSegment.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }
}
exports.PolarAreaController = PolarAreaController;
class PieController extends DoughnutController {
  static id = 'pie';
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: '100%'
  };
}
exports.PieController = PieController;
class RadarController extends DatasetController {
  static id = 'radar';
  static defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: true,
    elements: {
      line: {
        fill: 'start'
      }
    }
  };
  static overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: 'radialLinear'
      }
    }
  };
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _helpersSegment.y.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== 'resize') {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, undefined, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === 'reset';
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
exports.RadarController = RadarController;
class ScatterController extends DatasetController {
  static id = 'scatter';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'point',
    showLine: false,
    fill: false
  };
  static overrides = {
    interaction: {
      mode: 'point'
    },
    scales: {
      x: {
        type: 'linear'
      },
      y: {
        type: 'linear'
      }
    }
  };
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const {
      xScale,
      yScale
    } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index] || '',
      value: '(' + x + ', ' + y + ')'
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const {
      data: points = []
    } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {
      start,
      count
    } = (0, _helpersSegment.q)(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if ((0, _helpersSegment.w)(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const {
        dataset: line,
        _dataset
      } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, undefined, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const {
      showLine
    } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement('line');
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale,
      _stacked,
      _dataset
    } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {
      spanGaps,
      segment
    } = this.options;
    const maxGapLength = (0, _helpersSegment.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = (0, _helpersSegment.k)(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
exports.ScatterController = ScatterController;
var controllers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BarController: BarController,
  BubbleController: BubbleController,
  DoughnutController: DoughnutController,
  LineController: LineController,
  PolarAreaController: PolarAreaController,
  PieController: PieController,
  RadarController: RadarController,
  ScatterController: ScatterController
});

/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */
exports.controllers = controllers;
function abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */
class DateAdapterBase {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  constructor(options) {
    this.options = options || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {}
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
}
var adapters = {
  _date: DateAdapterBase
};
exports._adapters = adapters;
function binarySearch(metaset, axis, value, intersect) {
  const {
    controller,
    data,
    _sorted
  } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _helpersSegment.A : _helpersSegment.B;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {
      index,
      data
    } = metasets[i];
    const {
      lo,
      hi
    } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function (pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function (element, datasetIndex, index) {
    if (!includeInvisible && !(0, _helpersSegment.C)(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const {
      startAngle,
      endAngle
    } = element.getProps(['startAngle', 'endAngle'], useFinalPosition);
    const {
      angle
    } = (0, _helpersSegment.D)(element, {
      x: position.x,
      y: position.y
    });
    if ((0, _helpersSegment.p)(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{
        element,
        datasetIndex,
        index
      }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      const axis = options.axis || 'x';
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach(meta => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = (0, _helpersSegment.z)(e, chart);
      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
    }
  }
};
exports.Interaction = Interaction;
const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({
      position: pos,
      options: {
        stack,
        stackWeight = 1
      }
    } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts) {
  const stacks = {};
  for (const wrap of layouts) {
    const {
      stack,
      pos,
      stackWeight
    } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {
    vBoxMaxWidth,
    hBoxMaxHeight
  } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {
      fullSize
    } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const {
    pos,
    box
  } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!(0, _helpersSegment.i)(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions.forEach(pos => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const {
      same,
      other
    } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {
    x,
    y
  } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if ((0, _helpersSegment.h)(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height1 = chartArea.h * weight;
      const width1 = stack.size || box.width;
      if ((0, _helpersSegment.h)(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);
      }
      stack.start = x;
      stack.placed += height1;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    item._layers = item._layers || function () {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = (0, _helpersSegment.E)(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    (0, _helpersSegment.F)(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, (0, _helpersSegment.E)(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    (0, _helpersSegment.F)(boxes.chartArea, layout => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
exports.layouts = layouts;
class BasePlatform {
  acquireContext(canvas, aspectRatio) {}
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {}
  removeEventListener(chart, type, listener) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {}
}
exports.BasePlatform = BasePlatform;
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
exports.BasicPlatform = BasicPlatform;
const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
const isNullOrEmpty = value => value === null || value === '';
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = (0, _helpersSegment.J)(canvas, 'width');
    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = (0, _helpersSegment.J)(canvas, 'height');
      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = _helpersSegment.K ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {
    x,
    y
  } = (0, _helpersSegment.z)(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && (0, _helpersSegment.I)(canvas);
  if (!container) {
    return;
  }
  const resize = (0, _helpersSegment.L)((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = (0, _helpersSegment.L)(event => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach(prop => {
      const value = initial[prop];
      if ((0, _helpersSegment.k)(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach(key => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return (0, _helpersSegment.G)(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = (0, _helpersSegment.I)(canvas);
    return !!(container && container.isConnected);
  }
}
exports.DomPlatform = DomPlatform;
function _detectPlatform(canvas) {
  if (!(0, _helpersSegment.M)() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
class Element {
  static defaults = {};
  static defaultRoutes = undefined;
  active = false;
  tooltipPosition(useFinalPosition) {
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return (0, _helpersSegment.x)(this.x) && (0, _helpersSegment.x)(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      // let's not create an object, if not needed
      return this;
    }
    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
exports.Element = Element;
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, (0, _helpersSegment.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, (0, _helpersSegment.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = (0, _helpersSegment.N)(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = (0, _helpersSegment.v)(majorStart, 0);
  const end = Math.min((0, _helpersSegment.v)(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = align => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  (0, _helpersSegment.F)(caches, cache => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = (0, _helpersSegment.a0)(options.font, fallback);
  const padding = (0, _helpersSegment.E)(options.padding);
  const lines = (0, _helpersSegment.b)(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return (0, _helpersSegment.j)(parent, {
    scale,
    type: 'scale'
  });
}
function createTickContext(parent, index, tick) {
  return (0, _helpersSegment.j)(parent, {
    tick,
    index,
    type: 'tick'
  });
}
function titleAlign(align, position, reverse) {
  let ret = (0, _helpersSegment.a1)(align);
  if (reverse && position !== 'right' || !reverse && position === 'right') {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const {
    top,
    left,
    bottom,
    right,
    chart
  } = scale;
  const {
    chartArea,
    scales
  } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = (0, _helpersSegment.a2)(align, left, right);
    if ((0, _helpersSegment.i)(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if ((0, _helpersSegment.i)(position)) {
      const positionAxisID1 = Object.keys(position)[0];
      const value1 = position[positionAxisID1];
      titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = (0, _helpersSegment.a2)(align, bottom, top);
    rotation = position === 'left' ? -_helpersSegment.H : _helpersSegment.H;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let {
      _userMin,
      _userMax,
      _suggestedMin,
      _suggestedMax
    } = this;
    _userMin = (0, _helpersSegment.O)(_userMin, Number.POSITIVE_INFINITY);
    _userMax = (0, _helpersSegment.O)(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = (0, _helpersSegment.O)(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = (0, _helpersSegment.O)(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: (0, _helpersSegment.O)(_userMin, _suggestedMin),
      max: (0, _helpersSegment.O)(_userMax, _suggestedMax),
      minDefined: (0, _helpersSegment.g)(_userMin),
      maxDefined: (0, _helpersSegment.g)(_userMax)
    };
  }
  getMinMax(canStack) {
    let {
      min,
      max,
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: (0, _helpersSegment.O)(min, (0, _helpersSegment.O)(max, min)),
      max: (0, _helpersSegment.O)(max, (0, _helpersSegment.O)(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    (0, _helpersSegment.Q)(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const {
      beginAtZero,
      grace,
      ticks: tickOpts
    } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = (0, _helpersSegment.R)(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    (0, _helpersSegment.Q)(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    (0, _helpersSegment.Q)(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    (0, _helpersSegment.Q)(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    (0, _helpersSegment.Q)(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }
  beforeTickToLabelConversion() {
    (0, _helpersSegment.Q)(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = (0, _helpersSegment.Q)(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    (0, _helpersSegment.Q)(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    (0, _helpersSegment.Q)(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = (0, _helpersSegment.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = (0, _helpersSegment.U)(Math.min(Math.asin((0, _helpersSegment.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0, _helpersSegment.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0, _helpersSegment.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    (0, _helpersSegment.Q)(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {}
  beforeFit() {
    (0, _helpersSegment.Q)(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const {
      chart,
      options: {
        ticks: tickOpts,
        title: titleOpts,
        grid: gridOpts
      }
    } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const {
          first,
          last,
          widest,
          highest
        } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = (0, _helpersSegment.t)(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const {
      ticks: {
        align,
        padding
      },
      position
    } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && this.axis === 'x';
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else if (align !== 'inner') {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    (0, _helpersSegment.Q)(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const {
      axis,
      position
    } = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if ((0, _helpersSegment.k)(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const {
      ctx,
      _longestTextCache: caches
    } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!(0, _helpersSegment.k)(label) && !(0, _helpersSegment.b)(label)) {
        width = (0, _helpersSegment.V)(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if ((0, _helpersSegment.b)(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!(0, _helpersSegment.k)(nestedLabel) && !(0, _helpersSegment.b)(nestedLabel)) {
            width = (0, _helpersSegment.V)(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = idx => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {}
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return (0, _helpersSegment.W)(this._alignToPixels ? (0, _helpersSegment.X)(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const {
      min,
      max
    } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = (0, _helpersSegment.t)(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== 'auto') {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const {
      grid,
      position,
      border
    } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function (pixel) {
      return (0, _helpersSegment.X)(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === 'top') {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if ((0, _helpersSegment.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if ((0, _helpersSegment.i)(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = (0, _helpersSegment.v)(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === undefined) {
        continue;
      }
      alignedLineValue = (0, _helpersSegment.X)(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const {
      position,
      ticks: optionTicks
    } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const {
      align,
      crossAlign,
      padding,
      mirror
    } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -(0, _helpersSegment.t)(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';
    if (position === 'top') {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret1 = this._getYAxisLabelAlignment(tl);
      textAlign = ret1.textAlign;
      x = ret1.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if ((0, _helpersSegment.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if ((0, _helpersSegment.i)(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = (0, _helpersSegment.b)(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === 'inner') {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? 'right' : 'left';
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? 'left' : 'right';
          } else {
            tickTextAlign = 'center';
          }
        }
        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = (0, _helpersSegment.E)(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case 'middle':
            top -= height / 2;
            break;
          case 'bottom':
            top -= height;
            break;
        }
        switch (textAlign) {
          case 'center':
            left -= width / 2;
            break;
          case 'right':
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const {
      position,
      ticks
    } = this.options;
    const rotation = -(0, _helpersSegment.t)(this.labelRotation);
    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }
    let align = 'center';
    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    } else if (ticks.align === 'inner') {
      align = 'inner';
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const {
      position,
      ticks: {
        crossAlign,
        mirror,
        padding
      }
    } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === 'left') {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= widest / 2;
        } else {
          textAlign = 'left';
          x = this.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= widest / 2;
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = this.right;
        }
      }
    } else {
      textAlign = 'right';
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === 'left' || position === 'right') {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === 'top' || position === 'bottom') {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const {
      ctx,
      options: {
        backgroundColor
      },
      left,
      top,
      width,
      height
    } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex(t => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const {
      chart,
      ctx,
      options: {
        border,
        grid
      }
    } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = (0, _helpersSegment.X)(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = (0, _helpersSegment.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = (0, _helpersSegment.X)(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = (0, _helpersSegment.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      (0, _helpersSegment.Y)(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      let y = item.textOffset;
      (0, _helpersSegment.Z)(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      (0, _helpersSegment.$)(ctx);
    }
  }
  drawTitle() {
    const {
      ctx,
      options: {
        position,
        title,
        reverse
      }
    } = this;
    if (!title.display) {
      return;
    }
    const font = (0, _helpersSegment.a0)(title.font);
    const padding = (0, _helpersSegment.E)(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === 'bottom' || position === 'center' || (0, _helpersSegment.i)(position)) {
      offset += padding.bottom;
      if ((0, _helpersSegment.b)(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const {
      titleX,
      titleY,
      maxWidth,
      rotation
    } = titleArgs(this, offset, position, align);
    (0, _helpersSegment.Z)(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = (0, _helpersSegment.v)(opts.grid && opts.grid.z, -1);
    const bz = (0, _helpersSegment.v)(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: chartArea => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: chartArea => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: bz,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: chartArea => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + 'AxisID';
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return (0, _helpersSegment.a0)(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
exports.Scale = Scale;
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + '.' + id;
    if (!id) {
      throw new Error('class does not have id: ' + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      _helpersSegment.d.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in _helpersSegment.d[scope]) {
      delete _helpersSegment.d[scope][id];
      if (this.override) {
        delete _helpersSegment.a3[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = (0, _helpersSegment.a4)(Object.create(null), [parentScope ? _helpersSegment.d.get(parentScope) : {}, _helpersSegment.d.get(scope), item.defaults]);
  _helpersSegment.d.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    _helpersSegment.d.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    _helpersSegment.d.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
    this.elements = new TypedRegistry(Element, 'elements');
    this.plugins = new TypedRegistry(Object, 'plugins');
    this.scales = new TypedRegistry(Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each('register', args);
  }
  remove(...args) {
    this._each('unregister', args);
  }
  addControllers(...args) {
    this._each('register', args, this.controllers);
  }
  addElements(...args) {
    this._each('register', args, this.elements);
  }
  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }
  addScales(...args) {
    this._each('register', args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }
  getElement(id) {
    return this._get(id, this.elements, 'element');
  }
  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }
  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }
  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }
  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }
  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }
  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach(arg => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        (0, _helpersSegment.F)(arg, item => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry, component) {
    const camelMethod = (0, _helpersSegment.a5)(method);
    (0, _helpersSegment.Q)(component['before' + camelMethod], [], component);
    registry[method](component);
    (0, _helpersSegment.Q)(component['after' + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }
    return item;
  }
}
var registry = /* #__PURE__ */new Registry();
exports.registry = registry;
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === 'beforeInit') {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, 'install');
    }
    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors, chart, hook, args);
    if (hook === 'afterDestroy') {
      this._notify(descriptors, chart, 'stop');
      this._notify(this._init, chart, 'uninstall');
    }
    return result;
  }
  _notify(descriptors, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if ((0, _helpersSegment.Q)(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!(0, _helpersSegment.k)(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = (0, _helpersSegment.v)(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;
    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i1 = 0; i1 < local.length; i1++) {
    const plugin = local[i1];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, {
  plugins,
  localIds
}, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, {
  plugin,
  local
}, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [''], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = _helpersSegment.d.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }
  if (position === 'left' || position === 'right') {
    return 'y';
  }
}
function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y' || id === 'r') {
    return id;
  }
  id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);
  if (id) {
    return id;
  }
  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}
function mergeScaleConfig(config, options) {
  const chartDefaults = _helpersSegment.a3[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];
    if (!(0, _helpersSegment.i)(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = (0, _helpersSegment.ab)(Object.create(null), [{
      axis
    }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = _helpersSegment.a3[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || axis;
      scales[id] = scales[id] || Object.create(null);
      (0, _helpersSegment.ab)(scales[id], [{
        axis
      }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    (0, _helpersSegment.ab)(scale, [_helpersSegment.d.scales[scale.type], _helpersSegment.d.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = (0, _helpersSegment.v)(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set, obj, key) => {
  const opts = (0, _helpersSegment.f)(obj, key);
  if (opts !== undefined) {
    set.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, '']]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [[`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`], [`datasets.${datasetType}`, '']]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[`datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, '']]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[`plugins.${id}`, ...(plugin.additionalOptionScopes || [])]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const {
      options,
      type
    } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }
      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, _helpersSegment.a3[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, _helpersSegment.d, key));
      keys.forEach(key => addIfFound(scopes, _helpersSegment.a6, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const {
      options,
      type
    } = this;
    return [options, _helpersSegment.a3[type] || {}, _helpersSegment.d.datasets[type] || {}, {
      type
    }, _helpersSegment.d, _helpersSegment.a6];
  }
  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {
      $shared: true
    };
    const {
      resolver,
      subPrefixes
    } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names)) {
      result.$shared = false;
      context = (0, _helpersSegment.a7)(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = (0, _helpersSegment.a8)(resolver, context, subResolver);
    }
    for (const prop of names) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {
      resolver
    } = getResolver(this._resolverCache, scopes, prefixes);
    return (0, _helpersSegment.i)(context) ? (0, _helpersSegment.a8)(resolver, context, undefined, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = (0, _helpersSegment.a9)(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = value => (0, _helpersSegment.i)(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || (0, _helpersSegment.a7)(value[key]), false);
function needContext(proxy, names) {
  const {
    isScriptable,
    isIndexable
  } = (0, _helpersSegment.aa)(proxy);
  for (const prop of names) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && ((0, _helpersSegment.a7)(value) || hasFunction(value)) || indexable && (0, _helpersSegment.b)(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.0.1";
const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}
function compare2Level(l1, l2) {
  return function (a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  (0, _helpersSegment.Q)(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  (0, _helpersSegment.Q)(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
  if ((0, _helpersSegment.M)() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = key => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter(c => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === 'mouseout') {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getDatasetArea(meta) {
  const {
    xScale,
    yScale
  } = meta;
  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}
class Chart {
  static defaults = _helpersSegment.d;
  static instances = instances;
  static overrides = _helpersSegment.a3;
  static registry = registry;
  static version = version;
  static getChart = getChart;
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = (0, _helpersSegment.ac)();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = (0, _helpersSegment.ad)(mode => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, 'complete', onAnimationsComplete);
    animator.listen(this, 'progress', onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const {
      options: {
        aspectRatio,
        maintainAspectRatio
      },
      width,
      height,
      _aspectRatio
    } = this;
    if (!(0, _helpersSegment.k)(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins('beforeInit');
    if (this.options.responsive) {
      this.resize();
    } else {
      (0, _helpersSegment.ae)(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins('afterInit');
    return this;
  }
  clear() {
    (0, _helpersSegment.af)(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? 'resize' : 'attach';
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!(0, _helpersSegment.ae)(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins('resize', {
      size: newSize
    });
    (0, _helpersSegment.Q)(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    (0, _helpersSegment.F)(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map(id => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === 'r';
        const isHorizontal = axis === 'x';
        return {
          options: scaleOptions,
          dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
          dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
        };
      }));
    }
    (0, _helpersSegment.F)(items, item => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = (0, _helpersSegment.v)(scaleOptions.type, item.dtype);
      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    (0, _helpersSegment.F)(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    (0, _helpersSegment.F)(scales, scale => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }
  _removeUnreferencedMetasets() {
    const {
      _metasets: metasets,
      data: {
        datasets
      }
    } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const {
          datasetElementType,
          dataElementType
        } = _helpersSegment.d.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    (0, _helpersSegment.F)(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins('reset');
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins('beforeUpdate', {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const {
        controller
      } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      (0, _helpersSegment.F)(newControllers, controller => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins('afterUpdate', {
      mode
    });
    this._layers.sort(compare2Level('z', '_idx'));
    const {
      _active,
      _lastEvent
    } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    (0, _helpersSegment.F)(this.scales, scale => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!(0, _helpersSegment.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const {
      _hiddenIndices
    } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const {
      method,
      start,
      count
    } of changes) {
      const move = method === '_removeElements' ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = idx => new Set(_dataChanges.filter(c => c[0] === idx).map((c, i) => i + ',' + c.splice(1).join(',')));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!(0, _helpersSegment.ag)(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map(c => c.split(',')).map(a => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins('beforeLayout', {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    (0, _helpersSegment.F)(this.boxes, box => {
      if (noArea && box.position === 'chartArea') {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins('afterLayout');
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins('beforeDatasetsUpdate', {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
      this._updateDataset(i1, (0, _helpersSegment.a7)(mode) ? mode({
        datasetIndex: i1
      }) : mode);
    }
    this.notifyPlugins('afterDatasetsUpdate', {
      mode
    });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins('afterDatasetUpdate', args);
  }
  render() {
    if (this.notifyPlugins('beforeRender', {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const {
        width,
        height
      } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins('beforeDraw', {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins('afterDraw');
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins('afterDatasetsDraw');
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }
    if (useClip) {
      (0, _helpersSegment.Y)(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      (0, _helpersSegment.$)(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins('afterDatasetDraw', args);
  }
  isPointInArea(point) {
    return (0, _helpersSegment.C)(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = (0, _helpersSegment.j)(null, {
      chart: this,
      type: 'chart'
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? 'show' : 'hide';
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(undefined, mode);
    if ((0, _helpersSegment.h)(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update(ctx => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins('beforeDestroy');
    const {
      canvas,
      ctx
    } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      (0, _helpersSegment.af)(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins('afterDestroy');
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    (0, _helpersSegment.F)(this.options.events, type => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove('attach', attached);
      this.attached = true;
      this.resize();
      _add('resize', listener);
      _add('detach', detached);
    };
    detached = () => {
      this.attached = false;
      _remove('resize', listener);
      this._stop();
      this._resize(0, 0);
      _add('attach', attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    (0, _helpersSegment.F)(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    (0, _helpersSegment.F)(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = undefined;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;
    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({
      datasetIndex,
      index
    }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !(0, _helpersSegment.ah)(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins('afterEvent', args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const {
      _active: lastActive = [],
      options
    } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = (0, _helpersSegment.ai)(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      (0, _helpersSegment.Q)(options.onHover, [e, active, this], this);
      if (isClick) {
        (0, _helpersSegment.Q)(options.onClick, [e, active, this], this);
      }
    }
    const changed = !(0, _helpersSegment.ah)(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
function invalidatePlugins() {
  return (0, _helpersSegment.F)(Chart.instances, chart => chart._plugins.invalidate());
}
var Chart$1 = Chart;
exports.Chart = Chart$1;
function clipArc(ctx, element, endAngle) {
  const {
    startAngle,
    pixelMargin,
    x,
    y,
    outerRadius,
    innerRadius
  } = element;
  let angleMargin = pixelMargin / outerRadius;
  // Draw an inner border by clipping the arc and drawing a double-width border
  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + _helpersSegment.H, startAngle - _helpersSegment.H);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return (0, _helpersSegment.ak)(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
/**
 * Parse border radius from the provided options
 */
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  // Outer limits are complicated. We want to compute the available angular distance at
  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
  //
  // If the borderRadius is large, that value can become negative.
  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
  // we know that the thickness term will dominate and compute the limits at that point
  const computeOuterLimit = val => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return (0, _helpersSegment.S)(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: (0, _helpersSegment.S)(o.innerStart, 0, innerLimit),
    innerEnd: (0, _helpersSegment.S)(o.innerEnd, 0, innerLimit)
  };
}
/**
 * Convert (r, ð) to (x, y)
 */
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */
function pathArc(ctx, element, offset, spacing, end, circular) {
  const {
    x,
    y,
    startAngle: start,
    pixelMargin,
    innerRadius: innerR
  } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    // When spacing is present, it is the same for all items
    // So we adjust the start and end angle of the arc such that
    // the distance is the same as it would be without the spacing
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(0.001, alpha * outerRadius - offset / _helpersSegment.P) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {
    outerStart,
    outerEnd,
    innerStart,
    innerEnd
  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    // The first arc segments from point 1 to point a to point 2
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    // The corner segment from point 2 to point 3
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _helpersSegment.H);
    }
    // The line from point 3 to point 4
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    // The corner segment from point 4 to point 5
    if (innerEnd > 0) {
      const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + _helpersSegment.H, innerEndAdjustedAngle + Math.PI);
    }
    // The inner arc from point 5 to point b to point 6
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    // The corner segment from point 6 to point 7
    if (innerStart > 0) {
      const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _helpersSegment.H);
    }
    // The line from point 7 to point 8
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    // The corner segment from point 8 to point 1
    if (outerStart > 0) {
      const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - _helpersSegment.H, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const {
    fullCircles,
    startAngle,
    circumference
  } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % _helpersSegment.T || _helpersSegment.T);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const {
    fullCircles,
    startAngle,
    circumference,
    options
  } = element;
  const {
    borderWidth,
    borderJoinStyle
  } = options;
  const inner = options.borderAlign === 'inner';
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || 'round';
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || 'bevel';
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % _helpersSegment.T || _helpersSegment.T);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
class ArcElement extends Element {
  static id = 'arc';
  static defaults = {
    borderAlign: 'center',
    borderColor: '#fff',
    borderJoinStyle: undefined,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: undefined,
    circular: true
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor'
  };
  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {
      angle,
      distance
    } = (0, _helpersSegment.D)(point, {
      x: chartX,
      y: chartY
    });
    const {
      startAngle,
      endAngle,
      innerRadius,
      outerRadius,
      circumference
    } = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = (0, _helpersSegment.v)(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= _helpersSegment.T || (0, _helpersSegment.p)(angle, startAngle, endAngle);
    const withinRadius = (0, _helpersSegment.aj)(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const {
      x,
      y,
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    } = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);
    const {
      offset,
      spacing
    } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const {
      options,
      circumference
    } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
    this.fullCircles = circumference > _helpersSegment.T ? Math.floor(circumference / _helpersSegment.T) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(_helpersSegment.P, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
}
exports.ArcElement = ArcElement;
function setStyle(ctx, options, style = options) {
  ctx.lineCap = (0, _helpersSegment.v)(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash((0, _helpersSegment.v)(style.borderDash, options.borderDash));
  ctx.lineDashOffset = (0, _helpersSegment.v)(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = (0, _helpersSegment.v)(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = (0, _helpersSegment.v)(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = (0, _helpersSegment.v)(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _helpersSegment.ar;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _helpersSegment.as;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {
    start: paramsStart = 0,
    end: paramsEnd = count - 1
  } = params;
  const {
    start: segmentStart,
    end: segmentEnd
  } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const {
    points,
    options
  } = line;
  const {
    count,
    start,
    loop,
    ilen
  } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {
    move = true,
    reverse
  } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {
    count,
    start,
    ilen
  } = pathVars(points, segment, params);
  const {
    move = true,
    reverse
  } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _helpersSegment.ao;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _helpersSegment.ap;
  }
  return _helpersSegment.aq;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const {
    segments,
    options
  } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  static id = 'line';
  static defaults = {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: 'default',
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };
  static descriptors = {
    _scriptable: true,
    _indexable: name => name !== 'borderDash' && name !== 'fill'
  };
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._chart = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      (0, _helpersSegment.al)(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = (0, _helpersSegment.am)(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = (0, _helpersSegment.an)(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {
        start,
        end
      } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = undefined;
    }
  }
}
exports.LineElement = LineElement;
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {
    [axis]: value
  } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  static id = 'point';
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };
  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !(0, _helpersSegment.C)(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    (0, _helpersSegment.at)(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    // @ts-expect-error Fallbacks should never be hit in practice
    return options.radius + options.hitRadius;
  }
}
exports.PointElement = PointElement;
function getBarBounds(bar, useFinalPosition) {
  const {
    x,
    y,
    base,
    width,
    height
  } = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : (0, _helpersSegment.S)(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = (0, _helpersSegment.av)(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const {
    enableBorderRadius
  } = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = (0, _helpersSegment.aw)(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || (0, _helpersSegment.i)(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || (0, _helpersSegment.aj)(x, bounds.left, bounds.right)) && (skipY || (0, _helpersSegment.aj)(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  static id = 'bar';
  static defaults = {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: undefined
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };
  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    this.inflateAmount = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const {
      inflateAmount,
      options: {
        borderColor,
        backgroundColor
      }
    } = this;
    const {
      inner,
      outer
    } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? _helpersSegment.au : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill('evenodd');
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {
      x,
      y,
      base,
      horizontal
    } = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }
}
exports.BarElement = BarElement;
var elements = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcElement: ArcElement,
  LineElement: LineElement,
  PointElement: PointElement,
  BarElement: BarElement
});
exports.elements = elements;
const BORDER_COLORS = ['rgb(54, 162, 235)', 'rgb(255, 99, 132)', 'rgb(255, 159, 64)', 'rgb(255, 205, 86)', 'rgb(75, 192, 192)', 'rgb(153, 102, 255)', 'rgb(201, 203, 207)' // grey
];
// Border colors with 50% transparency
const BACKGROUND_COLORS = /* #__PURE__ */BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function createDefaultDatasetColorizer() {
  return (dataset, i) => {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
  };
}
function createDoughnutDatasetColorizer() {
  let i = 0;
  return dataset => {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  };
}
function createPolarAreaDatasetColorizer() {
  let i = 0;
  return dataset => {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  };
}
function getColorizer(type) {
  if (type === 'doughnut' || type === 'pie') {
    return createDoughnutDatasetColorizer();
  } else if (type === 'polarArea') {
    return createPolarAreaDatasetColorizer();
  }
  return createDefaultDatasetColorizer();
}
function containsColorsDefinitions(descriptors) {
  let k;
  for (k in descriptors) {
    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
var plugin_colors = {
  id: 'colors',
  defaults: {
    enabled: true
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const {
      type,
      options: {
        elements
      },
      data: {
        datasets
      }
    } = chart.config;
    if (containsColorsDefinitions(datasets) || elements && containsColorsDefinitions(elements)) {
      return;
    }
    const colorizer = getColorizer(type);
    datasets.forEach(colorizer);
  }
};
exports.Colors = plugin_colors;
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {
      x: pointAx,
      y: pointAy
    } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!(0, _helpersSegment.k)(minIndex) && !(0, _helpersSegment.k)(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach(dataset => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {
    iScale
  } = meta;
  const {
    min,
    max,
    minDefined,
    maxDefined
  } = iScale.getUserBounds();
  if (minDefined) {
    start = (0, _helpersSegment.S)((0, _helpersSegment.B)(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = (0, _helpersSegment.S)((0, _helpersSegment.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {
        _data,
        indexAxis
      } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if ((0, _helpersSegment.a)([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let {
        start,
        count
      } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if ((0, _helpersSegment.k)(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function () {
            return this._decimated;
          },
          set: function (d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case 'lttb':
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case 'min-max':
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
exports.Decimation = plugin_decimation;
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let {
      start,
      end
    } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = (0, _helpersSegment.an)(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = (0, _helpersSegment.ax)(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === 'angle') {
    start = (0, _helpersSegment.ay)(start);
    end = (0, _helpersSegment.ay)(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const {
    x = null,
    y = null
  } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({
    start,
    end
  }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if ((0, _helpersSegment.b)(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!(0, _helpersSegment.g)(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if ((0, _helpersSegment.i)(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if ((0, _helpersSegment.g)(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill[0], index, target, count);
  }
  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
  if (firstCh === '-' || firstCh === '+') {
    target = index + target;
  }
  if (target === index || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill, scale) {
  let pixel = null;
  if (fill === 'start') {
    pixel = scale.bottom;
  } else if (fill === 'end') {
    pixel = scale.top;
  } else if ((0, _helpersSegment.i)(fill)) {
    pixel = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill, scale, startValue) {
  let value;
  if (fill === 'start') {
    value = startValue;
  } else if (fill === 'end') {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if ((0, _helpersSegment.i)(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = (0, _helpersSegment.v)(fillOption && fillOption.target, fillOption);
  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return 'origin';
  }
  return fill;
}
function _buildStackLine(source) {
  const {
    scale,
    index,
    line
  } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas('line');
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {
      first,
      last,
      point
    } = findPoint(line, sourcePoint, 'x');
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if ((0, _helpersSegment.aj)(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const {
      x,
      y,
      radius
    } = this;
    bounds = bounds || {
      start: 0,
      end: _helpersSegment.T
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const {
      x,
      y,
      radius
    } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function _getTarget(source) {
  const {
    chart,
    fill,
    line
  } = source;
  if ((0, _helpersSegment.g)(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === 'stack') {
    return _buildStackLine(source);
  }
  if (fill === 'shape') {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const {
    scale = {},
    fill
  } = source;
  const pixel = _getTargetPixel(fill, scale);
  if ((0, _helpersSegment.g)(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const {
    scale,
    fill
  } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const {
    line,
    scale,
    axis
  } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {
    above = color,
    below = color
  } = fillOption || {};
  if (target && line.points.length) {
    (0, _helpersSegment.Y)(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    (0, _helpersSegment.$)(ctx);
  }
}
function doFill(ctx, cfg) {
  const {
    line,
    target,
    above,
    below,
    area,
    scale
  } = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();
  if (property === 'x' && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const {
    segments,
    points
  } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const {
      start,
      end
    } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const {
    line,
    target,
    property,
    color,
    scale
  } = cfg;
  const segments = _segments(line, target, property);
  for (const {
    source: src,
    target: tgt,
    start,
    end
  } of segments) {
    const {
      style: {
        backgroundColor = color
      } = {}
    } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const {
    top,
    bottom
  } = scale.chart.chartArea;
  const {
    property,
    start,
    end
  } = bounds || {};
  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: 'filler',
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};
exports.Filler = index;
const getBoxSize = (labelOpts, fontSize) => {
  let {
    boxHeight = fontSize,
    boxWidth = fontSize
  } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = (0, _helpersSegment.Q)(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter(item => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const {
      options,
      ctx
    } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = (0, _helpersSegment.a0)(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const {
      boxWidth,
      itemHeight
    } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const {
      ctx,
      maxWidth,
      options: {
        labels: {
          padding
        }
      }
    } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const {
      ctx,
      maxHeight,
      options: {
        labels: {
          padding
        }
      }
    } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const {
        itemWidth,
        itemHeight
      } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const {
      legendHitBoxes: hitboxes,
      options: {
        align,
        labels: {
          padding
        },
        rtl
      }
    } = this;
    const rtlHelper = (0, _helpersSegment.az)(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = (0, _helpersSegment.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = (0, _helpersSegment.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = (0, _helpersSegment.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox1 of hitboxes) {
        if (hitbox1.col !== col) {
          col = hitbox1.col;
          top = (0, _helpersSegment.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox1.top = top;
        hitbox1.left += this.left + padding;
        hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
        top += hitbox1.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      (0, _helpersSegment.Y)(ctx, this);
      this._draw();
      (0, _helpersSegment.$)(ctx);
    }
  }
  _draw() {
    const {
      options: opts,
      columnSizes,
      lineWidths,
      ctx
    } = this;
    const {
      align,
      labels: labelOpts
    } = opts;
    const defaultColor = _helpersSegment.d.color;
    const rtlHelper = (0, _helpersSegment.az)(opts.rtl, this.left, this.width);
    const labelFont = (0, _helpersSegment.a0)(labelOpts.font);
    const {
      padding
    } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {
      boxWidth,
      boxHeight,
      itemHeight
    } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function (x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = (0, _helpersSegment.v)(legendItem.lineWidth, 1);
      ctx.fillStyle = (0, _helpersSegment.v)(legendItem.fillStyle, defaultColor);
      ctx.lineCap = (0, _helpersSegment.v)(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = (0, _helpersSegment.v)(legendItem.lineDashOffset, 0);
      ctx.lineJoin = (0, _helpersSegment.v)(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = (0, _helpersSegment.v)(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash((0, _helpersSegment.v)(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        (0, _helpersSegment.aD)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = (0, _helpersSegment.aw)(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some(v => v !== 0)) {
          (0, _helpersSegment.au)(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function (x, y, legendItem) {
      (0, _helpersSegment.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: (0, _helpersSegment.a2)(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: (0, _helpersSegment.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    (0, _helpersSegment.aA)(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = (0, _helpersSegment.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = (0, _helpersSegment.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = (0, _helpersSegment.aB)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== 'string') {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight;
      }
    });
    (0, _helpersSegment.aC)(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = (0, _helpersSegment.a0)(titleOpts.font);
    const titlePadding = (0, _helpersSegment.E)(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = (0, _helpersSegment.az)(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = (0, _helpersSegment.a2)(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + (0, _helpersSegment.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = (0, _helpersSegment.a2)(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign((0, _helpersSegment.a1)(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    (0, _helpersSegment.Z)(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = (0, _helpersSegment.a0)(titleOpts.font);
    const titlePadding = (0, _helpersSegment.E)(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if ((0, _helpersSegment.aj)(x, this.left, this.right) && (0, _helpersSegment.aj)(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if ((0, _helpersSegment.aj)(x, hitBox.left, hitBox.left + hitBox.width) && (0, _helpersSegment.aj)(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === 'mousemove' || e.type === 'mouseout') {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        (0, _helpersSegment.Q)(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        (0, _helpersSegment.Q)(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      (0, _helpersSegment.Q)(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== 'string') {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== 'string') {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: 'legend',
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: ctx => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {
          labels: {
            usePointStyle,
            pointStyle,
            textAlign,
            color,
            useBorderRadius,
            borderRadius
          }
        } = chart.legend.options;
        return chart._getSortedDatasetMetas().map(meta => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = (0, _helpersSegment.E)(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: ctx => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: ''
    }
  },
  descriptors: {
    _scriptable: name => !name.startsWith('on'),
    labels: {
      _scriptable: name => !['generateLabels', 'filter', 'sort'].includes(name)
    }
  }
};
exports.Legend = plugin_legend;
class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = (0, _helpersSegment.b)(opts.text) ? opts.text.length : 1;
    this._padding = (0, _helpersSegment.E)(opts.padding);
    const textSize = lineCount * (0, _helpersSegment.a0)(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }
  _drawArgs(offset) {
    const {
      top,
      left,
      bottom,
      right,
      options
    } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = (0, _helpersSegment.a2)(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = (0, _helpersSegment.a2)(align, bottom, top);
        rotation = _helpersSegment.P * -0.5;
      } else {
        titleX = right - offset;
        titleY = (0, _helpersSegment.a2)(align, top, bottom);
        rotation = _helpersSegment.P * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = (0, _helpersSegment.a0)(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const {
      titleX,
      titleY,
      maxWidth,
      rotation
    } = this._drawArgs(offset);
    (0, _helpersSegment.Z)(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: (0, _helpersSegment.a1)(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: 'title',
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold'
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
exports.Title = plugin_title;
const map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal'
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
exports.SubTitle = plugin_subtitle;
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = (0, _helpersSegment.aE)(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if ((0, _helpersSegment.b)(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }
  return str;
}
function createTooltipItem(chart, item) {
  const {
    element,
    datasetIndex,
    index
  } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {
    label,
    value
  } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const {
    body,
    footer,
    title
  } = tooltip;
  const {
    boxWidth,
    boxHeight
  } = options;
  const bodyFont = (0, _helpersSegment.a0)(options.bodyFont);
  const titleFont = (0, _helpersSegment.a0)(options.titleFont);
  const footerFont = (0, _helpersSegment.a0)(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = (0, _helpersSegment.E)(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function (line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  (0, _helpersSegment.F)(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  (0, _helpersSegment.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  (0, _helpersSegment.F)(body, bodyItem => {
    (0, _helpersSegment.F)(bodyItem.before, maxLineWidth);
    (0, _helpersSegment.F)(bodyItem.lines, maxLineWidth);
    (0, _helpersSegment.F)(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  (0, _helpersSegment.F)(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const {
    y,
    height
  } = size;
  if (y < height / 2) {
    return 'top';
  } else if (y > chart.height - height / 2) {
    return 'bottom';
  }
  return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {
    x,
    width
  } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const {
    x,
    width
  } = size;
  const {
    width: chartWidth,
    chartArea: {
      left,
      right
    }
  } = chart;
  let xAlign = 'center';
  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let {
    x,
    width
  } = size;
  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let {
    y,
    height
  } = size;
  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const {
    caretSize,
    caretPadding,
    cornerRadius
  } = options;
  const {
    xAlign,
    yAlign
  } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight
  } = (0, _helpersSegment.aw)(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === 'right') {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: (0, _helpersSegment.S)(x, 0, chart.width - size.width),
    y: (0, _helpersSegment.S)(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = (0, _helpersSegment.E)(options.padding);
  return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return (0, _helpersSegment.j)(parent, {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
  beforeTitle: _helpersSegment.aF,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === 'dataset') {
        return item.dataset.label || '';
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return '';
  },
  afterTitle: _helpersSegment.aF,
  beforeBody: _helpersSegment.aF,
  beforeLabel: _helpersSegment.aF,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === 'dataset') {
      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || '';
    if (label) {
      label += ': ';
    }
    const value = tooltipItem.formattedValue;
    if (!(0, _helpersSegment.k)(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: _helpersSegment.aF,
  afterBody: _helpersSegment.aF,
  beforeFooter: _helpersSegment.aF,
  footer: _helpersSegment.aF,
  afterFooter: _helpersSegment.aF
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === 'undefined') {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
class Tooltip extends Element {
  static positioners = positioners;
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const {
      callbacks
    } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const {
      callbacks
    } = options;
    const bodyItems = [];
    (0, _helpersSegment.F)(tooltipItems, context => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const {
      callbacks
    } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    (0, _helpersSegment.F)(tooltipItems, context => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = undefined;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const {
      xAlign,
      yAlign
    } = this;
    const {
      caretSize,
      cornerRadius
    } = options;
    const {
      topLeft,
      topRight,
      bottomLeft,
      bottomRight
    } = (0, _helpersSegment.aw)(cornerRadius);
    const {
      x: ptX,
      y: ptY
    } = tooltipPoint;
    const {
      width,
      height
    } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === 'center') {
      y2 = ptY + height / 2;
      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === 'right') {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = (0, _helpersSegment.az)(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = (0, _helpersSegment.a0)(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const {
      boxHeight,
      boxWidth,
      boxPadding
    } = options;
    const bodyFont = (0, _helpersSegment.a0)(options.bodyFont);
    const colorX = getAlignedX(this, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      (0, _helpersSegment.at)(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      (0, _helpersSegment.at)(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = (0, _helpersSegment.i)(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = (0, _helpersSegment.aw)(labelColors.borderRadius);
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        (0, _helpersSegment.au)(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        (0, _helpersSegment.au)(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const {
      body
    } = this;
    const {
      bodySpacing,
      bodyAlign,
      displayColors,
      boxHeight,
      boxWidth,
      boxPadding
    } = options;
    const bodyFont = (0, _helpersSegment.a0)(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = (0, _helpersSegment.az)(options.rtl, this.x, this.width);
    const fillLineOfText = function (line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    (0, _helpersSegment.F)(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      (0, _helpersSegment.F)(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      (0, _helpersSegment.F)(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    (0, _helpersSegment.F)(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = (0, _helpersSegment.az)(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = (0, _helpersSegment.a0)(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const {
      xAlign,
      yAlign
    } = this;
    const {
      x,
      y
    } = pt;
    const {
      width,
      height
    } = tooltipSize;
    const {
      topLeft,
      topRight,
      bottomLeft,
      bottomRight
    } = (0, _helpersSegment.aw)(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = (0, _helpersSegment.E)(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      (0, _helpersSegment.aA)(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      (0, _helpersSegment.aC)(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({
      datasetIndex,
      index
    }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !(0, _helpersSegment.ah)(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !(0, _helpersSegment.ah)(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const {
      caretX,
      caretY,
      options
    } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
var plugin_tooltip = {
  id: 'tooltip',
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins('beforeTooltipDraw', {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins('afterTooltipDraw', args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold'
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold'
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart'
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY']
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: name => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};
exports.Tooltip = plugin_tooltip;
var plugins = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
exports.plugins = plugins;
const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === 'string') {
    index = labels.push(raw) - 1;
    addedLabels.unshift({
      index,
      label: raw
    });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max) => index === null ? null : (0, _helpersSegment.S)(Math.round(index), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
class CategoryScale extends Scale {
  static id = 'category';
  static defaults = {
    ticks: {
      callback: _getLabelForValue
    }
  };
  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const {
        index,
        label
      } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if ((0, _helpersSegment.k)(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0, _helpersSegment.v)(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let {
      min,
      max
    } = this.getMinMax(true);
    if (this.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== 'number') {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
exports.CategoryScale = CategoryScale;
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {
    bounds,
    step,
    min,
    max,
    precision,
    count,
    maxTicks,
    maxDigits,
    includeBounds
  } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {
    min: rmin,
    max: rmax
  } = dataRange;
  const minDefined = !(0, _helpersSegment.k)(min);
  const maxDefined = !(0, _helpersSegment.k)(max);
  const countDefined = !(0, _helpersSegment.k)(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = (0, _helpersSegment.aH)((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{
      value: rmin
    }, {
      value: rmax
    }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = (0, _helpersSegment.aH)(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!(0, _helpersSegment.k)(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && (0, _helpersSegment.aI)((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if ((0, _helpersSegment.aJ)(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max((0, _helpersSegment.aK)(spacing), (0, _helpersSegment.aK)(niceMin));
  factor = Math.pow(10, (0, _helpersSegment.k)(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if ((0, _helpersSegment.aJ)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({
      value: Math.round((niceMin + j * spacing) * factor) / factor
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && (0, _helpersSegment.aJ)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, {
  horizontal,
  minRotation
}) {
  const rad = (0, _helpersSegment.t)(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if ((0, _helpersSegment.k)(raw)) {
      return null;
    }
    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const {
      beginAtZero
    } = this.options;
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let {
      min,
      max
    } = this;
    const setMin = v => min = minDefined ? min : v;
    const setMax = v => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = (0, _helpersSegment.s)(min);
      const maxSign = (0, _helpersSegment.s)(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let {
      maxTicksLimit,
      stepSize
    } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1000) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1000;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === 'ticks') {
      (0, _helpersSegment.aG)(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return (0, _helpersSegment.o)(value, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  static id = 'linear';
  static defaults = {
    ticks: {
      callback: _helpersSegment.aL.formatters.numeric
    }
  };
  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(true);
    this.min = (0, _helpersSegment.g)(min) ? min : 0;
    this.max = (0, _helpersSegment.g)(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = (0, _helpersSegment.t)(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
exports.LinearScale = LinearScale;
const log10Floor = v => Math.floor((0, _helpersSegment.aM)(v));
const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, {
  min,
  max
}) {
  min = (0, _helpersSegment.O)(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = (0, _helpersSegment.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = (0, _helpersSegment.O)(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
class LogarithmicScale extends Scale {
  static id = 'logarithmic';
  static defaults = {
    ticks: {
      callback: _helpersSegment.aL.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return undefined;
    }
    return (0, _helpersSegment.g)(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(true);
    this.min = (0, _helpersSegment.g)(min) ? Math.max(0, min) : null;
    this.max = (0, _helpersSegment.g)(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !(0, _helpersSegment.g)(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = v => min = minDefined ? min : v;
    const setMax = v => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, +1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, +1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === 'ticks') {
      (0, _helpersSegment.aG)(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === undefined ? '0' : (0, _helpersSegment.o)(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = (0, _helpersSegment.aM)(start);
    this._valueRange = (0, _helpersSegment.aM)(this.max) - (0, _helpersSegment.aM)(start);
  }
  getPixelForValue(value) {
    if (value === undefined || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : ((0, _helpersSegment.aM)(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
exports.LogarithmicScale = LogarithmicScale;
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = (0, _helpersSegment.E)(tickOpts.backdropPadding);
    return (0, _helpersSegment.v)(tickOpts.font && tickOpts.font.size, _helpersSegment.d.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = (0, _helpersSegment.b)(label) ? label : [label];
  return {
    w: (0, _helpersSegment.aN)(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? _helpersSegment.P / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = (0, _helpersSegment.a0)(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = (0, _helpersSegment.ay)(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round((0, _helpersSegment.U)(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? _helpersSegment.P / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round((0, _helpersSegment.U)((0, _helpersSegment.ay)(pointLabelPosition.angle + _helpersSegment.H)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }
  return 'right';
}
function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const {
    ctx,
    options: {
      pointLabels
    }
  } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = (0, _helpersSegment.a0)(optsAtIndex.font);
    const {
      x,
      y,
      textAlign,
      left,
      top,
      right,
      bottom
    } = scale._pointLabelItems[i];
    const {
      backdropColor
    } = optsAtIndex;
    if (!(0, _helpersSegment.k)(backdropColor)) {
      const borderRadius = (0, _helpersSegment.aw)(optsAtIndex.borderRadius);
      const padding = (0, _helpersSegment.E)(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        (0, _helpersSegment.au)(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    (0, _helpersSegment.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign: textAlign,
      textBaseline: 'middle'
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const {
    ctx
  } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _helpersSegment.T);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {
    color,
    lineWidth
  } = gridLineOpts;
  if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return (0, _helpersSegment.j)(parent, {
    label,
    index,
    type: 'pointLabel'
  });
}
class RadialLinearScale extends LinearScaleBase {
  static id = 'radialLinear';
  static defaults = {
    display: true,
    animate: true,
    position: 'chartArea',
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0.0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: _helpersSegment.aL.formatters.numeric
    },
    pointLabels: {
      backdropColor: undefined,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  };
  static defaultRoutes = {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color'
  };
  static descriptors = {
    angleLines: {
      _fallback: 'grid'
    }
  };
  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = (0, _helpersSegment.E)(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(false);
    this.min = (0, _helpersSegment.g)(min) && !isNaN(min) ? min : 0;
    this.max = (0, _helpersSegment.g)(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = (0, _helpersSegment.Q)(this.options.pointLabels.callback, [value, index], this);
      return label || label === 0 ? label : '';
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = _helpersSegment.T / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return (0, _helpersSegment.ay)(index * angleMultiplier + (0, _helpersSegment.t)(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if ((0, _helpersSegment.k)(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if ((0, _helpersSegment.k)(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - _helpersSegment.H + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const {
      left,
      top,
      right,
      bottom
    } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const {
      backgroundColor,
      grid: {
        circular
      }
    } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const {
      angleLines,
      grid,
      border
    } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const {
          color,
          lineWidth
        } = optsAtIndex;
        if (!lineWidth || !color) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {}
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = (0, _helpersSegment.a0)(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = (0, _helpersSegment.E)(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      (0, _helpersSegment.Z)(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {}
}
exports.RadialLinearScale = RadialLinearScale;
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1000
  },
  second: {
    common: true,
    size: 1000,
    steps: 60
  },
  minute: {
    common: true,
    size: 60000,
    steps: 60
  },
  hour: {
    common: true,
    size: 3600000,
    steps: 24
  },
  day: {
    common: true,
    size: 86400000,
    steps: 30
  },
  week: {
    common: false,
    size: 604800000,
    steps: 4
  },
  month: {
    common: true,
    size: 2.628e9,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7.884e9,
    steps: 4
  },
  year: {
    common: true,
    size: 3.154e10
  }
};
const UNITS = /* #__PURE__ */Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if ((0, _helpersSegment.k)(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const {
    parser,
    round,
    isoWeekday
  } = scale._parseOpts;
  let value = input;
  if (typeof parser === 'function') {
    value = parser(value);
  }
  if (!(0, _helpersSegment.g)(value)) {
    value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round) {
    value = round === 'week' && ((0, _helpersSegment.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {
      lo,
      hi
    } = (0, _helpersSegment.aP)(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
  static id = 'time';
  static defaults = {
    bounds: 'data',
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: 'millisecond',
      displayFormats: {}
    },
    ticks: {
      source: 'auto',
      callback: false,
      major: {
        enabled: false
      }
    }
  };
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    (0, _helpersSegment.ab)(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || 'day';
    let {
      min,
      max,
      minDefined,
      maxDefined
    } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = (0, _helpersSegment.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = (0, _helpersSegment.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === 'ticks' && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = (0, _helpersSegment.aO)(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map(tick => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = (0, _helpersSegment.S)(start, 0, limit);
    end = (0, _helpersSegment.S)(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = (0, _helpersSegment.v)(options.ticks.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = (0, _helpersSegment.x)(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }
    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return (0, _helpersSegment.Q)(formatter, [time, index, ticks], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = (0, _helpersSegment.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return (0, _helpersSegment._)(values.sort(sorter));
  }
}
exports.TimeScale = TimeScale;
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({
        lo,
        hi
      } = (0, _helpersSegment.B)(table, 'pos', val));
    }
    ({
      pos: prevSource,
      time: prevTarget
    } = table[lo]);
    ({
      pos: nextSource,
      time: nextTarget
    } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({
        lo,
        hi
      } = (0, _helpersSegment.B)(table, 'time', val));
    }
    ({
      time: prevSource,
      pos: prevTarget
    } = table[lo]);
    ({
      time: nextSource,
      pos: nextTarget
    } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  static id = 'timeseries';
  static defaults = TimeScale.defaults;
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const {
      min,
      max
    } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [{
        time: min,
        pos: 0
      }, {
        time: max,
        pos: 1
      }];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
var TimeSeriesScale$1 = TimeSeriesScale;
exports.TimeSeriesScale = TimeSeriesScale$1;
var scales = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CategoryScale: CategoryScale,
  LinearScale: LinearScale,
  LogarithmicScale: LogarithmicScale,
  RadialLinearScale: RadialLinearScale,
  TimeScale: TimeScale,
  TimeSeriesScale: TimeSeriesScale$1
});
exports.scales = scales;
const registerables = [controllers, elements, plugins, scales];
exports.registerables = registerables;
},{"./chunks/helpers.segment.js":"../../node_modules/chart.js/dist/chunks/helpers.segment.js"}],"../../node_modules/chart.js/auto/auto.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = void 0;
var _chart = require("../dist/chart.js");
Object.keys(_chart).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _chart[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _chart[key];
    }
  });
});
_chart.Chart.register(..._chart.registerables);
var _default = _chart.Chart;
exports.default = _default;
},{"../dist/chart.js":"../../node_modules/chart.js/dist/chart.js"}],"chartUtils.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transparentize = void 0;
var transparentize = function transparentize(r, g, b, alpha) {
  var a = (1 - alpha) * 255;
  var calc = function calc(x) {
    return Math.round((x - a) / alpha);
  };
  return "rgba(".concat(calc(r), ", ").concat(calc(g), ", ").concat(calc(b), ", ").concat(alpha, ")");
};
exports.transparentize = transparentize;
},{}],"getFixture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFixture = exports.getAvgStats = void 0;
var _axios = _interopRequireDefault(require("axios"));
var _moment = _interopRequireDefault(require("moment/moment"));
var _alert = require("./alert");
var _auto = require("chart.js/auto");
var _chartUtils = require("/chartUtils.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var getAvgStats = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
    var overallStats, teamImg, statsList, team, teamForm, color, res, data, _i, _Object$entries, _Object$entries$_i, index, el, html, keys, values, dataa, chartExist;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            overallStats = document.querySelectorAll('.avgTeam-stats dd');
            teamImg = document.querySelector('.avgTeam-image img');
            statsList = document.querySelector('.stats--list');
            team = document.querySelector('.avgTeam-info h2');
            teamForm = document.querySelector('.avgTeam-info .team-form');
            color = {
              L: 'red',
              D: 'grey',
              W: 'green'
            };
            _context.prev = 6;
            _context.next = 9;
            return (0, _axios.default)({
              method: 'GET',
              url: "/api/v1/fixture/getAverageStats/".concat(id)
            });
          case 9:
            res = _context.sent;
            team.lastChild.textContent = res.data.team;
            data = res.data.result[0];
            teamForm.textContent = '';
            _i = 0, _Object$entries = Object.entries(data.Form);
          case 14:
            if (!(_i < _Object$entries.length)) {
              _context.next = 23;
              break;
            }
            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), index = _Object$entries$_i[0], el = _Object$entries$_i[1];
            if (!(index > 9)) {
              _context.next = 18;
              break;
            }
            return _context.abrupt("break", 23);
          case 18:
            html = "<div class=\"form-indicator\" style=\"background-color:".concat(color[el], ";\"> </div>");
            teamForm.insertAdjacentHTML('beforeend', html);
          case 20:
            _i++;
            _context.next = 14;
            break;
          case 23:
            overallStats[0].textContent = data.Played;
            overallStats[1].textContent = data.Wins;
            overallStats[2].textContent = data.Losses;
            overallStats[3].textContent = data.GF;
            teamImg.src = "/img/".concat(res.data.team.replace(/\s/g, ''), ".png");
            keys = Object.keys(data.avgStats).map(function (el) {
              return el;
            });
            values = Object.values(data.avgStats).map(function (el) {
              return el;
            });
            dataa = {
              labels: keys,
              datasets: [{
                label: res.data.team,
                data: values,
                borderColor: 'rgb(255, 99, 132)',
                backgroundColor: (0, _chartUtils.transparentize)(255, 99, 132, 0.5)
              }]
            };
            chartExist = _auto.Chart.getChart('acquisitions'); // <canvas> id
            if (chartExist) chartExist.destroy();
            new _auto.Chart(document.getElementById('acquisitions'), {
              type: 'radar',
              data: dataa,
              options: {
                responsive: true,
                plugins: {
                  title: {
                    display: false,
                    text: 'Average Stats this season:'
                  },
                  legend: {
                    display: false
                  }
                }
              }
            });

            // let html = '';
            // statsList.textContent = '';
            // for (const [key, value] of Object.entries(data.avgStats)) {
            //   html += `<p><strong>${key}:  </strong>${value.toFixed(2)}</p>`;
            // }

            // statsList.insertAdjacentHTML('afterbegin', html);
            _context.next = 40;
            break;
          case 36:
            _context.prev = 36;
            _context.t0 = _context["catch"](6);
            console.log(_context.t0);
            (0, _alert.showAlert)('error', 'error getting details');
          case 40:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[6, 36]]);
  }));
  return function getAvgStats(_x) {
    return _ref.apply(this, arguments);
  };
}();
exports.getAvgStats = getAvgStats;
var getFixture = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(HomeTeam, AwayTeam) {
    var awayTeamLogo, container, headerH1, homeTeamLogo, matchOverview, matchReferee, matchScore, matchStatus, matchTime, roundNumber, statistics, teamName, teamLogo, tempHTML, res, data, _data$Statistics, _data$Statistics2, homeStats, awayStats, stats, _i2, _Object$keys, key, percentage;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            //Initialise DOM elements
            awayTeamLogo = document.querySelector('.team--away .team-logo img');
            container = document.querySelector('.match--stats__container');
            headerH1 = document.querySelector('.header__matchStats h1');
            homeTeamLogo = document.querySelector('.team--home .team-logo img');
            matchOverview = document.querySelector('.match--overview');
            matchReferee = document.querySelector('.match-referee strong');
            matchScore = document.querySelectorAll('.match-score-number');
            matchStatus = document.querySelector('.match-time-lapsed');
            matchTime = document.querySelector('.match-date time');
            roundNumber = document.querySelector('.match-date p strong');
            statistics = document.querySelector('.match--stats');
            teamName = document.querySelectorAll('.team-name');
            teamLogo = document.querySelectorAll('.team-logo');
            _context2.prev = 13;
            _context2.next = 16;
            return (0, _axios.default)({
              method: 'GET',
              url: "/api/v1/fixture/getFixtures?HomeTeam=".concat(HomeTeam, "&AwayTeam=").concat(AwayTeam)
            });
          case 16:
            res = _context2.sent;
            data = res.data.fixture[0];
            _data$Statistics = data === null || data === void 0 ? void 0 : data.Statistics, _data$Statistics2 = _slicedToArray(_data$Statistics, 2), homeStats = _data$Statistics2[0], awayStats = _data$Statistics2[1];
            stats = '';
            if (homeStats && awayStats) {
              for (_i2 = 0, _Object$keys = Object.keys(homeStats); _i2 < _Object$keys.length; _i2++) {
                key = _Object$keys[_i2];
                percentage = homeStats[key] === awayStats[key] ? 0.5 : parseInt(homeStats[key] || 0) / (parseInt(homeStats[key] || 0) + parseInt(awayStats[key] || 0));
                stats += "\n        <p style=\"font-size:16px;text-align:center\"><strong>".concat(key, "</strong></p>\n        <div class=\"stat__progress\">\n          <p>").concat(homeStats[key] || 0, "</p>\n          <progress class=\"stats\" max=\"100\" value=").concat(Math.floor(percentage * 100), "></progress>\n          <p>").concat(awayStats[key] || 0, "</p>\n        </div>");
              }
            }

            //replace the header to show corresponding fixture
            headerH1.textContent = "".concat(data.HomeTeam, " vs ").concat(data.AwayTeam, " Match Statistics");

            //replace team logos to match corresponding fixture
            homeTeamLogo.src = "/img/".concat(data.HomeTeam.replace(/\s/g, ''), ".png");
            awayTeamLogo.src = "/img/".concat(data.AwayTeam.replace(/\s/g, ''), ".png");
            teamLogo[0].dataset.team = data.HomeTeam;
            teamLogo[1].dataset.team = data.AwayTeam;
            teamName[0].textContent = data.HomeTeam;
            teamName[1].textContent = data.AwayTeam;
            roundNumber.textContent = data.RoundNumber;
            matchTime.textContent = '';
            matchTime.insertAdjacentHTML('afterbegin', "".concat((0, _moment.default)(data.Date).format('LL').split(',')[0], " at <strong>").concat((0, _moment.default)(data.Date).format('HH:mm'), "</strong>"));
            matchStatus.textContent = data.Status;
            matchReferee.textContent = "".concat(data.Referee ? data.Referee.split(',')[0] : 'Not assigned');
            matchScore[0].textContent = data.HomeTeamScore === null ? 'P' : data.HomeTeamScore;
            matchScore[1].textContent = data.AwayTeamScore === null ? 'P' : data.AwayTeamScore;

            //Depending on which team has won, is winning,
            //there score will be hightlighted to easily see
            //the winning team
            if (data.HomeTeamScore > data.AwayTeamScore) {
              document;
              matchScore[0].classList.add('match-score-number--leading');
              document;
              matchScore[1].classList.remove('match-score-number--leading');
            } else if (data.HomeTeamScore < data.AwayTeamScore) {
              document;
              matchScore[1].classList.add('match-score-number--leading');
              document;
              matchScore[0].classList.remove('match-score-number--leading');
            } else {
              document;
              matchScore.forEach(function (el) {
                return el.classList.remove('match-score-number--leading');
              });
            }

            //remove statistics section from the page
            //so we can then re-add the HTML
            //to trigger the replay of the animation

            tempHTML = matchOverview.innerHTML;
            matchOverview.remove();
            container.insertAdjacentHTML('afterbegin', "<div class=\"match--overview\">".concat(tempHTML, "</div>"));
            statistics.remove();
            container.insertAdjacentHTML('beforeend', "<div class=\"match--stats slide-animation-UP\">".concat(stats, "</div>"));
            _context2.next = 46;
            break;
          case 43:
            _context2.prev = 43;
            _context2.t0 = _context2["catch"](13);
            (0, _alert.showAlert)('error', 'error getting fixture details');
          case 46:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[13, 43]]);
  }));
  return function getFixture(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
exports.getFixture = getFixture;
},{"axios":"../../node_modules/axios/index.js","moment/moment":"../../node_modules/moment/moment.js","./alert":"alert.js","chart.js/auto":"../../node_modules/chart.js/auto/auto.js","/chartUtils.js":"chartUtils.js"}],"../../node_modules/prettier/standalone.js":[function(require,module,exports) {
var define;
var global = arguments[3];
function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { var i = g[name]; if ("number" == typeof i) groups[name] = result[i];else { for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) { k++; } groups[name] = result[i[k]]; } return groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e3) { throw _e3; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e4) { didErr = true; err = _e4; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function (e) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) == "object" && (typeof module === "undefined" ? "undefined" : _typeof(module)) == "object") module.exports = e();else if (typeof define == "function" && define.amd) define(e);else {
    var f = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) < "u" ? globalThis : (typeof global === "undefined" ? "undefined" : _typeof(global)) < "u" ? global : (typeof self === "undefined" ? "undefined" : _typeof(self)) < "u" ? self : this || {};
    f.prettier = e();
  }
})(function () {
  "use strict";

  var we = function we(e, n) {
    return function () {
      return n || e((n = {
        exports: {}
      }).exports, n), n.exports;
    };
  };
  var Ye = we(function (Ig, ru) {
    var rr = function rr(e) {
      return e && e.Math == Math && e;
    };
    ru.exports = rr((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == "object" && globalThis) || rr((typeof window === "undefined" ? "undefined" : _typeof(window)) == "object" && window) || rr((typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self) || rr((typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global) || function () {
      return this;
    }() || Function("return this")();
  });
  var Dt = we(function (Lg, nu) {
    nu.exports = function (e) {
      try {
        return !!e();
      } catch (_unused) {
        return !0;
      }
    };
  });
  var Ct = we(function (jg, uu) {
    var So = Dt();
    uu.exports = !So(function () {
      return Object.defineProperty({}, 1, {
        get: function get() {
          return 7;
        }
      })[1] != 7;
    });
  });
  var nr = we(function (Og, su) {
    var xo = Dt();
    su.exports = !xo(function () {
      var e = function () {}.bind();
      return typeof e != "function" || e.hasOwnProperty("prototype");
    });
  });
  var Et = we(function (qg, iu) {
    var bo = nr(),
      ur = Function.prototype.call;
    iu.exports = bo ? ur.bind(ur) : function () {
      return ur.apply(ur, arguments);
    };
  });
  var cu = we(function (lu) {
    "use strict";

    var au = {}.propertyIsEnumerable,
      ou = Object.getOwnPropertyDescriptor,
      To = ou && !au.call({
        1: 2
      }, 1);
    lu.f = To ? function (n) {
      var t = ou(this, n);
      return !!t && t.enumerable;
    } : au;
  });
  var sr = we(function (Rg, pu) {
    pu.exports = function (e, n) {
      return {
        enumerable: !(e & 1),
        configurable: !(e & 2),
        writable: !(e & 4),
        value: n
      };
    };
  });
  var at = we(function (Vg, mu) {
    var fu = nr(),
      Du = Function.prototype,
      Bo = Du.bind,
      Or = Du.call,
      No = fu && Bo.bind(Or, Or);
    mu.exports = fu ? function (e) {
      return e && No(e);
    } : function (e) {
      return e && function () {
        return Or.apply(e, arguments);
      };
    };
  });
  var ir = we(function (Wg, gu) {
    var du = at(),
      wo = du({}.toString),
      _o = du("".slice);
    gu.exports = function (e) {
      return _o(wo(e), 8, -1);
    };
  });
  var hu = we(function ($g, yu) {
    var Po = Ye(),
      ko = at(),
      Io = Dt(),
      Lo = ir(),
      qr = Po.Object,
      jo = ko("".split);
    yu.exports = Io(function () {
      return !qr("z").propertyIsEnumerable(0);
    }) ? function (e) {
      return Lo(e) == "String" ? jo(e, "") : qr(e);
    } : qr;
  });
  var Mr = we(function (Hg, vu) {
    var Oo = Ye(),
      qo = Oo.TypeError;
    vu.exports = function (e) {
      if (e == null) throw qo("Can't call method on " + e);
      return e;
    };
  });
  var ar = we(function (Gg, Cu) {
    var Mo = hu(),
      Ro = Mr();
    Cu.exports = function (e) {
      return Mo(Ro(e));
    };
  });
  var ot = we(function (Jg, Eu) {
    Eu.exports = function (e) {
      return typeof e == "function";
    };
  });
  var Ft = we(function (Ug, Fu) {
    var Vo = ot();
    Fu.exports = function (e) {
      return _typeof(e) == "object" ? e !== null : Vo(e);
    };
  });
  var Rt = we(function (zg, Au) {
    var Rr = Ye(),
      Wo = ot(),
      $o = function $o(e) {
        return Wo(e) ? e : void 0;
      };
    Au.exports = function (e, n) {
      return arguments.length < 2 ? $o(Rr[e]) : Rr[e] && Rr[e][n];
    };
  });
  var Vr = we(function (Xg, Su) {
    var Ho = at();
    Su.exports = Ho({}.isPrototypeOf);
  });
  var bu = we(function (Kg, xu) {
    var Go = Rt();
    xu.exports = Go("navigator", "userAgent") || "";
  });
  var ku = we(function (Yg, Pu) {
    var _u = Ye(),
      Wr = bu(),
      Tu = _u.process,
      Bu = _u.Deno,
      Nu = Tu && Tu.versions || Bu && Bu.version,
      wu = Nu && Nu.v8,
      ft,
      or;
    wu && (ft = wu.split("."), or = ft[0] > 0 && ft[0] < 4 ? 1 : +(ft[0] + ft[1]));
    !or && Wr && (ft = Wr.match(/Edge\/(\d+)/), (!ft || ft[1] >= 74) && (ft = Wr.match(/Chrome\/(\d+)/), ft && (or = +ft[1])));
    Pu.exports = or;
  });
  var $r = we(function (Qg, Lu) {
    var Iu = ku(),
      Jo = Dt();
    Lu.exports = !!Object.getOwnPropertySymbols && !Jo(function () {
      var e = Symbol();
      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;
    });
  });
  var Hr = we(function (Zg, ju) {
    var Uo = $r();
    ju.exports = Uo && !Symbol.sham && _typeof(Symbol.iterator) == "symbol";
  });
  var Gr = we(function (e0, Ou) {
    var zo = Ye(),
      Xo = Rt(),
      Ko = ot(),
      Yo = Vr(),
      Qo = Hr(),
      Zo = zo.Object;
    Ou.exports = Qo ? function (e) {
      return _typeof(e) == "symbol";
    } : function (e) {
      var n = Xo("Symbol");
      return Ko(n) && Yo(n.prototype, Zo(e));
    };
  });
  var lr = we(function (t0, qu) {
    var el = Ye(),
      tl = el.String;
    qu.exports = function (e) {
      try {
        return tl(e);
      } catch (_unused2) {
        return "Object";
      }
    };
  });
  var Vt = we(function (r0, Mu) {
    var rl = Ye(),
      nl = ot(),
      ul = lr(),
      sl = rl.TypeError;
    Mu.exports = function (e) {
      if (nl(e)) return e;
      throw sl(ul(e) + " is not a function");
    };
  });
  var cr = we(function (n0, Ru) {
    var il = Vt();
    Ru.exports = function (e, n) {
      var t = e[n];
      return t == null ? void 0 : il(t);
    };
  });
  var Wu = we(function (u0, Vu) {
    var al = Ye(),
      Jr = Et(),
      Ur = ot(),
      zr = Ft(),
      ol = al.TypeError;
    Vu.exports = function (e, n) {
      var t, s;
      if (n === "string" && Ur(t = e.toString) && !zr(s = Jr(t, e)) || Ur(t = e.valueOf) && !zr(s = Jr(t, e)) || n !== "string" && Ur(t = e.toString) && !zr(s = Jr(t, e))) return s;
      throw ol("Can't convert object to primitive value");
    };
  });
  var Hu = we(function (s0, $u) {
    $u.exports = !1;
  });
  var pr = we(function (i0, Ju) {
    var Gu = Ye(),
      ll = Object.defineProperty;
    Ju.exports = function (e, n) {
      try {
        ll(Gu, e, {
          value: n,
          configurable: !0,
          writable: !0
        });
      } catch (_unused3) {
        Gu[e] = n;
      }
      return n;
    };
  });
  var fr = we(function (a0, zu) {
    var cl = Ye(),
      pl = pr(),
      Uu = "__core-js_shared__",
      fl = cl[Uu] || pl(Uu, {});
    zu.exports = fl;
  });
  var Xr = we(function (o0, Ku) {
    var Dl = Hu(),
      Xu = fr();
    (Ku.exports = function (e, n) {
      return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
    })("versions", []).push({
      version: "3.22.2",
      mode: Dl ? "pure" : "global",
      copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  });
  var Dr = we(function (l0, Yu) {
    var ml = Ye(),
      dl = Mr(),
      gl = ml.Object;
    Yu.exports = function (e) {
      return gl(dl(e));
    };
  });
  var gt = we(function (c0, Qu) {
    var yl = at(),
      hl = Dr(),
      vl = yl({}.hasOwnProperty);
    Qu.exports = Object.hasOwn || function (n, t) {
      return vl(hl(n), t);
    };
  });
  var Kr = we(function (p0, Zu) {
    var Cl = at(),
      El = 0,
      Fl = Math.random(),
      Al = Cl(1 .toString);
    Zu.exports = function (e) {
      return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Al(++El + Fl, 36);
    };
  });
  var St = we(function (f0, us) {
    var Sl = Ye(),
      xl = Xr(),
      es = gt(),
      bl = Kr(),
      ts = $r(),
      ns = Hr(),
      Nt = xl("wks"),
      At = Sl.Symbol,
      rs = At && At.for,
      Tl = ns ? At : At && At.withoutSetter || bl;
    us.exports = function (e) {
      if (!es(Nt, e) || !(ts || typeof Nt[e] == "string")) {
        var n = "Symbol." + e;
        ts && es(At, e) ? Nt[e] = At[e] : ns && rs ? Nt[e] = rs(n) : Nt[e] = Tl(n);
      }
      return Nt[e];
    };
  });
  var os = we(function (D0, as) {
    var Bl = Ye(),
      Nl = Et(),
      ss = Ft(),
      is = Gr(),
      wl = cr(),
      _l = Wu(),
      Pl = St(),
      kl = Bl.TypeError,
      Il = Pl("toPrimitive");
    as.exports = function (e, n) {
      if (!ss(e) || is(e)) return e;
      var t = wl(e, Il),
        s;
      if (t) {
        if (n === void 0 && (n = "default"), s = Nl(t, e, n), !ss(s) || is(s)) return s;
        throw kl("Can't convert object to primitive value");
      }
      return n === void 0 && (n = "number"), _l(e, n);
    };
  });
  var mr = we(function (m0, ls) {
    var Ll = os(),
      jl = Gr();
    ls.exports = function (e) {
      var n = Ll(e, "string");
      return jl(n) ? n : n + "";
    };
  });
  var fs = we(function (d0, ps) {
    var Ol = Ye(),
      cs = Ft(),
      Yr = Ol.document,
      ql = cs(Yr) && cs(Yr.createElement);
    ps.exports = function (e) {
      return ql ? Yr.createElement(e) : {};
    };
  });
  var Qr = we(function (g0, Ds) {
    var Ml = Ct(),
      Rl = Dt(),
      Vl = fs();
    Ds.exports = !Ml && !Rl(function () {
      return Object.defineProperty(Vl("div"), "a", {
        get: function get() {
          return 7;
        }
      }).a != 7;
    });
  });
  var Zr = we(function (ds) {
    var Wl = Ct(),
      $l = Et(),
      Hl = cu(),
      Gl = sr(),
      Jl = ar(),
      Ul = mr(),
      zl = gt(),
      Xl = Qr(),
      ms = Object.getOwnPropertyDescriptor;
    ds.f = Wl ? ms : function (n, t) {
      if (n = Jl(n), t = Ul(t), Xl) try {
        return ms(n, t);
      } catch (_unused4) {}
      if (zl(n, t)) return Gl(!$l(Hl.f, n, t), n[t]);
    };
  });
  var ys = we(function (h0, gs) {
    var Kl = Ct(),
      Yl = Dt();
    gs.exports = Kl && Yl(function () {
      return Object.defineProperty(function () {}, "prototype", {
        value: 42,
        writable: !1
      }).prototype != 42;
    });
  });
  var wt = we(function (v0, vs) {
    var hs = Ye(),
      Ql = Ft(),
      Zl = hs.String,
      ec = hs.TypeError;
    vs.exports = function (e) {
      if (Ql(e)) return e;
      throw ec(Zl(e) + " is not an object");
    };
  });
  var gr = we(function (Es) {
    var tc = Ye(),
      rc = Ct(),
      nc = Qr(),
      uc = ys(),
      dr = wt(),
      Cs = mr(),
      sc = tc.TypeError,
      en = Object.defineProperty,
      ic = Object.getOwnPropertyDescriptor,
      tn = "enumerable",
      rn = "configurable",
      nn = "writable";
    Es.f = rc ? uc ? function (n, t, s) {
      if (dr(n), t = Cs(t), dr(s), typeof n == "function" && t === "prototype" && "value" in s && nn in s && !s[nn]) {
        var a = ic(n, t);
        a && a[nn] && (n[t] = s.value, s = {
          configurable: rn in s ? s[rn] : a[rn],
          enumerable: tn in s ? s[tn] : a[tn],
          writable: !1
        });
      }
      return en(n, t, s);
    } : en : function (n, t, s) {
      if (dr(n), t = Cs(t), dr(s), nc) try {
        return en(n, t, s);
      } catch (_unused5) {}
      if ("get" in s || "set" in s) throw sc("Accessors not supported");
      return "value" in s && (n[t] = s.value), n;
    };
  });
  var yr = we(function (E0, Fs) {
    var ac = Ct(),
      oc = gr(),
      lc = sr();
    Fs.exports = ac ? function (e, n, t) {
      return oc.f(e, n, lc(1, t));
    } : function (e, n, t) {
      return e[n] = t, e;
    };
  });
  var hr = we(function (F0, As) {
    var cc = at(),
      pc = ot(),
      un = fr(),
      fc = cc(Function.toString);
    pc(un.inspectSource) || (un.inspectSource = function (e) {
      return fc(e);
    });
    As.exports = un.inspectSource;
  });
  var bs = we(function (A0, xs) {
    var Dc = Ye(),
      mc = ot(),
      dc = hr(),
      Ss = Dc.WeakMap;
    xs.exports = mc(Ss) && /native code/.test(dc(Ss));
  });
  var Ns = we(function (S0, Bs) {
    var gc = Xr(),
      yc = Kr(),
      Ts = gc("keys");
    Bs.exports = function (e) {
      return Ts[e] || (Ts[e] = yc(e));
    };
  });
  var sn = we(function (x0, ws) {
    ws.exports = {};
  });
  var js = we(function (b0, Ls) {
    var hc = bs(),
      Is = Ye(),
      an = at(),
      vc = Ft(),
      Cc = yr(),
      on = gt(),
      ln = fr(),
      Ec = Ns(),
      Fc = sn(),
      _s = "Object already initialized",
      pn = Is.TypeError,
      Ac = Is.WeakMap,
      vr,
      Wt,
      Cr,
      Sc = function Sc(e) {
        return Cr(e) ? Wt(e) : vr(e, {});
      },
      xc = function xc(e) {
        return function (n) {
          var t;
          if (!vc(n) || (t = Wt(n)).type !== e) throw pn("Incompatible receiver, " + e + " required");
          return t;
        };
      };
    hc || ln.state ? (yt = ln.state || (ln.state = new Ac()), Ps = an(yt.get), cn = an(yt.has), ks = an(yt.set), vr = function vr(e, n) {
      if (cn(yt, e)) throw new pn(_s);
      return n.facade = e, ks(yt, e, n), n;
    }, Wt = function Wt(e) {
      return Ps(yt, e) || {};
    }, Cr = function Cr(e) {
      return cn(yt, e);
    }) : (xt = Ec("state"), Fc[xt] = !0, vr = function vr(e, n) {
      if (on(e, xt)) throw new pn(_s);
      return n.facade = e, Cc(e, xt, n), n;
    }, Wt = function Wt(e) {
      return on(e, xt) ? e[xt] : {};
    }, Cr = function Cr(e) {
      return on(e, xt);
    });
    var yt, Ps, cn, ks, xt;
    Ls.exports = {
      set: vr,
      get: Wt,
      has: Cr,
      enforce: Sc,
      getterFor: xc
    };
  });
  var Ms = we(function (T0, qs) {
    var fn = Ct(),
      bc = gt(),
      Os = Function.prototype,
      Tc = fn && Object.getOwnPropertyDescriptor,
      Dn = bc(Os, "name"),
      Bc = Dn && function () {}.name === "something",
      Nc = Dn && (!fn || fn && Tc(Os, "name").configurable);
    qs.exports = {
      EXISTS: Dn,
      PROPER: Bc,
      CONFIGURABLE: Nc
    };
  });
  var Hs = we(function (B0, $s) {
    var wc = Ye(),
      Rs = ot(),
      _c = gt(),
      Vs = yr(),
      Pc = pr(),
      kc = hr(),
      Ws = js(),
      Ic = Ms().CONFIGURABLE,
      Lc = Ws.get,
      jc = Ws.enforce,
      Oc = String(String).split("String");
    ($s.exports = function (e, n, t, s) {
      var a = s ? !!s.unsafe : !1,
        r = s ? !!s.enumerable : !1,
        u = s ? !!s.noTargetGet : !1,
        i = s && s.name !== void 0 ? s.name : n,
        o;
      if (Rs(t) && (String(i).slice(0, 7) === "Symbol(" && (i = "[" + String(i).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!_c(t, "name") || Ic && t.name !== i) && Vs(t, "name", i), o = jc(t), o.source || (o.source = Oc.join(typeof i == "string" ? i : ""))), e === wc) {
        r ? e[n] = t : Pc(n, t);
        return;
      } else a ? !u && e[n] && (r = !0) : delete e[n];
      r ? e[n] = t : Vs(e, n, t);
    })(Function.prototype, "toString", function () {
      return Rs(this) && Lc(this).source || kc(this);
    });
  });
  var Er = we(function (N0, Gs) {
    var qc = Math.ceil,
      Mc = Math.floor;
    Gs.exports = function (e) {
      var n = +e;
      return n !== n || n === 0 ? 0 : (n > 0 ? Mc : qc)(n);
    };
  });
  var Us = we(function (w0, Js) {
    var Rc = Er(),
      Vc = Math.max,
      Wc = Math.min;
    Js.exports = function (e, n) {
      var t = Rc(e);
      return t < 0 ? Vc(t + n, 0) : Wc(t, n);
    };
  });
  var Xs = we(function (_0, zs) {
    var $c = Er(),
      Hc = Math.min;
    zs.exports = function (e) {
      return e > 0 ? Hc($c(e), 9007199254740991) : 0;
    };
  });
  var _t = we(function (P0, Ks) {
    var Gc = Xs();
    Ks.exports = function (e) {
      return Gc(e.length);
    };
  });
  var Zs = we(function (k0, Qs) {
    var Jc = ar(),
      Uc = Us(),
      zc = _t(),
      Ys = function Ys(e) {
        return function (n, t, s) {
          var a = Jc(n),
            r = zc(a),
            u = Uc(s, r),
            i;
          if (e && t != t) {
            for (; r > u;) {
              if (i = a[u++], i != i) return !0;
            }
          } else for (; r > u; u++) {
            if ((e || u in a) && a[u] === t) return e || u || 0;
          }
          return !e && -1;
        };
      };
    Qs.exports = {
      includes: Ys(!0),
      indexOf: Ys(!1)
    };
  });
  var ri = we(function (I0, ti) {
    var Xc = at(),
      mn = gt(),
      Kc = ar(),
      Yc = Zs().indexOf,
      Qc = sn(),
      ei = Xc([].push);
    ti.exports = function (e, n) {
      var t = Kc(e),
        s = 0,
        a = [],
        r;
      for (r in t) {
        !mn(Qc, r) && mn(t, r) && ei(a, r);
      }
      for (; n.length > s;) {
        mn(t, r = n[s++]) && (~Yc(a, r) || ei(a, r));
      }
      return a;
    };
  });
  var ui = we(function (L0, ni) {
    ni.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
  });
  var ii = we(function (si) {
    var Zc = ri(),
      ep = ui(),
      tp = ep.concat("length", "prototype");
    si.f = Object.getOwnPropertyNames || function (n) {
      return Zc(n, tp);
    };
  });
  var oi = we(function (ai) {
    ai.f = Object.getOwnPropertySymbols;
  });
  var ci = we(function (q0, li) {
    var rp = Rt(),
      np = at(),
      up = ii(),
      sp = oi(),
      ip = wt(),
      ap = np([].concat);
    li.exports = rp("Reflect", "ownKeys") || function (n) {
      var t = up.f(ip(n)),
        s = sp.f;
      return s ? ap(t, s(n)) : t;
    };
  });
  var Di = we(function (M0, fi) {
    var pi = gt(),
      op = ci(),
      lp = Zr(),
      cp = gr();
    fi.exports = function (e, n, t) {
      for (var s = op(n), a = cp.f, r = lp.f, u = 0; u < s.length; u++) {
        var i = s[u];
        !pi(e, i) && !(t && pi(t, i)) && a(e, i, r(n, i));
      }
    };
  });
  var di = we(function (R0, mi) {
    var pp = Dt(),
      fp = ot(),
      Dp = /#|\.prototype\./,
      $t = function $t(e, n) {
        var t = dp[mp(e)];
        return t == yp ? !0 : t == gp ? !1 : fp(n) ? pp(n) : !!n;
      },
      mp = $t.normalize = function (e) {
        return String(e).replace(Dp, ".").toLowerCase();
      },
      dp = $t.data = {},
      gp = $t.NATIVE = "N",
      yp = $t.POLYFILL = "P";
    mi.exports = $t;
  });
  var Ht = we(function (V0, gi) {
    var dn = Ye(),
      hp = Zr().f,
      vp = yr(),
      Cp = Hs(),
      Ep = pr(),
      Fp = Di(),
      Ap = di();
    gi.exports = function (e, n) {
      var t = e.target,
        s = e.global,
        a = e.stat,
        r,
        u,
        i,
        o,
        c,
        v;
      if (s ? u = dn : a ? u = dn[t] || Ep(t, {}) : u = (dn[t] || {}).prototype, u) for (i in n) {
        if (c = n[i], e.noTargetGet ? (v = hp(u, i), o = v && v.value) : o = u[i], r = Ap(s ? i : t + (a ? "." : "#") + i, e.forced), !r && o !== void 0) {
          if (_typeof(c) == _typeof(o)) continue;
          Fp(c, o);
        }
        (e.sham || o && o.sham) && vp(c, "sham", !0), Cp(u, i, c, e);
      }
    };
  });
  var gn = we(function (W0, yi) {
    var Sp = ir();
    yi.exports = Array.isArray || function (n) {
      return Sp(n) == "Array";
    };
  });
  var yn = we(function ($0, vi) {
    var hi = at(),
      xp = Vt(),
      bp = nr(),
      Tp = hi(hi.bind);
    vi.exports = function (e, n) {
      return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function () {
        return e.apply(n, arguments);
      };
    };
  });
  var hn = we(function (H0, Ei) {
    "use strict";

    var Bp = Ye(),
      Np = gn(),
      wp = _t(),
      _p = yn(),
      Pp = Bp.TypeError,
      Ci = function Ci(e, n, t, s, a, r, u, i) {
        for (var o = a, c = 0, v = u ? _p(u, i) : !1, m, d; c < s;) {
          if (c in t) {
            if (m = v ? v(t[c], c, n) : t[c], r > 0 && Np(m)) d = wp(m), o = Ci(e, n, m, d, o, r - 1) - 1;else {
              if (o >= 9007199254740991) throw Pp("Exceed the acceptable array length");
              e[o] = m;
            }
            o++;
          }
          c++;
        }
        return o;
      };
    Ei.exports = Ci;
  });
  var Si = we(function (G0, Ai) {
    var kp = St(),
      Ip = kp("toStringTag"),
      Fi = {};
    Fi[Ip] = "z";
    Ai.exports = String(Fi) === "[object z]";
  });
  var vn = we(function (J0, xi) {
    var Lp = Ye(),
      jp = Si(),
      Op = ot(),
      Fr = ir(),
      qp = St(),
      Mp = qp("toStringTag"),
      Rp = Lp.Object,
      Vp = Fr(function () {
        return arguments;
      }()) == "Arguments",
      Wp = function Wp(e, n) {
        try {
          return e[n];
        } catch (_unused6) {}
      };
    xi.exports = jp ? Fr : function (e) {
      var n, t, s;
      return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Wp(n = Rp(e), Mp)) == "string" ? t : Vp ? Fr(n) : (s = Fr(n)) == "Object" && Op(n.callee) ? "Arguments" : s;
    };
  });
  var _i = we(function (U0, wi) {
    var $p = at(),
      Hp = Dt(),
      bi = ot(),
      Gp = vn(),
      Jp = Rt(),
      Up = hr(),
      Ti = function Ti() {},
      zp = [],
      Bi = Jp("Reflect", "construct"),
      Cn = /^\s*(?:class|function)\b/,
      Xp = $p(Cn.exec),
      Kp = !Cn.exec(Ti),
      Gt = function Gt(n) {
        if (!bi(n)) return !1;
        try {
          return Bi(Ti, zp, n), !0;
        } catch (_unused7) {
          return !1;
        }
      },
      Ni = function Ni(n) {
        if (!bi(n)) return !1;
        switch (Gp(n)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return !1;
        }
        try {
          return Kp || !!Xp(Cn, Up(n));
        } catch (_unused8) {
          return !0;
        }
      };
    Ni.sham = !0;
    wi.exports = !Bi || Hp(function () {
      var e;
      return Gt(Gt.call) || !Gt(Object) || !Gt(function () {
        e = !0;
      }) || e;
    }) ? Ni : Gt;
  });
  var Li = we(function (z0, Ii) {
    var Yp = Ye(),
      Pi = gn(),
      Qp = _i(),
      Zp = Ft(),
      ef = St(),
      tf = ef("species"),
      ki = Yp.Array;
    Ii.exports = function (e) {
      var n;
      return Pi(e) && (n = e.constructor, Qp(n) && (n === ki || Pi(n.prototype)) ? n = void 0 : Zp(n) && (n = n[tf], n === null && (n = void 0))), n === void 0 ? ki : n;
    };
  });
  var En = we(function (X0, ji) {
    var rf = Li();
    ji.exports = function (e, n) {
      return new (rf(e))(n === 0 ? 0 : n);
    };
  });
  var Oi = we(function () {
    "use strict";

    var nf = Ht(),
      uf = hn(),
      sf = Vt(),
      af = Dr(),
      of = _t(),
      lf = En();
    nf({
      target: "Array",
      proto: !0
    }, {
      flatMap: function flatMap(n) {
        var t = af(this),
          s = of(t),
          a;
        return sf(n), a = lf(t, 0), a.length = uf(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;
      }
    });
  });
  var Fn = we(function (Q0, qi) {
    qi.exports = {};
  });
  var Ri = we(function (Z0, Mi) {
    var cf = St(),
      pf = Fn(),
      ff = cf("iterator"),
      Df = Array.prototype;
    Mi.exports = function (e) {
      return e !== void 0 && (pf.Array === e || Df[ff] === e);
    };
  });
  var An = we(function (ey, Wi) {
    var mf = vn(),
      Vi = cr(),
      df = Fn(),
      gf = St(),
      yf = gf("iterator");
    Wi.exports = function (e) {
      if (e != null) return Vi(e, yf) || Vi(e, "@@iterator") || df[mf(e)];
    };
  });
  var Hi = we(function (ty, $i) {
    var hf = Ye(),
      vf = Et(),
      Cf = Vt(),
      Ef = wt(),
      Ff = lr(),
      Af = An(),
      Sf = hf.TypeError;
    $i.exports = function (e, n) {
      var t = arguments.length < 2 ? Af(e) : n;
      if (Cf(t)) return Ef(vf(t, e));
      throw Sf(Ff(e) + " is not iterable");
    };
  });
  var Ui = we(function (ry, Ji) {
    var xf = Et(),
      Gi = wt(),
      bf = cr();
    Ji.exports = function (e, n, t) {
      var s, a;
      Gi(e);
      try {
        if (s = bf(e, "return"), !s) {
          if (n === "throw") throw t;
          return t;
        }
        s = xf(s, e);
      } catch (r) {
        a = !0, s = r;
      }
      if (n === "throw") throw t;
      if (a) throw s;
      return Gi(s), t;
    };
  });
  var Qi = we(function (ny, Yi) {
    var Tf = Ye(),
      Bf = yn(),
      Nf = Et(),
      wf = wt(),
      _f = lr(),
      Pf = Ri(),
      kf = _t(),
      zi = Vr(),
      If = Hi(),
      Lf = An(),
      Xi = Ui(),
      jf = Tf.TypeError,
      Ar = function Ar(e, n) {
        this.stopped = e, this.result = n;
      },
      Ki = Ar.prototype;
    Yi.exports = function (e, n, t) {
      var s = t && t.that,
        a = !!(t && t.AS_ENTRIES),
        r = !!(t && t.IS_ITERATOR),
        u = !!(t && t.INTERRUPTED),
        i = Bf(n, s),
        o,
        c,
        v,
        m,
        d,
        p,
        f,
        h = function h(T) {
          return o && Xi(o, "normal", T), new Ar(!0, T);
        },
        w = function w(T) {
          return a ? (wf(T), u ? i(T[0], T[1], h) : i(T[0], T[1])) : u ? i(T, h) : i(T);
        };
      if (r) o = e;else {
        if (c = Lf(e), !c) throw jf(_f(e) + " is not iterable");
        if (Pf(c)) {
          for (v = 0, m = kf(e); m > v; v++) {
            if (d = w(e[v]), d && zi(Ki, d)) return d;
          }
          return new Ar(!1);
        }
        o = If(e, c);
      }
      for (p = o.next; !(f = Nf(p, o)).done;) {
        try {
          d = w(f.value);
        } catch (T) {
          Xi(o, "throw", T);
        }
        if (_typeof(d) == "object" && d && zi(Ki, d)) return d;
      }
      return new Ar(!1);
    };
  });
  var ea = we(function (uy, Zi) {
    "use strict";

    var Of = mr(),
      qf = gr(),
      Mf = sr();
    Zi.exports = function (e, n, t) {
      var s = Of(n);
      s in e ? qf.f(e, s, Mf(0, t)) : e[s] = t;
    };
  });
  var ta = we(function () {
    var Rf = Ht(),
      Vf = Qi(),
      Wf = ea();
    Rf({
      target: "Object",
      stat: !0
    }, {
      fromEntries: function fromEntries(n) {
        var t = {};
        return Vf(n, function (s, a) {
          Wf(t, s, a);
        }, {
          AS_ENTRIES: !0
        }), t;
      }
    });
  });
  var ra = we(function () {
    var $f = Ht(),
      Hf = Ye();
    $f({
      global: !0
    }, {
      globalThis: Hf
    });
  });
  var na = we(function () {
    ra();
  });
  var ua = we(function () {
    "use strict";

    var Gf = Ht(),
      Jf = hn(),
      Uf = Dr(),
      zf = _t(),
      Xf = Er(),
      Kf = En();
    Gf({
      target: "Array",
      proto: !0
    }, {
      flat: function flat() {
        var n = arguments.length ? arguments[0] : void 0,
          t = Uf(this),
          s = zf(t),
          a = Kf(t, 0);
        return a.length = Jf(a, t, t, s, 0, n === void 0 ? 1 : Xf(n)), a;
      }
    });
  });
  var Pg = we(function (my, Co) {
    var Yf = ["cliName", "cliCategory", "cliDescription"],
      Qf = ["_"],
      Zf = ["languageId"],
      sa,
      ia,
      aa,
      oa,
      la,
      ca;
    function kn(e, n) {
      if (e == null) return {};
      var t = eD(e, n),
        s,
        a;
      if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        for (a = 0; a < r.length; a++) {
          s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
        }
      }
      return t;
    }
    function eD(e, n) {
      if (e == null) return {};
      var t = {},
        s = Object.keys(e),
        a,
        r;
      for (r = 0; r < s.length; r++) {
        a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
      }
      return t;
    }
    Oi();
    ta();
    na();
    ua();
    function Pt(e, n) {
      return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, {
        raw: {
          value: Object.freeze(n)
        }
      }));
    }
    var tD = Object.create,
      Br = Object.defineProperty,
      rD = Object.getOwnPropertyDescriptor,
      In = Object.getOwnPropertyNames,
      nD = Object.getPrototypeOf,
      uD = Object.prototype.hasOwnProperty,
      mt = function mt(e, n) {
        return function () {
          return e && (n = (0, e[In(e)[0]])(e = 0)), n;
        };
      },
      Z = function Z(e, n) {
        return function () {
          return n || (0, e[In(e)[0]])((n = {
            exports: {}
          }).exports, n), n.exports;
        };
      },
      Ut = function Ut(e, n) {
        for (var t in n) {
          Br(e, t, {
            get: n[t],
            enumerable: !0
          });
        }
      },
      ga = function ga(e, n, t, s) {
        if (n && _typeof(n) == "object" || typeof n == "function") {
          var _iterator = _createForOfIteratorHelper(In(n)),
            _step;
          try {
            var _loop = function _loop() {
              var a = _step.value;
              !uD.call(e, a) && a !== t && Br(e, a, {
                get: function get() {
                  return n[a];
                },
                enumerable: !(s = rD(n, a)) || s.enumerable
              });
            };
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return e;
      },
      sD = function sD(e, n, t) {
        return t = e != null ? tD(nD(e)) : {}, ga(n || !e || !e.__esModule ? Br(t, "default", {
          value: e,
          enumerable: !0
        }) : t, e);
      },
      lt = function lt(e) {
        return ga(Br({}, "__esModule", {
          value: !0
        }), e);
      },
      pa,
      fa,
      Tt,
      re = mt({
        "<define:process>": function defineProcess() {
          pa = {}, fa = [], Tt = {
            env: pa,
            argv: fa
          };
        }
      }),
      ya = Z({
        "package.json": function packageJson(e, n) {
          n.exports = {
            version: "2.7.1"
          };
        }
      }),
      iD = Z({
        "node_modules/diff/lib/diff/base.js": function node_modulesDiffLibDiffBaseJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.default = n;
          function n() {}
          n.prototype = {
            diff: function diff(r, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                o = i.callback;
              typeof i == "function" && (o = i, i = {}), this.options = i;
              var c = this;
              function v(S) {
                return o ? (setTimeout(function () {
                  o(void 0, S);
                }, 0), !0) : S;
              }
              r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
              var m = u.length,
                d = r.length,
                p = 1,
                f = m + d,
                h = [{
                  newPos: -1,
                  components: []
                }],
                w = this.extractCommon(h[0], u, r, 0);
              if (h[0].newPos + 1 >= m && w + 1 >= d) return v([{
                value: this.join(u),
                count: u.length
              }]);
              function T() {
                for (var S = -1 * p; S <= p; S += 2) {
                  var B = void 0,
                    I = h[S - 1],
                    k = h[S + 1],
                    P = (k ? k.newPos : 0) - S;
                  I && (h[S - 1] = void 0);
                  var C = I && I.newPos + 1 < m,
                    D = k && 0 <= P && P < d;
                  if (!C && !D) {
                    h[S] = void 0;
                    continue;
                  }
                  if (!C || D && I.newPos < k.newPos ? (B = s(k), c.pushComponent(B.components, void 0, !0)) : (B = I, B.newPos++, c.pushComponent(B.components, !0, void 0)), P = c.extractCommon(B, u, r, S), B.newPos + 1 >= m && P + 1 >= d) return v(t(c, B.components, u, r, c.useLongestToken));
                  h[S] = B;
                }
                p++;
              }
              if (o) (function S() {
                setTimeout(function () {
                  if (p > f) return o();
                  T() || S();
                }, 0);
              })();else for (; p <= f;) {
                var A = T();
                if (A) return A;
              }
            },
            pushComponent: function pushComponent(r, u, i) {
              var o = r[r.length - 1];
              o && o.added === u && o.removed === i ? r[r.length - 1] = {
                count: o.count + 1,
                added: u,
                removed: i
              } : r.push({
                count: 1,
                added: u,
                removed: i
              });
            },
            extractCommon: function extractCommon(r, u, i, o) {
              for (var c = u.length, v = i.length, m = r.newPos, d = m - o, p = 0; m + 1 < c && d + 1 < v && this.equals(u[m + 1], i[d + 1]);) {
                m++, d++, p++;
              }
              return p && r.components.push({
                count: p
              }), r.newPos = m, d;
            },
            equals: function equals(r, u) {
              return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
            },
            removeEmpty: function removeEmpty(r) {
              for (var u = [], i = 0; i < r.length; i++) {
                r[i] && u.push(r[i]);
              }
              return u;
            },
            castInput: function castInput(r) {
              return r;
            },
            tokenize: function tokenize(r) {
              return r.split("");
            },
            join: function join(r) {
              return r.join("");
            }
          };
          function t(a, r, u, i, o) {
            for (var c = 0, v = r.length, m = 0, d = 0; c < v; c++) {
              var p = r[c];
              if (p.removed) {
                if (p.value = a.join(i.slice(d, d + p.count)), d += p.count, c && r[c - 1].added) {
                  var h = r[c - 1];
                  r[c - 1] = r[c], r[c] = h;
                }
              } else {
                if (!p.added && o) {
                  var f = u.slice(m, m + p.count);
                  f = f.map(function (T, A) {
                    var S = i[d + A];
                    return S.length > T.length ? S : T;
                  }), p.value = a.join(f);
                } else p.value = a.join(u.slice(m, m + p.count));
                m += p.count, p.added || (d += p.count);
              }
            }
            var w = r[v - 1];
            return v > 1 && typeof w.value == "string" && (w.added || w.removed) && a.equals("", w.value) && (r[v - 2].value += w.value, r.pop()), r;
          }
          function s(a) {
            return {
              newPos: a.newPos,
              components: a.components.slice(0)
            };
          }
        }
      }),
      aD = Z({
        "node_modules/diff/lib/diff/array.js": function node_modulesDiffLibDiffArrayJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.diffArrays = a, e.arrayDiff = void 0;
          var n = t(iD());
          function t(r) {
            return r && r.__esModule ? r : {
              default: r
            };
          }
          var s = new n.default();
          e.arrayDiff = s, s.tokenize = function (r) {
            return r.slice();
          }, s.join = s.removeEmpty = function (r) {
            return r;
          };
          function a(r, u, i) {
            return s.diff(r, u, i);
          }
        }
      }),
      Ln = Z({
        "src/document/doc-builders.js": function srcDocumentDocBuildersJs(e, n) {
          "use strict";

          re();
          function t(F) {
            return {
              type: "concat",
              parts: F
            };
          }
          function s(F) {
            return {
              type: "indent",
              contents: F
            };
          }
          function a(F, l) {
            return {
              type: "align",
              contents: l,
              n: F
            };
          }
          function r(F) {
            var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return {
              type: "group",
              id: l.id,
              contents: F,
              break: Boolean(l.shouldBreak),
              expandedStates: l.expandedStates
            };
          }
          function u(F) {
            return a(Number.NEGATIVE_INFINITY, F);
          }
          function i(F) {
            return a({
              type: "root"
            }, F);
          }
          function o(F) {
            return a(-1, F);
          }
          function c(F, l) {
            return r(F[0], Object.assign(Object.assign({}, l), {}, {
              expandedStates: F
            }));
          }
          function v(F) {
            return {
              type: "fill",
              parts: F
            };
          }
          function m(F, l) {
            var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return {
              type: "if-break",
              breakContents: F,
              flatContents: l,
              groupId: E.groupId
            };
          }
          function d(F, l) {
            return {
              type: "indent-if-break",
              contents: F,
              groupId: l.groupId,
              negate: l.negate
            };
          }
          function p(F) {
            return {
              type: "line-suffix",
              contents: F
            };
          }
          var f = {
              type: "line-suffix-boundary"
            },
            h = {
              type: "break-parent"
            },
            w = {
              type: "trim"
            },
            T = {
              type: "line",
              hard: !0
            },
            A = {
              type: "line",
              hard: !0,
              literal: !0
            },
            S = {
              type: "line"
            },
            B = {
              type: "line",
              soft: !0
            },
            I = t([T, h]),
            k = t([A, h]),
            P = {
              type: "cursor",
              placeholder: Symbol("cursor")
            };
          function C(F, l) {
            var E = [];
            for (var y = 0; y < l.length; y++) {
              y !== 0 && E.push(F), E.push(l[y]);
            }
            return t(E);
          }
          function D(F, l, E) {
            var y = F;
            if (l > 0) {
              for (var N = 0; N < Math.floor(l / E); ++N) {
                y = s(y);
              }
              y = a(l % E, y), y = a(Number.NEGATIVE_INFINITY, y);
            }
            return y;
          }
          function g(F, l) {
            return {
              type: "label",
              label: F,
              contents: l
            };
          }
          n.exports = {
            concat: t,
            join: C,
            line: S,
            softline: B,
            hardline: I,
            literalline: k,
            group: r,
            conditionalGroup: c,
            fill: v,
            lineSuffix: p,
            lineSuffixBoundary: f,
            cursor: P,
            breakParent: h,
            ifBreak: m,
            trim: w,
            indent: s,
            indentIfBreak: d,
            align: a,
            addAlignmentToDoc: D,
            markAsRoot: i,
            dedentToRoot: u,
            dedent: o,
            hardlineWithoutBreakParent: T,
            literallineWithoutBreakParent: A,
            label: g
          };
        }
      }),
      jn = Z({
        "src/common/end-of-line.js": function srcCommonEndOfLineJs(e, n) {
          "use strict";

          re();
          function t(u) {
            var i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === "\n" ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return "\r\n";
              default:
                return "\n";
            }
          }
          function a(u, i) {
            var o;
            switch (i) {
              case "\n":
                o = /\n/g;
                break;
              case "\r":
                o = /\r/g;
                break;
              case "\r\n":
                o = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(i), "."));
            }
            var c = u.match(o);
            return c ? c.length : 0;
          }
          function r(u) {
            return u.replace(/\r\n?/g, "\n");
          }
          n.exports = {
            guessEndOfLine: t,
            convertEndOfLineToChars: s,
            countEndOfLineChars: a,
            normalizeEndOfLine: r
          };
        }
      }),
      it = Z({
        "src/utils/get-last.js": function srcUtilsGetLastJs(e, n) {
          "use strict";

          re();
          var t = function t(s) {
            return s[s.length - 1];
          };
          n.exports = t;
        }
      });
    function oD() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        _ref$onlyFirst = _ref.onlyFirst,
        e = _ref$onlyFirst === void 0 ? !1 : _ref$onlyFirst,
        n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(n, e ? void 0 : "g");
    }
    var lD = mt({
      "node_modules/strip-ansi/node_modules/ansi-regex/index.js": function node_modulesStripAnsiNode_modulesAnsiRegexIndexJs() {
        re();
      }
    });
    function cD(e) {
      if (typeof e != "string") throw new TypeError("Expected a `string`, got `".concat(_typeof(e), "`"));
      return e.replace(oD(), "");
    }
    var pD = mt({
      "node_modules/strip-ansi/index.js": function node_modulesStripAnsiIndexJs() {
        re(), lD();
      }
    });
    function fD(e) {
      return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : !1;
    }
    var DD = mt({
        "node_modules/is-fullwidth-code-point/index.js": function node_modulesIsFullwidthCodePointIndexJs() {
          re();
        }
      }),
      mD = Z({
        "node_modules/emoji-regex/index.js": function node_modulesEmojiRegexIndexJs(e, n) {
          "use strict";

          re(), n.exports = function () {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        }
      }),
      ha = {};
    Ut(ha, {
      default: function _default() {
        return dD;
      }
    });
    function dD(e) {
      if (typeof e != "string" || e.length === 0 || (e = cD(e), e.length === 0)) return 0;
      e = e.replace((0, va.default)(), "  ");
      var n = 0;
      for (var t = 0; t < e.length; t++) {
        var s = e.codePointAt(t);
        s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += fD(s) ? 2 : 1);
      }
      return n;
    }
    var va,
      gD = mt({
        "node_modules/string-width/index.js": function node_modulesStringWidthIndexJs() {
          re(), pD(), DD(), va = sD(mD());
        }
      }),
      Ca = Z({
        "src/utils/get-string-width.js": function srcUtilsGetStringWidthJs(e, n) {
          "use strict";

          re();
          var t = (gD(), lt(ha)).default,
            s = /[^\x20-\x7F]/;
          function a(r) {
            return r ? s.test(r) ? t(r) : r.length : 0;
          }
          n.exports = a;
        }
      }),
      On = Z({
        "src/document/doc-utils.js": function srcDocumentDocUtilsJs(e, n) {
          "use strict";

          re();
          var t = it(),
            _Ln = Ln(),
            s = _Ln.literalline,
            a = _Ln.join,
            r = function r(l) {
              return Array.isArray(l) || l && l.type === "concat";
            },
            u = function u(l) {
              if (Array.isArray(l)) return l;
              if (l.type !== "concat" && l.type !== "fill") throw new Error("Expect doc type to be `concat` or `fill`.");
              return l.parts;
            },
            i = {};
          function o(l, E, y, N) {
            var x = [l];
            for (; x.length > 0;) {
              var b = x.pop();
              if (b === i) {
                y(x.pop());
                continue;
              }
              if (y && x.push(b, i), !E || E(b) !== !1) if (r(b) || b.type === "fill") {
                var L = u(b);
                for (var M = L.length, j = M - 1; j >= 0; --j) {
                  x.push(L[j]);
                }
              } else if (b.type === "if-break") b.flatContents && x.push(b.flatContents), b.breakContents && x.push(b.breakContents);else if (b.type === "group" && b.expandedStates) {
                if (N) for (var _L = b.expandedStates.length, _M = _L - 1; _M >= 0; --_M) {
                  x.push(b.expandedStates[_M]);
                } else x.push(b.contents);
              } else b.contents && x.push(b.contents);
            }
          }
          function c(l, E) {
            var y = new Map();
            return N(l);
            function N(b) {
              if (y.has(b)) return y.get(b);
              var L = x(b);
              return y.set(b, L), L;
            }
            function x(b) {
              if (Array.isArray(b)) return E(b.map(N));
              if (b.type === "concat" || b.type === "fill") {
                var L = b.parts.map(N);
                return E(Object.assign(Object.assign({}, b), {}, {
                  parts: L
                }));
              }
              if (b.type === "if-break") {
                var _L2 = b.breakContents && N(b.breakContents),
                  M = b.flatContents && N(b.flatContents);
                return E(Object.assign(Object.assign({}, b), {}, {
                  breakContents: _L2,
                  flatContents: M
                }));
              }
              if (b.type === "group" && b.expandedStates) {
                var _L3 = b.expandedStates.map(N),
                  _M2 = _L3[0];
                return E(Object.assign(Object.assign({}, b), {}, {
                  contents: _M2,
                  expandedStates: _L3
                }));
              }
              if (b.contents) {
                var _L4 = N(b.contents);
                return E(Object.assign(Object.assign({}, b), {}, {
                  contents: _L4
                }));
              }
              return E(b);
            }
          }
          function v(l, E, y) {
            var N = y,
              x = !1;
            function b(L) {
              var M = E(L);
              if (M !== void 0 && (x = !0, N = M), x) return !1;
            }
            return o(l, b), N;
          }
          function m(l) {
            if (l.type === "group" && l.break || l.type === "line" && l.hard || l.type === "break-parent") return !0;
          }
          function d(l) {
            return v(l, m, !1);
          }
          function p(l) {
            if (l.length > 0) {
              var E = t(l);
              !E.expandedStates && !E.break && (E.break = "propagated");
            }
            return null;
          }
          function f(l) {
            var E = new Set(),
              y = [];
            function N(b) {
              if (b.type === "break-parent" && p(y), b.type === "group") {
                if (y.push(b), E.has(b)) return !1;
                E.add(b);
              }
            }
            function x(b) {
              b.type === "group" && y.pop().break && p(y);
            }
            o(l, N, x, !0);
          }
          function h(l) {
            return l.type === "line" && !l.hard ? l.soft ? "" : " " : l.type === "if-break" ? l.flatContents || "" : l;
          }
          function w(l) {
            return c(l, h);
          }
          var T = function T(l, E) {
            return l && l.type === "line" && l.hard && E && E.type === "break-parent";
          };
          function A(l) {
            if (!l) return l;
            if (r(l) || l.type === "fill") {
              var E = u(l);
              for (; E.length > 1 && T.apply(void 0, _toConsumableArray(E.slice(-2)));) {
                E.length -= 2;
              }
              if (E.length > 0) {
                var y = A(t(E));
                E[E.length - 1] = y;
              }
              return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {
                parts: E
              });
            }
            switch (l.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label":
                {
                  var _E = A(l.contents);
                  return Object.assign(Object.assign({}, l), {}, {
                    contents: _E
                  });
                }
              case "if-break":
                {
                  var _E2 = A(l.breakContents),
                    _y = A(l.flatContents);
                  return Object.assign(Object.assign({}, l), {}, {
                    breakContents: _E2,
                    flatContents: _y
                  });
                }
            }
            return l;
          }
          function S(l) {
            return A(I(l));
          }
          function B(l) {
            switch (l.type) {
              case "fill":
                if (l.parts.every(function (y) {
                  return y === "";
                })) return "";
                break;
              case "group":
                if (!l.contents && !l.id && !l.break && !l.expandedStates) return "";
                if (l.contents.type === "group" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates) return l.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!l.contents) return "";
                break;
              case "if-break":
                if (!l.flatContents && !l.breakContents) return "";
                break;
            }
            if (!r(l)) return l;
            var E = [];
            var _iterator2 = _createForOfIteratorHelper(u(l)),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var y = _step2.value;
                if (!y) continue;
                var _ref2 = r(y) ? u(y) : [y],
                  _ref3 = _toArray(_ref2),
                  N = _ref3[0],
                  x = _ref3.slice(1);
                typeof N == "string" && typeof t(E) == "string" ? E[E.length - 1] += N : E.push(N), E.push.apply(E, _toConsumableArray(x));
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            return E.length === 0 ? "" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {
              parts: E
            });
          }
          function I(l) {
            return c(l, function (E) {
              return B(E);
            });
          }
          function k(l) {
            var E = [],
              y = l.filter(Boolean);
            for (; y.length > 0;) {
              var N = y.shift();
              if (!!N) {
                if (r(N)) {
                  y.unshift.apply(y, _toConsumableArray(u(N)));
                  continue;
                }
                if (E.length > 0 && typeof t(E) == "string" && typeof N == "string") {
                  E[E.length - 1] += N;
                  continue;
                }
                E.push(N);
              }
            }
            return E;
          }
          function P(l) {
            return c(l, function (E) {
              return Array.isArray(E) ? k(E) : E.parts ? Object.assign(Object.assign({}, E), {}, {
                parts: k(E.parts)
              }) : E;
            });
          }
          function C(l) {
            return c(l, function (E) {
              return typeof E == "string" && E.includes("\n") ? D(E) : E;
            });
          }
          function D(l) {
            var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(E, l.split("\n")).parts;
          }
          function g(l) {
            if (l.type === "line") return !0;
          }
          function F(l) {
            return v(l, g, !1);
          }
          n.exports = {
            isConcat: r,
            getDocParts: u,
            willBreak: d,
            traverseDoc: o,
            findInDoc: v,
            mapDoc: c,
            propagateBreaks: f,
            removeLines: w,
            stripTrailingHardline: S,
            normalizeParts: k,
            normalizeDoc: P,
            cleanDoc: I,
            replaceTextEndOfLine: D,
            replaceEndOfLine: C,
            canBreak: F
          };
        }
      }),
      yD = Z({
        "src/document/doc-printer.js": function srcDocumentDocPrinterJs(e, n) {
          "use strict";

          re();
          var _jn = jn(),
            t = _jn.convertEndOfLineToChars,
            s = it(),
            a = Ca(),
            _Ln2 = Ln(),
            r = _Ln2.fill,
            u = _Ln2.cursor,
            i = _Ln2.indent,
            _On = On(),
            o = _On.isConcat,
            c = _On.getDocParts,
            v,
            m = 1,
            d = 2;
          function p() {
            return {
              value: "",
              length: 0,
              queue: []
            };
          }
          function f(B, I) {
            return w(B, {
              type: "indent"
            }, I);
          }
          function h(B, I, k) {
            return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, {
              type: "dedent"
            }, k) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, {
              root: B
            }) : w(B, {
              type: typeof I == "string" ? "stringAlign" : "numberAlign",
              n: I
            }, k) : B;
          }
          function w(B, I, k) {
            var P = I.type === "dedent" ? B.queue.slice(0, -1) : [].concat(_toConsumableArray(B.queue), [I]),
              C = "",
              D = 0,
              g = 0,
              F = 0;
            var _iterator3 = _createForOfIteratorHelper(P),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var L = _step3.value;
                switch (L.type) {
                  case "indent":
                    y(), k.useTabs ? l(1) : E(k.tabWidth);
                    break;
                  case "stringAlign":
                    y(), C += L.n, D += L.n.length;
                    break;
                  case "numberAlign":
                    g += 1, F += L.n;
                    break;
                  default:
                    throw new Error("Unexpected type '".concat(L.type, "'"));
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            return x(), Object.assign(Object.assign({}, B), {}, {
              value: C,
              length: D,
              queue: P
            });
            function l(L) {
              C += "	".repeat(L), D += k.tabWidth * L;
            }
            function E(L) {
              C += " ".repeat(L), D += L;
            }
            function y() {
              k.useTabs ? N() : x();
            }
            function N() {
              g > 0 && l(g), b();
            }
            function x() {
              F > 0 && E(F), b();
            }
            function b() {
              g = 0, F = 0;
            }
          }
          function T(B) {
            if (B.length === 0) return 0;
            var I = 0;
            for (; B.length > 0 && typeof s(B) == "string" && /^[\t ]*$/.test(s(B));) {
              I += B.pop().length;
            }
            if (B.length > 0 && typeof s(B) == "string") {
              var k = s(B).replace(/[\t ]*$/, "");
              I += s(B).length - k.length, B[B.length - 1] = k;
            }
            return I;
          }
          function A(B, I, k, P, C, D) {
            var g = I.length,
              F = [B],
              l = [];
            for (; k >= 0;) {
              if (F.length === 0) {
                if (g === 0) return !0;
                F.push(I[g - 1]), g--;
                continue;
              }
              var _F$pop = F.pop(),
                _F$pop2 = _slicedToArray(_F$pop, 3),
                E = _F$pop2[0],
                y = _F$pop2[1],
                N = _F$pop2[2];
              if (typeof N == "string") l.push(N), k -= a(N);else if (o(N)) {
                var x = c(N);
                for (var b = x.length - 1; b >= 0; b--) {
                  F.push([E, y, x[b]]);
                }
              } else switch (N.type) {
                case "indent":
                  F.push([f(E, P), y, N.contents]);
                  break;
                case "align":
                  F.push([h(E, N.n, P), y, N.contents]);
                  break;
                case "trim":
                  k += T(l);
                  break;
                case "group":
                  {
                    if (D && N.break) return !1;
                    var _x = N.break ? m : y;
                    F.push([E, _x, N.expandedStates && _x === m ? s(N.expandedStates) : N.contents]), N.id && (v[N.id] = _x);
                    break;
                  }
                case "fill":
                  for (var _x2 = N.parts.length - 1; _x2 >= 0; _x2--) {
                    F.push([E, y, N.parts[_x2]]);
                  }
                  break;
                case "if-break":
                case "indent-if-break":
                  {
                    var _x3 = N.groupId ? v[N.groupId] : y;
                    if (_x3 === m) {
                      var _b = N.type === "if-break" ? N.breakContents : N.negate ? N.contents : i(N.contents);
                      _b && F.push([E, y, _b]);
                    }
                    if (_x3 === d) {
                      var _b2 = N.type === "if-break" ? N.flatContents : N.negate ? i(N.contents) : N.contents;
                      _b2 && F.push([E, y, _b2]);
                    }
                    break;
                  }
                case "line":
                  switch (y) {
                    case d:
                      if (!N.hard) {
                        N.soft || (l.push(" "), k -= 1);
                        break;
                      }
                      return !0;
                    case m:
                      return !0;
                  }
                  break;
                case "line-suffix":
                  C = !0;
                  break;
                case "line-suffix-boundary":
                  if (C) return !1;
                  break;
                case "label":
                  F.push([E, y, N.contents]);
                  break;
              }
            }
            return !1;
          }
          function S(B, I) {
            v = {};
            var k = I.printWidth,
              P = t(I.endOfLine),
              C = 0,
              D = [[p(), m, B]],
              g = [],
              F = !1,
              l = [];
            for (; D.length > 0;) {
              var _D$pop = D.pop(),
                _D$pop2 = _slicedToArray(_D$pop, 3),
                y = _D$pop2[0],
                N = _D$pop2[1],
                x = _D$pop2[2];
              if (typeof x == "string") {
                var b = P !== "\n" ? x.replace(/\n/g, P) : x;
                g.push(b), C += a(b);
              } else if (o(x)) {
                var _b3 = c(x);
                for (var L = _b3.length - 1; L >= 0; L--) {
                  D.push([y, N, _b3[L]]);
                }
              } else switch (x.type) {
                case "cursor":
                  g.push(u.placeholder);
                  break;
                case "indent":
                  D.push([f(y, I), N, x.contents]);
                  break;
                case "align":
                  D.push([h(y, x.n, I), N, x.contents]);
                  break;
                case "trim":
                  C -= T(g);
                  break;
                case "group":
                  switch (N) {
                    case d:
                      if (!F) {
                        D.push([y, x.break ? m : d, x.contents]);
                        break;
                      }
                    case m:
                      {
                        F = !1;
                        var _b4 = [y, d, x.contents],
                          _L5 = k - C,
                          M = l.length > 0;
                        if (!x.break && A(_b4, D, _L5, I, M)) D.push(_b4);else if (x.expandedStates) {
                          var j = s(x.expandedStates);
                          if (x.break) {
                            D.push([y, m, j]);
                            break;
                          } else for (var $ = 1; $ < x.expandedStates.length + 1; $++) {
                            if ($ >= x.expandedStates.length) {
                              D.push([y, m, j]);
                              break;
                            } else {
                              var V = x.expandedStates[$],
                                q = [y, d, V];
                              if (A(q, D, _L5, I, M)) {
                                D.push(q);
                                break;
                              }
                            }
                          }
                        } else D.push([y, m, x.contents]);
                        break;
                      }
                  }
                  x.id && (v[x.id] = s(D)[1]);
                  break;
                case "fill":
                  {
                    var _b5 = k - C,
                      _L6 = x.parts;
                    if (_L6.length === 0) break;
                    var _L7 = _slicedToArray(_L6, 2),
                      _M3 = _L7[0],
                      _j = _L7[1],
                      _$ = [y, d, _M3],
                      _V = [y, m, _M3],
                      _q = A(_$, [], _b5, I, l.length > 0, !0);
                    if (_L6.length === 1) {
                      _q ? D.push(_$) : D.push(_V);
                      break;
                    }
                    var Y = [y, d, _j],
                      H = [y, m, _j];
                    if (_L6.length === 2) {
                      _q ? D.push(Y, _$) : D.push(H, _V);
                      break;
                    }
                    _L6.splice(0, 2);
                    var R = [y, N, r(_L6)],
                      Q = _L6[0];
                    A([y, d, [_M3, _j, Q]], [], _b5, I, l.length > 0, !0) ? D.push(R, Y, _$) : _q ? D.push(R, H, _$) : D.push(R, H, _V);
                    break;
                  }
                case "if-break":
                case "indent-if-break":
                  {
                    var _b6 = x.groupId ? v[x.groupId] : N;
                    if (_b6 === m) {
                      var _L8 = x.type === "if-break" ? x.breakContents : x.negate ? x.contents : i(x.contents);
                      _L8 && D.push([y, N, _L8]);
                    }
                    if (_b6 === d) {
                      var _L9 = x.type === "if-break" ? x.flatContents : x.negate ? i(x.contents) : x.contents;
                      _L9 && D.push([y, N, _L9]);
                    }
                    break;
                  }
                case "line-suffix":
                  l.push([y, N, x.contents]);
                  break;
                case "line-suffix-boundary":
                  l.length > 0 && D.push([y, N, {
                    type: "line",
                    hard: !0
                  }]);
                  break;
                case "line":
                  switch (N) {
                    case d:
                      if (x.hard) F = !0;else {
                        x.soft || (g.push(" "), C += 1);
                        break;
                      }
                    case m:
                      if (l.length > 0) {
                        D.push.apply(D, [[y, N, x]].concat(_toConsumableArray(l.reverse()))), l = [];
                        break;
                      }
                      x.literal ? y.root ? (g.push(P, y.root.value), C = y.root.length) : (g.push(P), C = 0) : (C -= T(g), g.push(P + y.value), C = y.length);
                      break;
                  }
                  break;
                case "label":
                  D.push([y, N, x.contents]);
                  break;
                default:
              }
              D.length === 0 && l.length > 0 && (D.push.apply(D, _toConsumableArray(l.reverse())), l = []);
            }
            var E = g.indexOf(u.placeholder);
            if (E !== -1) {
              var _y2 = g.indexOf(u.placeholder, E + 1),
                _N = g.slice(0, E).join(""),
                _x4 = g.slice(E + 1, _y2).join(""),
                _b7 = g.slice(_y2 + 1).join("");
              return {
                formatted: _N + _x4 + _b7,
                cursorNodeStart: _N.length,
                cursorNodeText: _x4
              };
            }
            return {
              formatted: g.join("")
            };
          }
          n.exports = {
            printDocToString: S
          };
        }
      }),
      hD = Z({
        "src/document/doc-debug.js": function srcDocumentDocDebugJs(e, n) {
          "use strict";

          re();
          var _On2 = On(),
            t = _On2.isConcat,
            s = _On2.getDocParts;
          function a(u) {
            if (!u) return "";
            if (t(u)) {
              var i = [];
              var _iterator4 = _createForOfIteratorHelper(s(u)),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var o = _step4.value;
                  if (t(o)) i.push.apply(i, _toConsumableArray(a(o).parts));else {
                    var c = a(o);
                    c !== "" && i.push(c);
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              return {
                type: "concat",
                parts: i
              };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, {
              breakContents: a(u.breakContents),
              flatContents: a(u.flatContents)
            }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, {
              contents: a(u.contents),
              expandedStates: u.expandedStates && u.expandedStates.map(a)
            }) : u.type === "fill" ? {
              type: "fill",
              parts: u.parts.map(a)
            } : u.contents ? Object.assign(Object.assign({}, u), {}, {
              contents: a(u.contents)
            }) : u;
          }
          function r(u) {
            var i = Object.create(null),
              o = new Set();
            return c(a(u));
            function c(m, d, p) {
              if (typeof m == "string") return JSON.stringify(m);
              if (t(m)) {
                var f = s(m).map(c).filter(Boolean);
                return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
              }
              if (m.type === "line") {
                var _f2 = Array.isArray(p) && p[d + 1] && p[d + 1].type === "break-parent";
                return m.literal ? _f2 ? "literalline" : "literallineWithoutBreakParent" : m.hard ? _f2 ? "hardline" : "hardlineWithoutBreakParent" : m.soft ? "softline" : "line";
              }
              if (m.type === "break-parent") return Array.isArray(p) && p[d - 1] && p[d - 1].type === "line" && p[d - 1].hard ? void 0 : "breakParent";
              if (m.type === "trim") return "trim";
              if (m.type === "indent") return "indent(" + c(m.contents) + ")";
              if (m.type === "align") return m.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(m.contents) + ")" : m.n < 0 ? "dedent(" + c(m.contents) + ")" : m.n.type === "root" ? "markAsRoot(" + c(m.contents) + ")" : "align(" + JSON.stringify(m.n) + ", " + c(m.contents) + ")";
              if (m.type === "if-break") return "ifBreak(" + c(m.breakContents) + (m.flatContents ? ", " + c(m.flatContents) : "") + (m.groupId ? (m.flatContents ? "" : ', ""') + ", { groupId: ".concat(v(m.groupId), " }") : "") + ")";
              if (m.type === "indent-if-break") {
                var _f3 = [];
                m.negate && _f3.push("negate: true"), m.groupId && _f3.push("groupId: ".concat(v(m.groupId)));
                var h = _f3.length > 0 ? ", { ".concat(_f3.join(", "), " }") : "";
                return "indentIfBreak(".concat(c(m.contents)).concat(h, ")");
              }
              if (m.type === "group") {
                var _f4 = [];
                m.break && m.break !== "propagated" && _f4.push("shouldBreak: true"), m.id && _f4.push("id: ".concat(v(m.id)));
                var _h = _f4.length > 0 ? ", { ".concat(_f4.join(", "), " }") : "";
                return m.expandedStates ? "conditionalGroup([".concat(m.expandedStates.map(function (w) {
                  return c(w);
                }).join(","), "]").concat(_h, ")") : "group(".concat(c(m.contents)).concat(_h, ")");
              }
              if (m.type === "fill") return "fill([".concat(m.parts.map(function (f) {
                return c(f);
              }).join(", "), "])");
              if (m.type === "line-suffix") return "lineSuffix(" + c(m.contents) + ")";
              if (m.type === "line-suffix-boundary") return "lineSuffixBoundary";
              if (m.type === "label") return "label(".concat(JSON.stringify(m.label), ", ").concat(c(m.contents), ")");
              throw new Error("Unknown doc type " + m.type);
            }
            function v(m) {
              if (_typeof(m) != "symbol") return JSON.stringify(String(m));
              if (m in i) return i[m];
              var d = String(m).slice(7, -1) || "symbol";
              for (var p = 0;; p++) {
                var f = d + (p > 0 ? " #".concat(p) : "");
                if (!o.has(f)) return o.add(f), i[m] = "Symbol.for(".concat(JSON.stringify(f), ")");
              }
            }
          }
          n.exports = {
            printDocToDebug: r
          };
        }
      }),
      Oe = Z({
        "src/document/index.js": function srcDocumentIndexJs(e, n) {
          "use strict";

          re(), n.exports = {
            builders: Ln(),
            printer: yD(),
            utils: On(),
            debug: hD()
          };
        }
      }),
      Ea = {};
    Ut(Ea, {
      default: function _default() {
        return vD;
      }
    });
    function vD(e) {
      if (typeof e != "string") throw new TypeError("Expected a string");
      return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }
    var CD = mt({
        "node_modules/escape-string-regexp/index.js": function node_modulesEscapeStringRegexpIndexJs() {
          re();
        }
      }),
      Fa = Z({
        "node_modules/semver/internal/debug.js": function node_modulesSemverInternalDebugJs(e, n) {
          re();
          var t = _typeof(Tt) == "object" && Tt.env && Tt.env.NODE_DEBUG && /\bsemver\b/i.test(Tt.env.NODE_DEBUG) ? function () {
            var _console;
            for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++) {
              a[r] = arguments[r];
            }
            return (_console = console).error.apply(_console, ["SEMVER"].concat(a));
          } : function () {};
          n.exports = t;
        }
      }),
      Aa = Z({
        "node_modules/semver/internal/constants.js": function node_modulesSemverInternalConstantsJs(e, n) {
          re();
          var t = "2.0.0",
            s = 256,
            a = Number.MAX_SAFE_INTEGER || 9007199254740991,
            r = 16;
          n.exports = {
            SEMVER_SPEC_VERSION: t,
            MAX_LENGTH: s,
            MAX_SAFE_INTEGER: a,
            MAX_SAFE_COMPONENT_LENGTH: r
          };
        }
      }),
      ED = Z({
        "node_modules/semver/internal/re.js": function node_modulesSemverInternalReJs(e, n) {
          re();
          var _Aa = Aa(),
            t = _Aa.MAX_SAFE_COMPONENT_LENGTH,
            s = Fa();
          e = n.exports = {};
          var a = e.re = [],
            r = e.src = [],
            u = e.t = {},
            i = 0,
            o = function o(c, v, m) {
              var d = i++;
              s(c, d, v), u[c] = d, r[d] = v, a[d] = new RegExp(v, m ? "g" : void 0);
            };
          o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), o("FULL", "^".concat(r[u.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), o("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", r[u.COERCE], !0), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), !0), e.tildeTrimReplace = "$1~", o("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), !0), e.caretTrimReplace = "$1^", o("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), !0), e.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        }
      }),
      FD = Z({
        "node_modules/semver/internal/parse-options.js": function node_modulesSemverInternalParseOptionsJs(e, n) {
          re();
          var t = ["includePrerelease", "loose", "rtl"],
            s = function s(a) {
              return a ? _typeof(a) != "object" ? {
                loose: !0
              } : t.filter(function (r) {
                return a[r];
              }).reduce(function (r, u) {
                return r[u] = !0, r;
              }, {}) : {};
            };
          n.exports = s;
        }
      }),
      AD = Z({
        "node_modules/semver/internal/identifiers.js": function node_modulesSemverInternalIdentifiersJs(e, n) {
          re();
          var t = /^[0-9]+$/,
            s = function s(r, u) {
              var i = t.test(r),
                o = t.test(u);
              return i && o && (r = +r, u = +u), r === u ? 0 : i && !o ? -1 : o && !i ? 1 : r < u ? -1 : 1;
            },
            a = function a(r, u) {
              return s(u, r);
            };
          n.exports = {
            compareIdentifiers: s,
            rcompareIdentifiers: a
          };
        }
      }),
      SD = Z({
        "node_modules/semver/classes/semver.js": function node_modulesSemverClassesSemverJs(e, n) {
          re();
          var t = Fa(),
            _Aa2 = Aa(),
            s = _Aa2.MAX_LENGTH,
            a = _Aa2.MAX_SAFE_INTEGER,
            _ED = ED(),
            r = _ED.re,
            u = _ED.t,
            i = FD(),
            _AD = AD(),
            o = _AD.compareIdentifiers,
            c = /*#__PURE__*/function () {
              function c(v, m) {
                _classCallCheck(this, c);
                if (m = i(m), v instanceof c) {
                  if (v.loose === !!m.loose && v.includePrerelease === !!m.includePrerelease) return v;
                  v = v.version;
                } else if (typeof v != "string") throw new TypeError("Invalid Version: ".concat(v));
                if (v.length > s) throw new TypeError("version is longer than ".concat(s, " characters"));
                t("SemVer", v, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;
                var d = v.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);
                if (!d) throw new TypeError("Invalid Version: ".concat(v));
                if (this.raw = v, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
                if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
                if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
                d[4] ? this.prerelease = d[4].split(".").map(function (p) {
                  if (/^[0-9]+$/.test(p)) {
                    var f = +p;
                    if (f >= 0 && f < a) return f;
                  }
                  return p;
                }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
              }
              _createClass(c, [{
                key: "format",
                value: function format() {
                  return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
                }
              }, {
                key: "toString",
                value: function toString() {
                  return this.version;
                }
              }, {
                key: "compare",
                value: function compare(v) {
                  if (t("SemVer.compare", this.version, this.options, v), !(v instanceof c)) {
                    if (typeof v == "string" && v === this.version) return 0;
                    v = new c(v, this.options);
                  }
                  return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);
                }
              }, {
                key: "compareMain",
                value: function compareMain(v) {
                  return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);
                }
              }, {
                key: "comparePre",
                value: function comparePre(v) {
                  if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length) return -1;
                  if (!this.prerelease.length && v.prerelease.length) return 1;
                  if (!this.prerelease.length && !v.prerelease.length) return 0;
                  var m = 0;
                  do {
                    var d = this.prerelease[m],
                      p = v.prerelease[m];
                    if (t("prerelease compare", m, d, p), d === void 0 && p === void 0) return 0;
                    if (p === void 0) return 1;
                    if (d === void 0) return -1;
                    if (d === p) continue;
                    return o(d, p);
                  } while (++m);
                }
              }, {
                key: "compareBuild",
                value: function compareBuild(v) {
                  v instanceof c || (v = new c(v, this.options));
                  var m = 0;
                  do {
                    var d = this.build[m],
                      p = v.build[m];
                    if (t("prerelease compare", m, d, p), d === void 0 && p === void 0) return 0;
                    if (p === void 0) return 1;
                    if (d === void 0) return -1;
                    if (d === p) continue;
                    return o(d, p);
                  } while (++m);
                }
              }, {
                key: "inc",
                value: function inc(v, m) {
                  switch (v) {
                    case "premajor":
                      this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m);
                      break;
                    case "preminor":
                      this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m);
                      break;
                    case "prepatch":
                      this.prerelease.length = 0, this.inc("patch", m), this.inc("pre", m);
                      break;
                    case "prerelease":
                      this.prerelease.length === 0 && this.inc("patch", m), this.inc("pre", m);
                      break;
                    case "major":
                      (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                      break;
                    case "minor":
                      (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                      break;
                    case "patch":
                      this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                      break;
                    case "pre":
                      if (this.prerelease.length === 0) this.prerelease = [0];else {
                        var d = this.prerelease.length;
                        for (; --d >= 0;) {
                          typeof this.prerelease[d] == "number" && (this.prerelease[d]++, d = -2);
                        }
                        d === -1 && this.prerelease.push(0);
                      }
                      m && (o(this.prerelease[0], m) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m, 0]) : this.prerelease = [m, 0]);
                      break;
                    default:
                      throw new Error("invalid increment argument: ".concat(v));
                  }
                  return this.format(), this.raw = this.version, this;
                }
              }]);
              return c;
            }();
          n.exports = c;
        }
      }),
      qn = Z({
        "node_modules/semver/functions/compare.js": function node_modulesSemverFunctionsCompareJs(e, n) {
          re();
          var t = SD(),
            s = function s(a, r, u) {
              return new t(a, u).compare(new t(r, u));
            };
          n.exports = s;
        }
      }),
      xD = Z({
        "node_modules/semver/functions/lt.js": function node_modulesSemverFunctionsLtJs(e, n) {
          re();
          var t = qn(),
            s = function s(a, r, u) {
              return t(a, r, u) < 0;
            };
          n.exports = s;
        }
      }),
      bD = Z({
        "node_modules/semver/functions/gte.js": function node_modulesSemverFunctionsGteJs(e, n) {
          re();
          var t = qn(),
            s = function s(a, r, u) {
              return t(a, r, u) >= 0;
            };
          n.exports = s;
        }
      }),
      TD = Z({
        "src/utils/arrayify.js": function srcUtilsArrayifyJs(e, n) {
          "use strict";

          re(), n.exports = function (t, s) {
            return Object.entries(t).map(function (a) {
              var _a2 = _slicedToArray(a, 2),
                r = _a2[0],
                u = _a2[1];
              return Object.assign(_defineProperty({}, s, r), u);
            });
          };
        }
      }),
      BD = Z({
        "node_modules/outdent/lib/index.js": function node_modulesOutdentLibIndexJs(e, n) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.outdent = void 0;
          function t() {
            for (var A = [], S = 0; S < arguments.length; S++) {
              A[S] = arguments[S];
            }
          }
          function s() {
            return (typeof WeakMap === "undefined" ? "undefined" : _typeof(WeakMap)) < "u" ? new WeakMap() : a();
          }
          function a() {
            return {
              add: t,
              delete: t,
              get: t,
              set: t,
              has: function has(A) {
                return !1;
              }
            };
          }
          var r = Object.prototype.hasOwnProperty,
            u = function u(A, S) {
              return r.call(A, S);
            };
          function i(A, S) {
            for (var B in S) {
              u(S, B) && (A[B] = S[B]);
            }
            return A;
          }
          var o = /^[ \t]*(?:\r\n|\r|\n)/,
            c = /(?:\r\n|\r|\n)[ \t]*$/,
            v = /^(?:[\r\n]|$)/,
            m = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,
            d = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p(A, S, B) {
            var I = 0,
              k = A[0].match(m);
            k && (I = k[1].length);
            var P = "(\\r\\n|\\r|\\n).{0," + I + "}",
              C = new RegExp(P, "g");
            S && (A = A.slice(1));
            var D = B.newline,
              g = B.trimLeadingNewline,
              F = B.trimTrailingNewline,
              l = typeof D == "string",
              E = A.length,
              y = A.map(function (N, x) {
                return N = N.replace(C, "$1"), x === 0 && g && (N = N.replace(o, "")), x === E - 1 && F && (N = N.replace(c, "")), l && (N = N.replace(/\r\n|\n|\r/g, function (b) {
                  return D;
                })), N;
              });
            return y;
          }
          function f(A, S) {
            for (var B = "", I = 0, k = A.length; I < k; I++) {
              B += A[I], I < k - 1 && (B += S[I]);
            }
            return B;
          }
          function h(A) {
            return u(A, "raw") && u(A, "length");
          }
          function w(A) {
            var S = s(),
              B = s();
            function I(P) {
              for (var C = [], D = 1; D < arguments.length; D++) {
                C[D - 1] = arguments[D];
              }
              if (h(P)) {
                var g = P,
                  F = (C[0] === I || C[0] === T) && d.test(g[0]) && v.test(g[1]),
                  l = F ? B : S,
                  E = l.get(g);
                if (E || (E = p(g, F, A), l.set(g, E)), C.length === 0) return E[0];
                var y = f(E, F ? C.slice(1) : C);
                return y;
              } else return w(i(i({}, A), P || {}));
            }
            var k = i(I, {
              string: function string(P) {
                return p([P], !1, A)[0];
              }
            });
            return k;
          }
          var T = w({
            trimLeadingNewline: !0,
            trimTrailingNewline: !0
          });
          if (e.outdent = T, e.default = T, _typeof(n) < "u") try {
            n.exports = T, Object.defineProperty(T, "__esModule", {
              value: !0
            }), T.default = T, T.outdent = T;
          } catch (_unused9) {}
        }
      }),
      ND = Z({
        "src/main/core-options.js": function srcMainCoreOptionsJs(e, n) {
          "use strict";

          re();
          var _BD = BD(),
            t = _BD.outdent,
            s = "Config",
            a = "Editor",
            r = "Format",
            u = "Other",
            i = "Output",
            o = "Global",
            c = "Special",
            v = {
              cursorOffset: {
                since: "1.4.0",
                category: c,
                type: "int",
                default: -1,
                range: {
                  start: -1,
                  end: Number.POSITIVE_INFINITY,
                  step: 1
                },
                description: t(sa || (sa = Pt(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))),
                cliCategory: a
              },
              endOfLine: {
                since: "1.15.0",
                category: o,
                type: "choice",
                default: [{
                  since: "1.15.0",
                  value: "auto"
                }, {
                  since: "2.0.0",
                  value: "lf"
                }],
                description: "Which end of line characters to apply.",
                choices: [{
                  value: "lf",
                  description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
                }, {
                  value: "crlf",
                  description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
                }, {
                  value: "cr",
                  description: "Carriage Return character only (\\r), used very rarely"
                }, {
                  value: "auto",
                  description: t(ia || (ia = Pt(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "])))
                }]
              },
              filepath: {
                since: "1.4.0",
                category: c,
                type: "path",
                description: "Specify the input filepath. This will be used to do parser inference.",
                cliName: "stdin-filepath",
                cliCategory: u,
                cliDescription: "Path to the file to pretend that stdin comes from."
              },
              insertPragma: {
                since: "1.8.0",
                category: c,
                type: "boolean",
                default: !1,
                description: "Insert @format pragma into file's first docblock comment.",
                cliCategory: u
              },
              parser: {
                since: "0.0.10",
                category: o,
                type: "choice",
                default: [{
                  since: "0.0.10",
                  value: "babylon"
                }, {
                  since: "1.13.0",
                  value: void 0
                }],
                description: "Which parser to use.",
                exception: function exception(m) {
                  return typeof m == "string" || typeof m == "function";
                },
                choices: [{
                  value: "flow",
                  description: "Flow"
                }, {
                  value: "babel",
                  since: "1.16.0",
                  description: "JavaScript"
                }, {
                  value: "babel-flow",
                  since: "1.16.0",
                  description: "Flow"
                }, {
                  value: "babel-ts",
                  since: "2.0.0",
                  description: "TypeScript"
                }, {
                  value: "typescript",
                  since: "1.4.0",
                  description: "TypeScript"
                }, {
                  value: "acorn",
                  since: "2.6.0",
                  description: "JavaScript"
                }, {
                  value: "espree",
                  since: "2.2.0",
                  description: "JavaScript"
                }, {
                  value: "meriyah",
                  since: "2.2.0",
                  description: "JavaScript"
                }, {
                  value: "css",
                  since: "1.7.1",
                  description: "CSS"
                }, {
                  value: "less",
                  since: "1.7.1",
                  description: "Less"
                }, {
                  value: "scss",
                  since: "1.7.1",
                  description: "SCSS"
                }, {
                  value: "json",
                  since: "1.5.0",
                  description: "JSON"
                }, {
                  value: "json5",
                  since: "1.13.0",
                  description: "JSON5"
                }, {
                  value: "json-stringify",
                  since: "1.13.0",
                  description: "JSON.stringify"
                }, {
                  value: "graphql",
                  since: "1.5.0",
                  description: "GraphQL"
                }, {
                  value: "markdown",
                  since: "1.8.0",
                  description: "Markdown"
                }, {
                  value: "mdx",
                  since: "1.15.0",
                  description: "MDX"
                }, {
                  value: "vue",
                  since: "1.10.0",
                  description: "Vue"
                }, {
                  value: "yaml",
                  since: "1.14.0",
                  description: "YAML"
                }, {
                  value: "glimmer",
                  since: "2.3.0",
                  description: "Ember / Handlebars"
                }, {
                  value: "html",
                  since: "1.15.0",
                  description: "HTML"
                }, {
                  value: "angular",
                  since: "1.15.0",
                  description: "Angular"
                }, {
                  value: "lwc",
                  since: "1.17.0",
                  description: "Lightning Web Components"
                }]
              },
              plugins: {
                since: "1.10.0",
                type: "path",
                array: !0,
                default: [{
                  value: []
                }],
                category: o,
                description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
                exception: function exception(m) {
                  return typeof m == "string" || _typeof(m) == "object";
                },
                cliName: "plugin",
                cliCategory: s
              },
              pluginSearchDirs: {
                since: "1.13.0",
                type: "path",
                array: !0,
                default: [{
                  value: []
                }],
                category: o,
                description: t(aa || (aa = Pt(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))),
                exception: function exception(m) {
                  return typeof m == "string" || _typeof(m) == "object";
                },
                cliName: "plugin-search-dir",
                cliCategory: s
              },
              printWidth: {
                since: "0.0.0",
                category: o,
                type: "int",
                default: 80,
                description: "The line length where Prettier will try wrap.",
                range: {
                  start: 0,
                  end: Number.POSITIVE_INFINITY,
                  step: 1
                }
              },
              rangeEnd: {
                since: "1.4.0",
                category: c,
                type: "int",
                default: Number.POSITIVE_INFINITY,
                range: {
                  start: 0,
                  end: Number.POSITIVE_INFINITY,
                  step: 1
                },
                description: t(oa || (oa = Pt(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))),
                cliCategory: a
              },
              rangeStart: {
                since: "1.4.0",
                category: c,
                type: "int",
                default: 0,
                range: {
                  start: 0,
                  end: Number.POSITIVE_INFINITY,
                  step: 1
                },
                description: t(la || (la = Pt(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))),
                cliCategory: a
              },
              requirePragma: {
                since: "1.7.0",
                category: c,
                type: "boolean",
                default: !1,
                description: t(ca || (ca = Pt(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))),
                cliCategory: u
              },
              tabWidth: {
                type: "int",
                category: o,
                default: 2,
                description: "Number of spaces per indentation level.",
                range: {
                  start: 0,
                  end: Number.POSITIVE_INFINITY,
                  step: 1
                }
              },
              useTabs: {
                since: "1.0.0",
                category: o,
                type: "boolean",
                default: !1,
                description: "Indent with tabs instead of spaces."
              },
              embeddedLanguageFormatting: {
                since: "2.1.0",
                category: o,
                type: "choice",
                default: [{
                  since: "2.1.0",
                  value: "auto"
                }],
                description: "Control how Prettier formats quoted code embedded in the file.",
                choices: [{
                  value: "auto",
                  description: "Format embedded code if Prettier can automatically identify it."
                }, {
                  value: "off",
                  description: "Never automatically format embedded code."
                }]
              }
            };
          n.exports = {
            CATEGORY_CONFIG: s,
            CATEGORY_EDITOR: a,
            CATEGORY_FORMAT: r,
            CATEGORY_OTHER: u,
            CATEGORY_OUTPUT: i,
            CATEGORY_GLOBAL: o,
            CATEGORY_SPECIAL: c,
            options: v
          };
        }
      }),
      Mn = Z({
        "src/main/support.js": function srcMainSupportJs(e, n) {
          "use strict";

          re();
          var t = {
              compare: qn(),
              lt: xD(),
              gte: bD()
            },
            s = TD(),
            a = ya().version,
            r = ND().options;
          function u() {
            var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
              _ref4$plugins = _ref4.plugins,
              o = _ref4$plugins === void 0 ? [] : _ref4$plugins,
              _ref4$showUnreleased = _ref4.showUnreleased,
              c = _ref4$showUnreleased === void 0 ? !1 : _ref4$showUnreleased,
              _ref4$showDeprecated = _ref4.showDeprecated,
              v = _ref4$showDeprecated === void 0 ? !1 : _ref4$showDeprecated,
              _ref4$showInternal = _ref4.showInternal,
              m = _ref4$showInternal === void 0 ? !1 : _ref4$showInternal,
              d = a.split("-", 1)[0],
              p = o.flatMap(function (A) {
                return A.languages || [];
              }).filter(h),
              f = s(Object.assign.apply(Object, [{}].concat(_toConsumableArray(o.map(function (A) {
                var S = A.options;
                return S;
              })), [r])), "name").filter(function (A) {
                return h(A) && w(A);
              }).sort(function (A, S) {
                return A.name === S.name ? 0 : A.name < S.name ? -1 : 1;
              }).map(T).map(function (A) {
                A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort(function (B, I) {
                  return t.compare(I.since, B.since);
                })[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter(function (B) {
                  return h(B) && w(B);
                }), A.name === "parser" && i(A, p, o));
                var S = Object.fromEntries(o.filter(function (B) {
                  return B.defaultOptions && B.defaultOptions[A.name] !== void 0;
                }).map(function (B) {
                  return [B.name, B.defaultOptions[A.name]];
                }));
                return Object.assign(Object.assign({}, A), {}, {
                  pluginDefaults: S
                });
              });
            return {
              languages: p,
              options: f
            };
            function h(A) {
              return c || !("since" in A) || A.since && t.gte(d, A.since);
            }
            function w(A) {
              return v || !("deprecated" in A) || A.deprecated && t.lt(d, A.deprecated);
            }
            function T(A) {
              if (m) return A;
              var S = A.cliName,
                B = A.cliCategory,
                I = A.cliDescription;
              return kn(A, Yf);
            }
          }
          function i(o, c, v) {
            var m = new Set(o.choices.map(function (d) {
              return d.value;
            }));
            var _iterator5 = _createForOfIteratorHelper(c),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var d = _step5.value;
                if (d.parsers) {
                  var _iterator6 = _createForOfIteratorHelper(d.parsers),
                    _step6;
                  try {
                    var _loop2 = function _loop2() {
                      var p = _step6.value;
                      if (!m.has(p)) {
                        m.add(p);
                        var f = v.find(function (w) {
                            return w.parsers && w.parsers[p];
                          }),
                          _h2 = d.name;
                        f && f.name && (_h2 += " (plugin: ".concat(f.name, ")")), o.choices.push({
                          value: p,
                          description: _h2
                        });
                      }
                    };
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                      _loop2();
                    }
                  } catch (err) {
                    _iterator6.e(err);
                  } finally {
                    _iterator6.f();
                  }
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          n.exports = {
            getSupportInfo: u
          };
        }
      }),
      Rn = Z({
        "src/utils/is-non-empty-array.js": function srcUtilsIsNonEmptyArrayJs(e, n) {
          "use strict";

          re();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          n.exports = t;
        }
      }),
      Nr = Z({
        "src/utils/text/skip.js": function srcUtilsTextSkipJs(e, n) {
          "use strict";

          re();
          function t(i) {
            return function (o, c, v) {
              var m = v && v.backwards;
              if (c === !1) return !1;
              var d = o.length,
                p = c;
              for (; p >= 0 && p < d;) {
                var f = o.charAt(p);
                if (i instanceof RegExp) {
                  if (!i.test(f)) return p;
                } else if (!i.includes(f)) return p;
                m ? p-- : p++;
              }
              return p === -1 || p === d ? p : !1;
            };
          }
          var s = t(/\s/),
            a = t(" 	"),
            r = t(",; 	"),
            u = t(/[^\n\r]/);
          n.exports = {
            skipWhitespace: s,
            skipSpaces: a,
            skipToLineEnd: r,
            skipEverythingButNewLine: u
          };
        }
      }),
      Sa = Z({
        "src/utils/text/skip-inline-comment.js": function srcUtilsTextSkipInlineCommentJs(e, n) {
          "use strict";

          re();
          function t(s, a) {
            if (a === !1) return !1;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (var r = a + 2; r < s.length; ++r) {
                if (s.charAt(r) === "*" && s.charAt(r + 1) === "/") return r + 2;
              }
            }
            return a;
          }
          n.exports = t;
        }
      }),
      xa = Z({
        "src/utils/text/skip-trailing-comment.js": function srcUtilsTextSkipTrailingCommentJs(e, n) {
          "use strict";

          re();
          var _Nr = Nr(),
            t = _Nr.skipEverythingButNewLine;
          function s(a, r) {
            return r === !1 ? !1 : a.charAt(r) === "/" && a.charAt(r + 1) === "/" ? t(a, r) : r;
          }
          n.exports = s;
        }
      }),
      ba = Z({
        "src/utils/text/skip-newline.js": function srcUtilsTextSkipNewlineJs(e, n) {
          "use strict";

          re();
          function t(s, a, r) {
            var u = r && r.backwards;
            if (a === !1) return !1;
            var i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === "\n") return a - 2;
              if (i === "\n" || i === "\r" || i === "\u2028" || i === "\u2029") return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === "\n") return a + 2;
              if (i === "\n" || i === "\r" || i === "\u2028" || i === "\u2029") return a + 1;
            }
            return a;
          }
          n.exports = t;
        }
      }),
      wD = Z({
        "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js": function srcUtilsTextGetNextNonSpaceNonCommentCharacterIndexWithStartIndexJs(e, n) {
          "use strict";

          re();
          var t = Sa(),
            s = ba(),
            a = xa(),
            _Nr2 = Nr(),
            r = _Nr2.skipSpaces;
          function u(i, o) {
            var c = null,
              v = o;
            for (; v !== c;) {
              c = v, v = r(i, v), v = t(i, v), v = a(i, v), v = s(i, v);
            }
            return v;
          }
          n.exports = u;
        }
      }),
      Ue = Z({
        "src/common/util.js": function srcCommonUtilJs(e, n) {
          "use strict";

          re();
          var _ref5 = (CD(), lt(Ea)),
            t = _ref5.default,
            s = it(),
            _Mn = Mn(),
            a = _Mn.getSupportInfo,
            r = Rn(),
            u = Ca(),
            _Nr3 = Nr(),
            i = _Nr3.skipWhitespace,
            o = _Nr3.skipSpaces,
            c = _Nr3.skipToLineEnd,
            v = _Nr3.skipEverythingButNewLine,
            m = Sa(),
            d = xa(),
            p = ba(),
            f = wD(),
            h = function h(H) {
              return H[H.length - 2];
            };
          function w(H) {
            return function (R, Q, ee) {
              var te = ee && ee.backwards;
              if (Q === !1) return !1;
              var oe = R.length,
                W = Q;
              for (; W >= 0 && W < oe;) {
                var X = R.charAt(W);
                if (H instanceof RegExp) {
                  if (!H.test(X)) return W;
                } else if (!H.includes(X)) return W;
                te ? W-- : W++;
              }
              return W === -1 || W === oe ? W : !1;
            };
          }
          function T(H, R) {
            var Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              ee = o(H, Q.backwards ? R - 1 : R, Q),
              te = p(H, ee, Q);
            return ee !== te;
          }
          function A(H, R, Q) {
            for (var ee = R; ee < Q; ++ee) {
              if (H.charAt(ee) === "\n") return !0;
            }
            return !1;
          }
          function S(H, R, Q) {
            var ee = Q(R) - 1;
            ee = o(H, ee, {
              backwards: !0
            }), ee = p(H, ee, {
              backwards: !0
            }), ee = o(H, ee, {
              backwards: !0
            });
            var te = p(H, ee, {
              backwards: !0
            });
            return ee !== te;
          }
          function B(H, R) {
            var Q = null,
              ee = R;
            for (; ee !== Q;) {
              Q = ee, ee = c(H, ee), ee = m(H, ee), ee = o(H, ee);
            }
            return ee = d(H, ee), ee = p(H, ee), ee !== !1 && T(H, ee);
          }
          function I(H, R, Q) {
            return B(H, Q(R));
          }
          function k(H, R, Q) {
            return f(H, Q(R));
          }
          function P(H, R, Q) {
            return H.charAt(k(H, R, Q));
          }
          function C(H, R) {
            var Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return o(H, Q.backwards ? R - 1 : R, Q) !== R;
          }
          function D(H, R) {
            var Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
              ee = 0;
            for (var te = Q; te < H.length; ++te) {
              H[te] === "	" ? ee = ee + R - ee % R : ee++;
            }
            return ee;
          }
          function g(H, R) {
            var Q = H.lastIndexOf("\n");
            return Q === -1 ? 0 : D(H.slice(Q + 1).match(/^[\t ]*/)[0], R);
          }
          function F(H, R) {
            var Q = {
                quote: '"',
                regex: /"/g,
                escaped: "&quot;"
              },
              ee = {
                quote: "'",
                regex: /'/g,
                escaped: "&apos;"
              },
              te = R === "'" ? ee : Q,
              oe = te === ee ? Q : ee,
              W = te;
            if (H.includes(te.quote) || H.includes(oe.quote)) {
              var X = (H.match(te.regex) || []).length,
                ue = (H.match(oe.regex) || []).length;
              W = X > ue ? oe : te;
            }
            return W;
          }
          function l(H, R) {
            var Q = H.slice(1, -1),
              ee = R.parser === "json" || R.parser === "json5" && R.quoteProps === "preserve" && !R.singleQuote ? '"' : R.__isInHtmlAttribute ? "'" : F(Q, R.singleQuote ? "'" : '"').quote;
            return E(Q, ee, !(R.parser === "css" || R.parser === "less" || R.parser === "scss" || R.__embeddedInHtml));
          }
          function E(H, R, Q) {
            var ee = R === '"' ? "'" : '"',
              te = /\\([\s\S])|(["'])/g,
              oe = H.replace(te, function (W, X, ue) {
                return X === ee ? X : ue === R ? "\\" + ue : ue || (Q && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X);
              });
            return R + oe + R;
          }
          function y(H) {
            return H.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function N(H, R) {
            var Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
            return Q === null ? 0 : Q.reduce(function (ee, te) {
              return Math.max(ee, te.length / R.length);
            }, 0);
          }
          function x(H, R) {
            var Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
            if (Q === null) return 0;
            var ee = new Map(),
              te = 0;
            var _iterator7 = _createForOfIteratorHelper(Q),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _oe = _step7.value;
                var W = _oe.length / R.length;
                ee.set(W, !0), W > te && (te = W);
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            for (var oe = 1; oe < te; oe++) {
              if (!ee.get(oe)) return oe;
            }
            return te + 1;
          }
          function b(H, R) {
            (H.comments || (H.comments = [])).push(R), R.printed = !1, R.nodeDescription = Y(H);
          }
          function L(H, R) {
            R.leading = !0, R.trailing = !1, b(H, R);
          }
          function M(H, R, Q) {
            R.leading = !1, R.trailing = !1, Q && (R.marker = Q), b(H, R);
          }
          function j(H, R) {
            R.leading = !1, R.trailing = !0, b(H, R);
          }
          function $(H, R) {
            var _a3 = a({
                plugins: R.plugins
              }),
              Q = _a3.languages,
              ee = Q.find(function (te) {
                var oe = te.name;
                return oe.toLowerCase() === H;
              }) || Q.find(function (te) {
                var oe = te.aliases;
                return Array.isArray(oe) && oe.includes(H);
              }) || Q.find(function (te) {
                var oe = te.extensions;
                return Array.isArray(oe) && oe.includes(".".concat(H));
              });
            return ee && ee.parsers[0];
          }
          function V(H) {
            return H && H.type === "front-matter";
          }
          function q(H) {
            var R = new WeakMap();
            return function (Q) {
              return R.has(Q) || R.set(Q, Symbol(H)), R.get(Q);
            };
          }
          function Y(H) {
            var R = H.type || H.kind || "(unknown type)",
              Q = String(H.name || H.id && (_typeof(H.id) == "object" ? H.id.name : H.id) || H.key && (_typeof(H.key) == "object" ? H.key.name : H.key) || H.value && (_typeof(H.value) == "object" ? "" : String(H.value)) || H.operator || "");
            return Q.length > 20 && (Q = Q.slice(0, 19) + "\u2026"), R + (Q ? " " + Q : "");
          }
          n.exports = {
            inferParserByLanguage: $,
            getStringWidth: u,
            getMaxContinuousCount: N,
            getMinNotPresentContinuousCount: x,
            getPenultimate: h,
            getLast: s,
            getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,
            getNextNonSpaceNonCommentCharacterIndex: k,
            getNextNonSpaceNonCommentCharacter: P,
            skip: w,
            skipWhitespace: i,
            skipSpaces: o,
            skipToLineEnd: c,
            skipEverythingButNewLine: v,
            skipInlineComment: m,
            skipTrailingComment: d,
            skipNewline: p,
            isNextLineEmptyAfterIndex: B,
            isNextLineEmpty: I,
            isPreviousLineEmpty: S,
            hasNewline: T,
            hasNewlineInRange: A,
            hasSpaces: C,
            getAlignmentSize: D,
            getIndentSize: g,
            getPreferredQuote: F,
            printString: l,
            printNumber: y,
            makeString: E,
            addLeadingComment: L,
            addDanglingComment: M,
            addTrailingComment: j,
            isFrontMatterNode: V,
            isNonEmptyArray: r,
            createGroupIdMapper: q
          };
        }
      }),
      Ta = {};
    Ut(Ta, {
      basename: function basename() {
        return Pa;
      },
      default: function _default() {
        return Ia;
      },
      delimiter: function delimiter() {
        return Bn;
      },
      dirname: function dirname() {
        return _a;
      },
      extname: function extname() {
        return ka;
      },
      isAbsolute: function isAbsolute() {
        return Wn;
      },
      join: function join() {
        return Na;
      },
      normalize: function normalize() {
        return Vn;
      },
      relative: function relative() {
        return wa;
      },
      resolve: function resolve() {
        return Tr;
      },
      sep: function sep() {
        return Tn;
      }
    });
    function Ba(e, n) {
      for (var t = 0, s = e.length - 1; s >= 0; s--) {
        var a = e[s];
        a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
      }
      if (n) for (; t--; t) {
        e.unshift("..");
      }
      return e;
    }
    function Tr() {
      for (var e = "", n = !1, t = arguments.length - 1; t >= -1 && !n; t--) {
        var s = t >= 0 ? arguments[t] : "/";
        if (typeof s != "string") throw new TypeError("Arguments to path.resolve must be strings");
        if (!s) continue;
        e = s + "/" + e, n = s.charAt(0) === "/";
      }
      return e = Ba($n(e.split("/"), function (a) {
        return !!a;
      }), !n).join("/"), (n ? "/" : "") + e || ".";
    }
    function Vn(e) {
      var n = Wn(e),
        t = La(e, -1) === "/";
      return e = Ba($n(e.split("/"), function (s) {
        return !!s;
      }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
    }
    function Wn(e) {
      return e.charAt(0) === "/";
    }
    function Na() {
      var e = Array.prototype.slice.call(arguments, 0);
      return Vn($n(e, function (n, t) {
        if (typeof n != "string") throw new TypeError("Arguments to path.join must be strings");
        return n;
      }).join("/"));
    }
    function wa(e, n) {
      e = Tr(e).substr(1), n = Tr(n).substr(1);
      function t(c) {
        for (var v = 0; v < c.length && c[v] === ""; v++) {
          ;
        }
        for (var m = c.length - 1; m >= 0 && c[m] === ""; m--) {
          ;
        }
        return v > m ? [] : c.slice(v, m - v + 1);
      }
      for (var s = t(e.split("/")), a = t(n.split("/")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++) {
        if (s[i] !== a[i]) {
          u = i;
          break;
        }
      }
      for (var o = [], i = u; i < s.length; i++) {
        o.push("..");
      }
      return o = o.concat(a.slice(u)), o.join("/");
    }
    function _a(e) {
      var n = wr(e),
        t = n[0],
        s = n[1];
      return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
    }
    function Pa(e, n) {
      var t = wr(e)[2];
      return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
    }
    function ka(e) {
      return wr(e)[3];
    }
    function $n(e, n) {
      if (e.filter) return e.filter(n);
      for (var t = [], s = 0; s < e.length; s++) {
        n(e[s], s, e) && t.push(e[s]);
      }
      return t;
    }
    var Da,
      wr,
      Tn,
      Bn,
      Ia,
      La,
      _D = mt({
        "node-modules-polyfills:path": function nodeModulesPolyfillsPath() {
          re(), Da = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, wr = function wr(e) {
            return Da.exec(e).slice(1);
          }, Tn = "/", Bn = ":", Ia = {
            extname: ka,
            basename: Pa,
            dirname: _a,
            sep: Tn,
            delimiter: Bn,
            relative: wa,
            join: Na,
            isAbsolute: Wn,
            normalize: Vn,
            resolve: Tr
          }, La = "ab".substr(-1) === "b" ? function (e, n, t) {
            return e.substr(n, t);
          } : function (e, n, t) {
            return n < 0 && (n = e.length + n), e.substr(n, t);
          };
        }
      }),
      PD = Z({
        "node-modules-polyfills-commonjs:path": function nodeModulesPolyfillsCommonjsPath(e, n) {
          re();
          var t = (_D(), lt(Ta));
          if (t && t.default) {
            n.exports = t.default;
            for (var s in t) {
              n.exports[s] = t[s];
            }
          } else t && (n.exports = t);
        }
      }),
      zt = Z({
        "src/common/errors.js": function srcCommonErrorsJs(e, n) {
          "use strict";

          re();
          var t = /*#__PURE__*/function (_Error) {
              _inherits(t, _Error);
              var _super = _createSuper(t);
              function t() {
                _classCallCheck(this, t);
                return _super.apply(this, arguments);
              }
              return _createClass(t);
            }( /*#__PURE__*/_wrapNativeSuper(Error)),
            s = /*#__PURE__*/function (_Error2) {
              _inherits(s, _Error2);
              var _super2 = _createSuper(s);
              function s() {
                _classCallCheck(this, s);
                return _super2.apply(this, arguments);
              }
              return _createClass(s);
            }( /*#__PURE__*/_wrapNativeSuper(Error)),
            a = /*#__PURE__*/function (_Error3) {
              _inherits(a, _Error3);
              var _super3 = _createSuper(a);
              function a() {
                _classCallCheck(this, a);
                return _super3.apply(this, arguments);
              }
              return _createClass(a);
            }( /*#__PURE__*/_wrapNativeSuper(Error)),
            r = /*#__PURE__*/function (_Error4) {
              _inherits(r, _Error4);
              var _super4 = _createSuper(r);
              function r() {
                _classCallCheck(this, r);
                return _super4.apply(this, arguments);
              }
              return _createClass(r);
            }( /*#__PURE__*/_wrapNativeSuper(Error));
          n.exports = {
            ConfigError: t,
            DebugError: s,
            UndefinedParserError: a,
            ArgExpansionBailout: r
          };
        }
      }),
      dt = {};
    Ut(dt, {
      __assign: function __assign() {
        return _br;
      },
      __asyncDelegator: function __asyncDelegator() {
        return GD;
      },
      __asyncGenerator: function __asyncGenerator() {
        return HD;
      },
      __asyncValues: function __asyncValues() {
        return JD;
      },
      __await: function __await() {
        return Jt;
      },
      __awaiter: function __awaiter() {
        return qD;
      },
      __classPrivateFieldGet: function __classPrivateFieldGet() {
        return KD;
      },
      __classPrivateFieldSet: function __classPrivateFieldSet() {
        return YD;
      },
      __createBinding: function __createBinding() {
        return RD;
      },
      __decorate: function __decorate() {
        return LD;
      },
      __exportStar: function __exportStar() {
        return VD;
      },
      __extends: function __extends() {
        return kD;
      },
      __generator: function __generator() {
        return MD;
      },
      __importDefault: function __importDefault() {
        return XD;
      },
      __importStar: function __importStar() {
        return zD;
      },
      __makeTemplateObject: function __makeTemplateObject() {
        return UD;
      },
      __metadata: function __metadata() {
        return OD;
      },
      __param: function __param() {
        return jD;
      },
      __read: function __read() {
        return ja;
      },
      __rest: function __rest() {
        return ID;
      },
      __spread: function __spread() {
        return WD;
      },
      __spreadArrays: function __spreadArrays() {
        return $D;
      },
      __values: function __values() {
        return Nn;
      }
    });
    function kD(e, n) {
      _xr(e, n);
      function t() {
        this.constructor = e;
      }
      e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
    }
    function ID(e, n) {
      var t = {};
      for (var s in e) {
        Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
      }
      if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) {
        n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
      }
      return t;
    }
    function LD(e, n, t, s) {
      var a = arguments.length,
        r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s,
        u;
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(e, n, t, s);else for (var i = e.length - 1; i >= 0; i--) {
        (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);
      }
      return a > 3 && r && Object.defineProperty(n, t, r), r;
    }
    function jD(e, n) {
      return function (t, s) {
        n(t, s, e);
      };
    }
    function OD(e, n) {
      if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, n);
    }
    function qD(e, n, t, s) {
      function a(r) {
        return r instanceof t ? r : new t(function (u) {
          u(r);
        });
      }
      return new (t || (t = Promise))(function (r, u) {
        function i(v) {
          try {
            c(s.next(v));
          } catch (m) {
            u(m);
          }
        }
        function o(v) {
          try {
            c(s.throw(v));
          } catch (m) {
            u(m);
          }
        }
        function c(v) {
          v.done ? r(v.value) : a(v.value).then(i, o);
        }
        c((s = s.apply(e, n || [])).next());
      });
    }
    function MD(e, n) {
      var t = {
          label: 0,
          sent: function sent() {
            if (r[0] & 1) throw r[1];
            return r[1];
          },
          trys: [],
          ops: []
        },
        s,
        a,
        r,
        u;
      return u = {
        next: i(0),
        throw: i(1),
        return: i(2)
      }, typeof Symbol == "function" && (u[Symbol.iterator] = function () {
        return this;
      }), u;
      function i(c) {
        return function (v) {
          return o([c, v]);
        };
      }
      function o(c) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; t;) {
          try {
            if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done) return r;
            switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
              case 0:
              case 1:
                r = c;
                break;
              case 4:
                return t.label++, {
                  value: c[1],
                  done: !1
                };
              case 5:
                t.label++, a = c[1], c = [0];
                continue;
              case 7:
                c = t.ops.pop(), t.trys.pop();
                continue;
              default:
                if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                  t = 0;
                  continue;
                }
                if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                  t.label = c[1];
                  break;
                }
                if (c[0] === 6 && t.label < r[1]) {
                  t.label = r[1], r = c;
                  break;
                }
                if (r && t.label < r[2]) {
                  t.label = r[2], t.ops.push(c);
                  break;
                }
                r[2] && t.ops.pop(), t.trys.pop();
                continue;
            }
            c = n.call(e, t);
          } catch (v) {
            c = [6, v], a = 0;
          } finally {
            s = r = 0;
          }
        }
        if (c[0] & 5) throw c[1];
        return {
          value: c[0] ? c[1] : void 0,
          done: !0
        };
      }
    }
    function RD(e, n, t, s) {
      s === void 0 && (s = t), e[s] = n[t];
    }
    function VD(e, n) {
      for (var t in e) {
        t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
      }
    }
    function Nn(e) {
      var n = typeof Symbol == "function" && Symbol.iterator,
        t = n && e[n],
        s = 0;
      if (t) return t.call(e);
      if (e && typeof e.length == "number") return {
        next: function next() {
          return e && s >= e.length && (e = void 0), {
            value: e && e[s++],
            done: !e
          };
        }
      };
      throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function ja(e, n) {
      var t = typeof Symbol == "function" && e[Symbol.iterator];
      if (!t) return e;
      var s = t.call(e),
        a,
        r = [],
        u;
      try {
        for (; (n === void 0 || n-- > 0) && !(a = s.next()).done;) {
          r.push(a.value);
        }
      } catch (i) {
        u = {
          error: i
        };
      } finally {
        try {
          a && !a.done && (t = s.return) && t.call(s);
        } finally {
          if (u) throw u.error;
        }
      }
      return r;
    }
    function WD() {
      for (var e = [], n = 0; n < arguments.length; n++) {
        e = e.concat(ja(arguments[n]));
      }
      return e;
    }
    function $D() {
      for (var e = 0, n = 0, t = arguments.length; n < t; n++) {
        e += arguments[n].length;
      }
      for (var s = Array(e), a = 0, n = 0; n < t; n++) {
        for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++) {
          s[a] = r[u];
        }
      }
      return s;
    }
    function Jt(e) {
      return this instanceof Jt ? (this.v = e, this) : new Jt(e);
    }
    function HD(e, n, t) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var s = t.apply(e, n || []),
        a,
        r = [];
      return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function () {
        return this;
      }, a;
      function u(d) {
        s[d] && (a[d] = function (p) {
          return new Promise(function (f, h) {
            r.push([d, p, f, h]) > 1 || i(d, p);
          });
        });
      }
      function i(d, p) {
        try {
          o(s[d](p));
        } catch (f) {
          m(r[0][3], f);
        }
      }
      function o(d) {
        d.value instanceof Jt ? Promise.resolve(d.value.v).then(c, v) : m(r[0][2], d);
      }
      function c(d) {
        i("next", d);
      }
      function v(d) {
        i("throw", d);
      }
      function m(d, p) {
        d(p), r.shift(), r.length && i(r[0][0], r[0][1]);
      }
    }
    function GD(e) {
      var n, t;
      return n = {}, s("next"), s("throw", function (a) {
        throw a;
      }), s("return"), n[Symbol.iterator] = function () {
        return this;
      }, n;
      function s(a, r) {
        n[a] = e[a] ? function (u) {
          return (t = !t) ? {
            value: Jt(e[a](u)),
            done: a === "return"
          } : r ? r(u) : u;
        } : r;
      }
    }
    function JD(e) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var n = e[Symbol.asyncIterator],
        t;
      return n ? n.call(e) : (e = typeof Nn == "function" ? Nn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function () {
        return this;
      }, t);
      function s(r) {
        t[r] = e[r] && function (u) {
          return new Promise(function (i, o) {
            u = e[r](u), a(i, o, u.done, u.value);
          });
        };
      }
      function a(r, u, i, o) {
        Promise.resolve(o).then(function (c) {
          r({
            value: c,
            done: i
          });
        }, u);
      }
    }
    function UD(e, n) {
      return Object.defineProperty ? Object.defineProperty(e, "raw", {
        value: n
      }) : e.raw = n, e;
    }
    function zD(e) {
      if (e && e.__esModule) return e;
      var n = {};
      if (e != null) for (var t in e) {
        Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
      }
      return n.default = e, n;
    }
    function XD(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }
    function KD(e, n) {
      if (!n.has(e)) throw new TypeError("attempted to get private field on non-instance");
      return n.get(e);
    }
    function YD(e, n, t) {
      if (!n.has(e)) throw new TypeError("attempted to set private field on non-instance");
      return n.set(e, t), t;
    }
    var _xr,
      _br,
      ht = mt({
        "node_modules/tslib/tslib.es6.js": function node_modulesTslibTslibEs6Js() {
          re(), _xr = function xr(e, n) {
            return _xr = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (t, s) {
              t.__proto__ = s;
            } || function (t, s) {
              for (var a in s) {
                s.hasOwnProperty(a) && (t[a] = s[a]);
              }
            }, _xr(e, n);
          }, _br = function br() {
            return _br = Object.assign || function (n) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var r in t) {
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
              }
              return n;
            }, _br.apply(this, arguments);
          };
        }
      }),
      Oa = Z({
        "node_modules/vnopts/lib/descriptors/api.js": function node_modulesVnoptsLibDescriptorsApiJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.apiDescriptor = {
            key: function key(n) {
              return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n);
            },
            value: function value(n) {
              if (n === null || _typeof(n) != "object") return JSON.stringify(n);
              if (Array.isArray(n)) return "[".concat(n.map(function (s) {
                return e.apiDescriptor.value(s);
              }).join(", "), "]");
              var t = Object.keys(n);
              return t.length === 0 ? "{}" : "{ ".concat(t.map(function (s) {
                return "".concat(e.apiDescriptor.key(s), ": ").concat(e.apiDescriptor.value(n[s]));
              }).join(", "), " }");
            },
            pair: function pair(n) {
              var t = n.key,
                s = n.value;
              return e.apiDescriptor.value(_defineProperty({}, t, s));
            }
          };
        }
      }),
      QD = Z({
        "node_modules/vnopts/lib/descriptors/index.js": function node_modulesVnoptsLibDescriptorsIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(Oa(), e);
        }
      }),
      _r = Z({
        "scripts/build/shims/chalk.cjs": function scriptsBuildShimsChalkCjs(e, n) {
          "use strict";

          re();
          var t = function t(s) {
            return s;
          };
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
        }
      }),
      qa = Z({
        "node_modules/vnopts/lib/handlers/deprecated/common.js": function node_modulesVnoptsLibHandlersDeprecatedCommonJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = _r();
          e.commonDeprecatedHandler = function (t, s, a) {
            var r = a.descriptor,
              u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
            return s && u.push("we now treat it as ".concat(n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s)))), u.join("; ") + ".";
          };
        }
      }),
      ZD = Z({
        "node_modules/vnopts/lib/handlers/deprecated/index.js": function node_modulesVnoptsLibHandlersDeprecatedIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(qa(), e);
        }
      }),
      em = Z({
        "node_modules/vnopts/lib/handlers/invalid/common.js": function node_modulesVnoptsLibHandlersInvalidCommonJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = _r();
          e.commonInvalidHandler = function (t, s, a) {
            return ["Invalid ".concat(n.default.red(a.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(a.schemas[t].expected(a)), ","), "but received ".concat(n.default.red(a.descriptor.value(s)), ".")].join(" ");
          };
        }
      }),
      Ma = Z({
        "node_modules/vnopts/lib/handlers/invalid/index.js": function node_modulesVnoptsLibHandlersInvalidIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(em(), e);
        }
      }),
      tm = Z({
        "node_modules/vnopts/node_modules/leven/index.js": function node_modulesVnoptsNode_modulesLevenIndexJs(e, n) {
          "use strict";

          re();
          var t = [],
            s = [];
          n.exports = function (a, r) {
            if (a === r) return 0;
            var u = a;
            a.length > r.length && (a = r, r = u);
            var i = a.length,
              o = r.length;
            if (i === 0) return o;
            if (o === 0) return i;
            for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-o);) {
              i--, o--;
            }
            if (i === 0) return o;
            for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c);) {
              c++;
            }
            if (i -= c, o -= c, i === 0) return o;
            for (var v, m, d, p, f = 0, h = 0; f < i;) {
              s[c + f] = a.charCodeAt(c + f), t[f] = ++f;
            }
            for (; h < o;) {
              for (v = r.charCodeAt(c + h), d = h++, m = h, f = 0; f < i; f++) {
                p = v === s[c + f] ? d : d + 1, d = t[f], m = t[f] = d > m ? p > m ? m + 1 : p : p > d ? d + 1 : p;
              }
            }
            return m;
          };
        }
      }),
      Ra = Z({
        "node_modules/vnopts/lib/handlers/unknown/leven.js": function node_modulesVnoptsLibHandlersUnknownLevenJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = _r(),
            t = tm();
          e.levenUnknownHandler = function (s, a, r) {
            var u = r.descriptor,
              i = r.logger,
              o = r.schemas,
              c = ["Ignored unknown option ".concat(n.default.yellow(u.pair({
                key: s,
                value: a
              })), ".")],
              v = Object.keys(o).sort().find(function (m) {
                return t(s, m) < 3;
              });
            v && c.push("Did you mean ".concat(n.default.blue(u.key(v)), "?")), i.warn(c.join(" "));
          };
        }
      }),
      rm = Z({
        "node_modules/vnopts/lib/handlers/unknown/index.js": function node_modulesVnoptsLibHandlersUnknownIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(Ra(), e);
        }
      }),
      nm = Z({
        "node_modules/vnopts/lib/handlers/index.js": function node_modulesVnoptsLibHandlersIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(ZD(), e), n.__exportStar(Ma(), e), n.__exportStar(rm(), e);
        }
      }),
      vt = Z({
        "node_modules/vnopts/lib/schema.js": function node_modulesVnoptsLibSchemaJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(r, u) {
            var i = new r(u),
              o = Object.create(i);
            var _iterator8 = _createForOfIteratorHelper(n),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var c = _step8.value;
                c in u && (o[c] = a(u[c], i, s.prototype[c].length));
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            return o;
          }
          e.createSchema = t;
          var s = /*#__PURE__*/function () {
            function s(r) {
              _classCallCheck(this, s);
              this.name = r.name;
            }
            _createClass(s, [{
              key: "default",
              value: function _default(r) {}
            }, {
              key: "expected",
              value: function expected(r) {
                return "nothing";
              }
            }, {
              key: "validate",
              value: function validate(r, u) {
                return !1;
              }
            }, {
              key: "deprecated",
              value: function deprecated(r, u) {
                return !1;
              }
            }, {
              key: "forward",
              value: function forward(r, u) {}
            }, {
              key: "redirect",
              value: function redirect(r, u) {}
            }, {
              key: "overlap",
              value: function overlap(r, u, i) {
                return r;
              }
            }, {
              key: "preprocess",
              value: function preprocess(r, u) {
                return r;
              }
            }, {
              key: "postprocess",
              value: function postprocess(r, u) {
                return r;
              }
            }], [{
              key: "create",
              value: function create(r) {
                return t(this, r);
              }
            }]);
            return s;
          }();
          e.Schema = s;
          function a(r, u, i) {
            return typeof r == "function" ? function () {
              for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++) {
                c[v] = arguments[v];
              }
              return r.apply(void 0, _toConsumableArray(c.slice(0, i - 1)).concat([u], _toConsumableArray(c.slice(i - 1))));
            } : function () {
              return r;
            };
          }
        }
      }),
      um = Z({
        "node_modules/vnopts/lib/schemas/alias.js": function node_modulesVnoptsLibSchemasAliasJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = /*#__PURE__*/function (_n$Schema) {
              _inherits(t, _n$Schema);
              var _super5 = _createSuper(t);
              function t(s) {
                var _this;
                _classCallCheck(this, t);
                _this = _super5.call(this, s), _this._sourceName = s.sourceName;
                return _this;
              }
              _createClass(t, [{
                key: "expected",
                value: function expected(s) {
                  return s.schemas[this._sourceName].expected(s);
                }
              }, {
                key: "validate",
                value: function validate(s, a) {
                  return a.schemas[this._sourceName].validate(s, a);
                }
              }, {
                key: "redirect",
                value: function redirect(s, a) {
                  return this._sourceName;
                }
              }]);
              return t;
            }(n.Schema);
          e.AliasSchema = t;
        }
      }),
      sm = Z({
        "node_modules/vnopts/lib/schemas/any.js": function node_modulesVnoptsLibSchemasAnyJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = /*#__PURE__*/function (_n$Schema2) {
              _inherits(t, _n$Schema2);
              var _super6 = _createSuper(t);
              function t() {
                _classCallCheck(this, t);
                return _super6.apply(this, arguments);
              }
              _createClass(t, [{
                key: "expected",
                value: function expected() {
                  return "anything";
                }
              }, {
                key: "validate",
                value: function validate() {
                  return !0;
                }
              }]);
              return t;
            }(n.Schema);
          e.AnySchema = t;
        }
      }),
      im = Z({
        "node_modules/vnopts/lib/schemas/array.js": function node_modulesVnoptsLibSchemasArrayJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt)),
            t = vt(),
            s = /*#__PURE__*/function (_t$Schema) {
              _inherits(s, _t$Schema);
              var _super7 = _createSuper(s);
              function s(r) {
                var _this2;
                _classCallCheck(this, s);
                var u = r.valueSchema,
                  _r$name = r.name,
                  i = _r$name === void 0 ? u.name : _r$name,
                  o = n.__rest(r, ["valueSchema", "name"]);
                _this2 = _super7.call(this, Object.assign({}, o, {
                  name: i
                })), _this2._valueSchema = u;
                return _this2;
              }
              _createClass(s, [{
                key: "expected",
                value: function expected(r) {
                  return "an array of ".concat(this._valueSchema.expected(r));
                }
              }, {
                key: "validate",
                value: function validate(r, u) {
                  if (!Array.isArray(r)) return !1;
                  var i = [];
                  var _iterator9 = _createForOfIteratorHelper(r),
                    _step9;
                  try {
                    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                      var o = _step9.value;
                      var c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
                      c !== !0 && i.push(c.value);
                    }
                  } catch (err) {
                    _iterator9.e(err);
                  } finally {
                    _iterator9.f();
                  }
                  return i.length === 0 ? !0 : {
                    value: i
                  };
                }
              }, {
                key: "deprecated",
                value: function deprecated(r, u) {
                  var i = [];
                  var _iterator10 = _createForOfIteratorHelper(r),
                    _step10;
                  try {
                    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                      var o = _step10.value;
                      var c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
                      c !== !1 && i.push.apply(i, _toConsumableArray(c.map(function (v) {
                        var m = v.value;
                        return {
                          value: [m]
                        };
                      })));
                    }
                  } catch (err) {
                    _iterator10.e(err);
                  } finally {
                    _iterator10.f();
                  }
                  return i;
                }
              }, {
                key: "forward",
                value: function forward(r, u) {
                  var i = [];
                  var _iterator11 = _createForOfIteratorHelper(r),
                    _step11;
                  try {
                    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                      var o = _step11.value;
                      var c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
                      i.push.apply(i, _toConsumableArray(c.map(a)));
                    }
                  } catch (err) {
                    _iterator11.e(err);
                  } finally {
                    _iterator11.f();
                  }
                  return i;
                }
              }, {
                key: "redirect",
                value: function redirect(r, u) {
                  var i = [],
                    o = [];
                  var _iterator12 = _createForOfIteratorHelper(r),
                    _step12;
                  try {
                    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                      var c = _step12.value;
                      var v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                      "remain" in v && i.push(v.remain), o.push.apply(o, _toConsumableArray(v.redirect.map(a)));
                    }
                  } catch (err) {
                    _iterator12.e(err);
                  } finally {
                    _iterator12.f();
                  }
                  return i.length === 0 ? {
                    redirect: o
                  } : {
                    redirect: o,
                    remain: i
                  };
                }
              }, {
                key: "overlap",
                value: function overlap(r, u) {
                  return r.concat(u);
                }
              }]);
              return s;
            }(t.Schema);
          e.ArraySchema = s;
          function a(r) {
            var u = r.from,
              i = r.to;
            return {
              from: [u],
              to: i
            };
          }
        }
      }),
      am = Z({
        "node_modules/vnopts/lib/schemas/boolean.js": function node_modulesVnoptsLibSchemasBooleanJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = /*#__PURE__*/function (_n$Schema3) {
              _inherits(t, _n$Schema3);
              var _super8 = _createSuper(t);
              function t() {
                _classCallCheck(this, t);
                return _super8.apply(this, arguments);
              }
              _createClass(t, [{
                key: "expected",
                value: function expected() {
                  return "true or false";
                }
              }, {
                key: "validate",
                value: function validate(s) {
                  return typeof s == "boolean";
                }
              }]);
              return t;
            }(n.Schema);
          e.BooleanSchema = t;
        }
      }),
      Hn = Z({
        "node_modules/vnopts/lib/utils.js": function node_modulesVnoptsLibUtilsJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          function n(p, f) {
            var h = Object.create(null);
            var _iterator13 = _createForOfIteratorHelper(p),
              _step13;
            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var _w = _step13.value;
                var T = _w[f];
                if (h[T]) throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h[T] = _w;
              }
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
            return h;
          }
          e.recordFromArray = n;
          function t(p, f) {
            var h = new Map();
            var _iterator14 = _createForOfIteratorHelper(p),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _w2 = _step14.value;
                var T = _w2[f];
                if (h.has(T)) throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
                h.set(T, _w2);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
            return h;
          }
          e.mapFromArray = t;
          function s() {
            var p = Object.create(null);
            return function (f) {
              var h = JSON.stringify(f);
              return p[h] ? !0 : (p[h] = !0, !1);
            };
          }
          e.createAutoChecklist = s;
          function a(p, f) {
            var h = [],
              w = [];
            var _iterator15 = _createForOfIteratorHelper(p),
              _step15;
            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var T = _step15.value;
                f(T) ? h.push(T) : w.push(T);
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
            return [h, w];
          }
          e.partition = a;
          function r(p) {
            return p === Math.floor(p);
          }
          e.isInt = r;
          function u(p, f) {
            if (p === f) return 0;
            var h = _typeof(p),
              w = _typeof(f),
              T = ["undefined", "object", "boolean", "number", "string"];
            return h !== w ? T.indexOf(h) - T.indexOf(w) : h !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i(p) {
            return p === void 0 ? {} : p;
          }
          e.normalizeDefaultResult = i;
          function o(p, f) {
            return p === !0 ? !0 : p === !1 ? {
              value: f
            } : p;
          }
          e.normalizeValidateResult = o;
          function c(p, f) {
            var h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            return p === !1 ? !1 : p === !0 ? h ? !0 : [{
              value: f
            }] : "value" in p ? [p] : p.length === 0 ? !1 : p;
          }
          e.normalizeDeprecatedResult = c;
          function v(p, f) {
            return typeof p == "string" || "key" in p ? {
              from: f,
              to: p
            } : "from" in p ? {
              from: p.from,
              to: p.to
            } : {
              from: f,
              to: p.to
            };
          }
          e.normalizeTransferResult = v;
          function m(p, f) {
            return p === void 0 ? [] : Array.isArray(p) ? p.map(function (h) {
              return v(h, f);
            }) : [v(p, f)];
          }
          e.normalizeForwardResult = m;
          function d(p, f) {
            var h = m(_typeof(p) == "object" && "redirect" in p ? p.redirect : p, f);
            return h.length === 0 ? {
              remain: f,
              redirect: h
            } : _typeof(p) == "object" && "remain" in p ? {
              remain: p.remain,
              redirect: h
            } : {
              redirect: h
            };
          }
          e.normalizeRedirectResult = d;
        }
      }),
      om = Z({
        "node_modules/vnopts/lib/schemas/choice.js": function node_modulesVnoptsLibSchemasChoiceJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = Hn(),
            s = /*#__PURE__*/function (_n$Schema4) {
              _inherits(s, _n$Schema4);
              var _super9 = _createSuper(s);
              function s(a) {
                var _this3;
                _classCallCheck(this, s);
                _this3 = _super9.call(this, a), _this3._choices = t.mapFromArray(a.choices.map(function (r) {
                  return r && _typeof(r) == "object" ? r : {
                    value: r
                  };
                }), "value");
                return _this3;
              }
              _createClass(s, [{
                key: "expected",
                value: function expected(a) {
                  var _this4 = this;
                  var r = a.descriptor,
                    u = Array.from(this._choices.keys()).map(function (c) {
                      return _this4._choices.get(c);
                    }).filter(function (c) {
                      return !c.deprecated;
                    }).map(function (c) {
                      return c.value;
                    }).sort(t.comparePrimitive).map(r.value),
                    i = u.slice(0, -2),
                    o = u.slice(-2);
                  return i.concat(o.join(" or ")).join(", ");
                }
              }, {
                key: "validate",
                value: function validate(a) {
                  return this._choices.has(a);
                }
              }, {
                key: "deprecated",
                value: function deprecated(a) {
                  var r = this._choices.get(a);
                  return r && r.deprecated ? {
                    value: a
                  } : !1;
                }
              }, {
                key: "forward",
                value: function forward(a) {
                  var r = this._choices.get(a);
                  return r ? r.forward : void 0;
                }
              }, {
                key: "redirect",
                value: function redirect(a) {
                  var r = this._choices.get(a);
                  return r ? r.redirect : void 0;
                }
              }]);
              return s;
            }(n.Schema);
          e.ChoiceSchema = s;
        }
      }),
      Va = Z({
        "node_modules/vnopts/lib/schemas/number.js": function node_modulesVnoptsLibSchemasNumberJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = /*#__PURE__*/function (_n$Schema5) {
              _inherits(t, _n$Schema5);
              var _super10 = _createSuper(t);
              function t() {
                _classCallCheck(this, t);
                return _super10.apply(this, arguments);
              }
              _createClass(t, [{
                key: "expected",
                value: function expected() {
                  return "a number";
                }
              }, {
                key: "validate",
                value: function validate(s, a) {
                  return typeof s == "number";
                }
              }]);
              return t;
            }(n.Schema);
          e.NumberSchema = t;
        }
      }),
      lm = Z({
        "node_modules/vnopts/lib/schemas/integer.js": function node_modulesVnoptsLibSchemasIntegerJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = Hn(),
            t = Va(),
            s = /*#__PURE__*/function (_t$NumberSchema) {
              _inherits(s, _t$NumberSchema);
              var _super11 = _createSuper(s);
              function s() {
                _classCallCheck(this, s);
                return _super11.apply(this, arguments);
              }
              _createClass(s, [{
                key: "expected",
                value: function expected() {
                  return "an integer";
                }
              }, {
                key: "validate",
                value: function validate(a, r) {
                  return r.normalizeValidateResult(_get(_getPrototypeOf(s.prototype), "validate", this).call(this, a, r), a) === !0 && n.isInt(a);
                }
              }]);
              return s;
            }(t.NumberSchema);
          e.IntegerSchema = s;
        }
      }),
      cm = Z({
        "node_modules/vnopts/lib/schemas/string.js": function node_modulesVnoptsLibSchemasStringJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = vt(),
            t = /*#__PURE__*/function (_n$Schema6) {
              _inherits(t, _n$Schema6);
              var _super12 = _createSuper(t);
              function t() {
                _classCallCheck(this, t);
                return _super12.apply(this, arguments);
              }
              _createClass(t, [{
                key: "expected",
                value: function expected() {
                  return "a string";
                }
              }, {
                key: "validate",
                value: function validate(s) {
                  return typeof s == "string";
                }
              }]);
              return t;
            }(n.Schema);
          e.StringSchema = t;
        }
      }),
      pm = Z({
        "node_modules/vnopts/lib/schemas/index.js": function node_modulesVnoptsLibSchemasIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(um(), e), n.__exportStar(sm(), e), n.__exportStar(im(), e), n.__exportStar(am(), e), n.__exportStar(om(), e), n.__exportStar(lm(), e), n.__exportStar(Va(), e), n.__exportStar(cm(), e);
        }
      }),
      fm = Z({
        "node_modules/vnopts/lib/defaults.js": function node_modulesVnoptsLibDefaultsJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = Oa(),
            t = qa(),
            s = Ma(),
            a = Ra();
          e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        }
      }),
      Dm = Z({
        "node_modules/vnopts/lib/normalize.js": function node_modulesVnoptsLibNormalizeJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = fm(),
            t = Hn();
          e.normalize = function (a, r, u) {
            return new s(r, u).normalize(a);
          };
          var s = /*#__PURE__*/function () {
            function s(a, r) {
              _classCallCheck(this, s);
              var _ref6 = r || {},
                _ref6$logger = _ref6.logger,
                u = _ref6$logger === void 0 ? console : _ref6$logger,
                _ref6$descriptor = _ref6.descriptor,
                i = _ref6$descriptor === void 0 ? n.defaultDescriptor : _ref6$descriptor,
                _ref6$unknown = _ref6.unknown,
                o = _ref6$unknown === void 0 ? n.defaultUnknownHandler : _ref6$unknown,
                _ref6$invalid = _ref6.invalid,
                c = _ref6$invalid === void 0 ? n.defaultInvalidHandler : _ref6$invalid,
                _ref6$deprecated = _ref6.deprecated,
                v = _ref6$deprecated === void 0 ? n.defaultDeprecatedHandler : _ref6$deprecated;
              this._utils = {
                descriptor: i,
                logger: u || {
                  warn: function warn() {}
                },
                schemas: t.recordFromArray(a, "name"),
                normalizeDefaultResult: t.normalizeDefaultResult,
                normalizeDeprecatedResult: t.normalizeDeprecatedResult,
                normalizeForwardResult: t.normalizeForwardResult,
                normalizeRedirectResult: t.normalizeRedirectResult,
                normalizeValidateResult: t.normalizeValidateResult
              }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();
            }
            _createClass(s, [{
              key: "cleanHistory",
              value: function cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
            }, {
              key: "normalize",
              value: function normalize(a) {
                var _this5 = this;
                var r = {},
                  u = [a],
                  i = function i() {
                    for (; u.length !== 0;) {
                      var o = u.shift(),
                        c = _this5._applyNormalization(o, r);
                      u.push.apply(u, _toConsumableArray(c));
                    }
                  };
                i();
                for (var _i2 = 0, _Object$keys = Object.keys(this._utils.schemas); _i2 < _Object$keys.length; _i2++) {
                  var o = _Object$keys[_i2];
                  var c = this._utils.schemas[o];
                  if (!(o in r)) {
                    var v = t.normalizeDefaultResult(c.default(this._utils));
                    "value" in v && u.push(_defineProperty({}, o, v.value));
                  }
                }
                i();
                for (var _i3 = 0, _Object$keys2 = Object.keys(this._utils.schemas); _i3 < _Object$keys2.length; _i3++) {
                  var _o2 = _Object$keys2[_i3];
                  var _c2 = this._utils.schemas[_o2];
                  _o2 in r && (r[_o2] = _c2.postprocess(r[_o2], this._utils));
                }
                return r;
              }
            }, {
              key: "_applyNormalization",
              value: function _applyNormalization(a, r) {
                var _this6 = this;
                var u = [],
                  _t$partition = t.partition(Object.keys(a), function (c) {
                    return c in _this6._utils.schemas;
                  }),
                  _t$partition2 = _slicedToArray(_t$partition, 2),
                  i = _t$partition2[0],
                  o = _t$partition2[1];
                var _iterator16 = _createForOfIteratorHelper(i),
                  _step16;
                try {
                  var _loop3 = function _loop3() {
                    var c = _step16.value;
                    var v = _this6._utils.schemas[c],
                      m = v.preprocess(a[c], _this6._utils),
                      d = t.normalizeValidateResult(v.validate(m, _this6._utils), m);
                    if (d !== !0) {
                      var T = d.value,
                        A = _this6._invalidHandler(c, T, _this6._utils);
                      throw typeof A == "string" ? new Error(A) : A;
                    }
                    var p = function p(T) {
                        var A = T.from,
                          S = T.to;
                        u.push(typeof S == "string" ? _defineProperty({}, S, A) : _defineProperty({}, S.key, S.value));
                      },
                      f = function f(T) {
                        var A = T.value,
                          S = T.redirectTo,
                          B = t.normalizeDeprecatedResult(v.deprecated(A, _this6._utils), m, !0);
                        if (B !== !1) if (B === !0) _this6._hasDeprecationWarned(c) || _this6._utils.logger.warn(_this6._deprecatedHandler(c, S, _this6._utils));else {
                          var _iterator18 = _createForOfIteratorHelper(B),
                            _step18;
                          try {
                            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                              var I = _step18.value.value;
                              var k = {
                                key: c,
                                value: I
                              };
                              if (!_this6._hasDeprecationWarned(k)) {
                                var P = typeof S == "string" ? {
                                  key: S,
                                  value: I
                                } : S;
                                _this6._utils.logger.warn(_this6._deprecatedHandler(k, P, _this6._utils));
                              }
                            }
                          } catch (err) {
                            _iterator18.e(err);
                          } finally {
                            _iterator18.f();
                          }
                        }
                      };
                    t.normalizeForwardResult(v.forward(m, _this6._utils), m).forEach(p);
                    var w = t.normalizeRedirectResult(v.redirect(m, _this6._utils), m);
                    if (w.redirect.forEach(p), "remain" in w) {
                      var _T = w.remain;
                      r[c] = c in r ? v.overlap(r[c], _T, _this6._utils) : _T, f({
                        value: _T
                      });
                    }
                    var _iterator19 = _createForOfIteratorHelper(w.redirect),
                      _step19;
                    try {
                      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                        var _step19$value = _step19.value,
                          _T2 = _step19$value.from,
                          _A = _step19$value.to;
                        f({
                          value: _T2,
                          redirectTo: _A
                        });
                      }
                    } catch (err) {
                      _iterator19.e(err);
                    } finally {
                      _iterator19.f();
                    }
                  };
                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                    _loop3();
                  }
                } catch (err) {
                  _iterator16.e(err);
                } finally {
                  _iterator16.f();
                }
                var _iterator17 = _createForOfIteratorHelper(o),
                  _step17;
                try {
                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                    var c = _step17.value;
                    var v = a[c],
                      m = this._unknownHandler(c, v, this._utils);
                    if (m) for (var _i4 = 0, _Object$keys3 = Object.keys(m); _i4 < _Object$keys3.length; _i4++) {
                      var d = _Object$keys3[_i4];
                      var p = _defineProperty({}, d, m[d]);
                      d in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                    }
                  }
                } catch (err) {
                  _iterator17.e(err);
                } finally {
                  _iterator17.f();
                }
                return u;
              }
            }]);
            return s;
          }();
          e.Normalizer = s;
        }
      }),
      mm = Z({
        "node_modules/vnopts/lib/index.js": function node_modulesVnoptsLibIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = (ht(), lt(dt));
          n.__exportStar(QD(), e), n.__exportStar(nm(), e), n.__exportStar(pm(), e), n.__exportStar(Dm(), e), n.__exportStar(vt(), e);
        }
      }),
      dm = Z({
        "src/main/options-normalizer.js": function srcMainOptionsNormalizerJs(e, n) {
          "use strict";

          re();
          var t = mm(),
            s = it(),
            a = {
              key: function key(d) {
                return d.length === 1 ? "-".concat(d) : "--".concat(d);
              },
              value: function value(d) {
                return t.apiDescriptor.value(d);
              },
              pair: function pair(d) {
                var p = d.key,
                  f = d.value;
                return f === !1 ? "--no-".concat(p) : f === !0 ? a.key(p) : f === "" ? "".concat(a.key(p), " without an argument") : "".concat(a.key(p), "=").concat(f);
              }
            },
            r = function r(d) {
              var p = d.colorsModule,
                f = d.levenshteinDistance;
              return /*#__PURE__*/function (_t$ChoiceSchema) {
                _inherits(_class, _t$ChoiceSchema);
                var _super13 = _createSuper(_class);
                function _class(w) {
                  var _this7;
                  _classCallCheck(this, _class);
                  var T = w.name,
                    A = w.flags;
                  _this7 = _super13.call(this, {
                    name: T,
                    choices: A
                  }), _this7._flags = _toConsumableArray(A).sort();
                  return _this7;
                }
                _createClass(_class, [{
                  key: "preprocess",
                  value: function preprocess(w, T) {
                    if (typeof w == "string" && w.length > 0 && !this._flags.includes(w)) {
                      var A = this._flags.find(function (S) {
                        return f(S, w) < 3;
                      });
                      if (A) return T.logger.warn(["Unknown flag ".concat(p.yellow(T.descriptor.value(w)), ","), "did you mean ".concat(p.blue(T.descriptor.value(A)), "?")].join(" ")), A;
                    }
                    return w;
                  }
                }, {
                  key: "expected",
                  value: function expected() {
                    return "a flag";
                  }
                }]);
                return _class;
              }(t.ChoiceSchema);
            },
            u;
          function i(d, p) {
            var _ref9 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              _ref9$logger = _ref9.logger,
              f = _ref9$logger === void 0 ? !1 : _ref9$logger,
              _ref9$isCLI = _ref9.isCLI,
              h = _ref9$isCLI === void 0 ? !1 : _ref9$isCLI,
              _ref9$passThrough = _ref9.passThrough,
              w = _ref9$passThrough === void 0 ? !1 : _ref9$passThrough,
              _ref9$colorsModule = _ref9.colorsModule,
              T = _ref9$colorsModule === void 0 ? null : _ref9$colorsModule,
              _ref9$levenshteinDist = _ref9.levenshteinDistance,
              A = _ref9$levenshteinDist === void 0 ? null : _ref9$levenshteinDist,
              S = w ? Array.isArray(w) ? function (D, g) {
                return w.includes(D) ? _defineProperty({}, D, g) : void 0;
              } : function (D, g) {
                return _defineProperty({}, D, g);
              } : function (D, g, F) {
                var l = F.schemas,
                  E = l._,
                  y = kn(l, Qf);
                return t.levenUnknownHandler(D, g, Object.assign(Object.assign({}, F), {}, {
                  schemas: y
                }));
              },
              B = h ? a : t.apiDescriptor,
              I = o(p, {
                isCLI: h,
                colorsModule: T,
                levenshteinDistance: A
              }),
              k = new t.Normalizer(I, {
                logger: f,
                unknown: S,
                descriptor: B
              }),
              P = f !== !1;
            P && u && (k._hasDeprecationWarned = u);
            var C = k.normalize(d);
            return P && (u = k._hasDeprecationWarned), h && C["plugin-search"] === !1 && (C["plugin-search-dir"] = !1), C;
          }
          function o(d, p) {
            var f = p.isCLI,
              h = p.colorsModule,
              w = p.levenshteinDistance,
              T = [];
            f && T.push(t.AnySchema.create({
              name: "_"
            }));
            var _iterator20 = _createForOfIteratorHelper(d),
              _step20;
            try {
              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                var A = _step20.value;
                T.push(c(A, {
                  isCLI: f,
                  optionInfos: d,
                  colorsModule: h,
                  levenshteinDistance: w
                })), A.alias && f && T.push(t.AliasSchema.create({
                  name: A.alias,
                  sourceName: A.name
                }));
              }
            } catch (err) {
              _iterator20.e(err);
            } finally {
              _iterator20.f();
            }
            return T;
          }
          function c(d, p) {
            var f = p.isCLI,
              h = p.optionInfos,
              w = p.colorsModule,
              T = p.levenshteinDistance,
              A = d.name;
            if (A === "plugin-search-dir" || A === "pluginSearchDirs") return t.AnySchema.create({
              name: A,
              preprocess: function preprocess(k) {
                return k === !1 || (k = Array.isArray(k) ? k : [k]), k;
              },
              validate: function validate(k) {
                return k === !1 ? !0 : k.every(function (P) {
                  return typeof P == "string";
                });
              },
              expected: function expected() {
                return "false or paths to plugin search dir";
              }
            });
            var S = {
                name: A
              },
              B,
              I = {};
            switch (d.type) {
              case "int":
                B = t.IntegerSchema, f && (S.preprocess = Number);
                break;
              case "string":
                B = t.StringSchema;
                break;
              case "choice":
                B = t.ChoiceSchema, S.choices = d.choices.map(function (k) {
                  return _typeof(k) == "object" && k.redirect ? Object.assign(Object.assign({}, k), {}, {
                    redirect: {
                      to: {
                        key: d.name,
                        value: k.redirect
                      }
                    }
                  }) : k;
                });
                break;
              case "boolean":
                B = t.BooleanSchema;
                break;
              case "flag":
                B = r({
                  colorsModule: w,
                  levenshteinDistance: T
                }), S.flags = h.flatMap(function (k) {
                  return [k.alias, k.description && k.name, k.oppositeDescription && "no-".concat(k.name)].filter(Boolean);
                });
                break;
              case "path":
                B = t.StringSchema;
                break;
              default:
                throw new Error("Unexpected type ".concat(d.type));
            }
            if (d.exception ? S.validate = function (k, P, C) {
              return d.exception(k) || P.validate(k, C);
            } : S.validate = function (k, P, C) {
              return k === void 0 || P.validate(k, C);
            }, d.redirect && (I.redirect = function (k) {
              return k ? {
                to: {
                  key: d.redirect.option,
                  value: d.redirect.value
                }
              } : void 0;
            }), d.deprecated && (I.deprecated = !0), f && !d.array) {
              var k = S.preprocess || function (P) {
                return P;
              };
              S.preprocess = function (P, C, D) {
                return C.preprocess(k(Array.isArray(P) ? s(P) : P), D);
              };
            }
            return d.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? {
              preprocess: function preprocess(k) {
                return Array.isArray(k) ? k : [k];
              }
            } : {}), I), {}, {
              valueSchema: B.create(S)
            })) : B.create(Object.assign(Object.assign({}, S), I));
          }
          function v(d, p, f) {
            return i(d, p, f);
          }
          function m(d, p, f) {
            return i(d, p, Object.assign({
              isCLI: !0
            }, f));
          }
          n.exports = {
            normalizeApiOptions: v,
            normalizeCliOptions: m
          };
        }
      }),
      st = Z({
        "src/language-js/loc.js": function srcLanguageJsLocJs(e, n) {
          "use strict";

          re();
          var t = Rn();
          function s(o, c) {
            var _ref12 = c || {},
              v = _ref12.ignoreDecorators;
            if (!v) {
              var m = o.declaration && o.declaration.decorators || o.decorators;
              if (t(m)) return s(m[0]);
            }
            return o.range ? o.range[0] : o.start;
          }
          function a(o) {
            return o.range ? o.range[1] : o.end;
          }
          function r(o, c) {
            var v = s(o);
            return Number.isInteger(v) && v === s(c);
          }
          function u(o, c) {
            var v = a(o);
            return Number.isInteger(v) && v === a(c);
          }
          function i(o, c) {
            return r(o, c) && u(o, c);
          }
          n.exports = {
            locStart: s,
            locEnd: a,
            hasSameLocStart: r,
            hasSameLoc: i
          };
        }
      }),
      gm = Z({
        "src/main/load-parser.js": function srcMainLoadParserJs(e, n) {
          re(), n.exports = function () {};
        }
      }),
      ym = Z({
        "scripts/build/shims/babel-highlight.cjs": function scriptsBuildShimsBabelHighlightCjs(e, n) {
          "use strict";

          re();
          var t = _r(),
            s = {
              shouldHighlight: function shouldHighlight() {
                return !1;
              },
              getChalk: function getChalk() {
                return t;
              }
            };
          n.exports = s;
        }
      }),
      hm = Z({
        "node_modules/@babel/code-frame/lib/index.js": function node_modulesBabelCodeFrameLibIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.codeFrameColumns = u, e.default = i;
          var n = ym(),
            t = !1;
          function s(o) {
            return {
              gutter: o.grey,
              marker: o.red.bold,
              message: o.red.bold
            };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function r(o, c, v) {
            var m = Object.assign({
                column: 0,
                line: -1
              }, o.start),
              d = Object.assign({}, m, o.end),
              _ref13 = v || {},
              _ref13$linesAbove = _ref13.linesAbove,
              p = _ref13$linesAbove === void 0 ? 2 : _ref13$linesAbove,
              _ref13$linesBelow = _ref13.linesBelow,
              f = _ref13$linesBelow === void 0 ? 3 : _ref13$linesBelow,
              h = m.line,
              w = m.column,
              T = d.line,
              A = d.column,
              S = Math.max(h - (p + 1), 0),
              B = Math.min(c.length, T + f);
            h === -1 && (S = 0), T === -1 && (B = c.length);
            var I = T - h,
              k = {};
            if (I) for (var P = 0; P <= I; P++) {
              var C = P + h;
              if (!w) k[C] = !0;else if (P === 0) {
                var D = c[C - 1].length;
                k[C] = [w, D - w + 1];
              } else if (P === I) k[C] = [0, A];else {
                var _D2 = c[C - P].length;
                k[C] = [0, _D2];
              }
            } else w === A ? w ? k[h] = [w, 0] : k[h] = !0 : k[h] = [w, A - w];
            return {
              start: S,
              end: B,
              markerLines: k
            };
          }
          function u(o, c) {
            var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              m = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v),
              d = (0, n.getChalk)(v),
              p = s(d),
              f = function f(P, C) {
                return m ? P(C) : C;
              },
              h = o.split(a),
              _r2 = r(c, h, v),
              w = _r2.start,
              T = _r2.end,
              A = _r2.markerLines,
              S = c.start && typeof c.start.column == "number",
              B = String(T).length,
              k = (m ? (0, n.default)(o, v) : o).split(a, T).slice(w, T).map(function (P, C) {
                var D = w + 1 + C,
                  g = " ".concat(D).slice(-B),
                  F = " ".concat(g, " |"),
                  l = A[D],
                  E = !A[D + 1];
                if (l) {
                  var y = "";
                  if (Array.isArray(l)) {
                    var N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " "),
                      x = l[1] || 1;
                    y = ["\n ", f(p.gutter, F.replace(/\d/g, " ")), " ", N, f(p.marker, "^").repeat(x)].join(""), E && v.message && (y += " " + f(p.message, v.message));
                  }
                  return [f(p.marker, ">"), f(p.gutter, F), P.length > 0 ? " ".concat(P) : "", y].join("");
                } else return " ".concat(f(p.gutter, F)).concat(P.length > 0 ? " ".concat(P) : "");
              }).join("\n");
            return v.message && !S && (k = "".concat(" ".repeat(B + 1)).concat(v.message, "\n").concat(k)), m ? d.reset(k) : k;
          }
          function i(o, c, v) {
            var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = !0;
              var p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (Tt.emitWarning) Tt.emitWarning(p, "DeprecationWarning");else {
                var f = new Error(p);
                f.name = "DeprecationWarning", console.warn(new Error(p));
              }
            }
            return v = Math.max(v, 0), u(o, {
              start: {
                column: v,
                line: c
              }
            }, m);
          }
        }
      }),
      Gn = Z({
        "src/main/parser.js": function srcMainParserJs(e, n) {
          "use strict";

          re();
          var _zt = zt(),
            t = _zt.ConfigError,
            s = st(),
            a = gm(),
            r = s.locStart,
            u = s.locEnd,
            i = Object.getOwnPropertyNames,
            o = Object.getOwnPropertyDescriptor;
          function c(d) {
            var p = {};
            var _iterator21 = _createForOfIteratorHelper(d.plugins),
              _step21;
            try {
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                var f = _step21.value;
                if (!!f.parsers) {
                  var _iterator22 = _createForOfIteratorHelper(i(f.parsers)),
                    _step22;
                  try {
                    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                      var _h3 = _step22.value;
                      Object.defineProperty(p, _h3, o(f.parsers, _h3));
                    }
                  } catch (err) {
                    _iterator22.e(err);
                  } finally {
                    _iterator22.f();
                  }
                }
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }
            return p;
          }
          function v(d) {
            var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d);
            if (typeof d.parser == "function") return {
              parse: d.parser,
              astFormat: "estree",
              locStart: r,
              locEnd: u
            };
            if (typeof d.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p, d.parser)) return p[d.parser];
              throw new t("Couldn't resolve parser \"".concat(d.parser, '". Parsers must be explicitly added to the standalone bundle.'));
            }
          }
          function m(d, p) {
            var f = c(p),
              h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map(function (T) {
                return [T, {
                  enumerable: !0,
                  get: function get() {
                    return f[T].parse;
                  }
                }];
              }))),
              w = v(p, f);
            try {
              return w.preprocess && (d = w.preprocess(d, p)), {
                text: d,
                ast: w.parse(d, h, p)
              };
            } catch (T) {
              var A = T.loc;
              if (A) {
                var _hm = hm(),
                  S = _hm.codeFrameColumns;
                throw T.codeFrame = S(d, A, {
                  highlightCode: !0
                }), T.message += "\n" + T.codeFrame, T;
              }
              throw T.stack;
            }
          }
          n.exports = {
            parse: m,
            resolveParser: v
          };
        }
      }),
      Wa = Z({
        "src/main/options.js": function srcMainOptionsJs(e, n) {
          "use strict";

          re();
          var t = PD(),
            _zt2 = zt(),
            s = _zt2.UndefinedParserError,
            _Mn2 = Mn(),
            a = _Mn2.getSupportInfo,
            r = dm(),
            _Gn = Gn(),
            u = _Gn.resolveParser,
            i = {
              astFormat: "estree",
              printer: {},
              originalText: void 0,
              locStart: null,
              locEnd: null
            };
          function o(m) {
            var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
              p = Object.assign({}, m),
              f = a({
                plugins: m.plugins,
                showUnreleased: !0,
                showDeprecated: !0
              }).options,
              h = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter(function (B) {
                return B.default !== void 0;
              }).map(function (B) {
                return [B.name, B.default];
              })));
            if (!p.parser) {
              if (!p.filepath) (d.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";else if (p.parser = v(p.filepath, p.plugins), !p.parser) throw new s("No parser could be inferred for file: ".concat(p.filepath));
            }
            var w = u(r.normalizeApiOptions(p, [f.find(function (B) {
              return B.name === "parser";
            })], {
              passThrough: !0,
              logger: !1
            }));
            p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;
            var T = c(p);
            p.printer = T.printers[p.astFormat];
            var A = Object.fromEntries(f.filter(function (B) {
                return B.pluginDefaults && B.pluginDefaults[T.name] !== void 0;
              }).map(function (B) {
                return [B.name, B.pluginDefaults[T.name]];
              })),
              S = Object.assign(Object.assign({}, h), A);
            for (var _i5 = 0, _Object$entries = Object.entries(S); _i5 < _Object$entries.length; _i5++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),
                B = _Object$entries$_i[0],
                I = _Object$entries$_i[1];
              (p[B] === null || p[B] === void 0) && (p[B] = I);
            }
            return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({
              passThrough: Object.keys(i)
            }, d));
          }
          function c(m) {
            var d = m.astFormat;
            if (!d) throw new Error("getPlugin() requires astFormat to be set");
            var p = m.plugins.find(function (f) {
              return f.printers && f.printers[d];
            });
            if (!p) throw new Error("Couldn't find plugin for AST format \"".concat(d, '"'));
            return p;
          }
          function v(m, d) {
            var p = t.basename(m).toLowerCase(),
              h = a({
                plugins: d
              }).languages.filter(function (w) {
                return w.since !== null;
              }).find(function (w) {
                return w.extensions && w.extensions.some(function (T) {
                  return p.endsWith(T);
                }) || w.filenames && w.filenames.some(function (T) {
                  return T.toLowerCase() === p;
                });
              });
            return h && h.parsers[0];
          }
          n.exports = {
            normalize: o,
            hiddenDefaults: i,
            inferParser: v
          };
        }
      }),
      vm = Z({
        "src/main/massage-ast.js": function srcMainMassageAstJs(e, n) {
          "use strict";

          re();
          function t(s, a, r) {
            if (Array.isArray(s)) return s.map(function (c) {
              return t(c, a, r);
            }).filter(Boolean);
            if (!s || _typeof(s) != "object") return s;
            var u = a.printer.massageAstNode,
              i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = new Set();
            var o = {};
            for (var _i6 = 0, _Object$entries2 = Object.entries(s); _i6 < _Object$entries2.length; _i6++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i6], 2),
                c = _Object$entries2$_i[0],
                v = _Object$entries2$_i[1];
              !i.has(c) && typeof v != "function" && (o[c] = t(v, a, s));
            }
            if (u) {
              var _c3 = u(s, o, r);
              if (_c3 === null) return;
              if (_c3) return _c3;
            }
            return o;
          }
          n.exports = t;
        }
      }),
      Xt = Z({
        "scripts/build/shims/assert.cjs": function scriptsBuildShimsAssertCjs(e, n) {
          "use strict";

          re();
          var t = function t() {};
          t.ok = t, t.strictEqual = t, n.exports = t;
        }
      }),
      et = Z({
        "src/main/comments.js": function srcMainCommentsJs(e, n) {
          "use strict";

          re();
          var t = Xt(),
            _Oe = Oe(),
            _Oe$builders = _Oe.builders,
            s = _Oe$builders.line,
            a = _Oe$builders.hardline,
            r = _Oe$builders.breakParent,
            u = _Oe$builders.indent,
            i = _Oe$builders.lineSuffix,
            o = _Oe$builders.join,
            c = _Oe$builders.cursor,
            _Ue = Ue(),
            v = _Ue.hasNewline,
            m = _Ue.skipNewline,
            d = _Ue.skipSpaces,
            p = _Ue.isPreviousLineEmpty,
            f = _Ue.addLeadingComment,
            h = _Ue.addDanglingComment,
            w = _Ue.addTrailingComment,
            T = new WeakMap();
          function A(L, M, j) {
            if (!L) return;
            var $ = M.printer,
              V = M.locStart,
              q = M.locEnd;
            if (j) {
              if ($.canAttachComment && $.canAttachComment(L)) {
                var H;
                for (H = j.length - 1; H >= 0 && !(V(j[H]) <= V(L) && q(j[H]) <= q(L)); --H) {
                  ;
                }
                j.splice(H + 1, 0, L);
                return;
              }
            } else if (T.has(L)) return T.get(L);
            var Y = $.getCommentChildNodes && $.getCommentChildNodes(L, M) || _typeof(L) == "object" && Object.entries(L).filter(function (H) {
              var _H = _slicedToArray(H, 1),
                R = _H[0];
              return R !== "enclosingNode" && R !== "precedingNode" && R !== "followingNode" && R !== "tokens" && R !== "comments" && R !== "parent";
            }).map(function (H) {
              var _H2 = _slicedToArray(H, 2),
                R = _H2[1];
              return R;
            });
            if (!!Y) {
              j || (j = [], T.set(L, j));
              var _iterator23 = _createForOfIteratorHelper(Y),
                _step23;
              try {
                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                  var _H3 = _step23.value;
                  A(_H3, M, j);
                }
              } catch (err) {
                _iterator23.e(err);
              } finally {
                _iterator23.f();
              }
              return j;
            }
          }
          function S(L, M, j, $) {
            var V = j.locStart,
              q = j.locEnd,
              Y = V(M),
              H = q(M),
              R = A(L, j),
              Q,
              ee,
              te = 0,
              oe = R.length;
            for (; te < oe;) {
              var W = te + oe >> 1,
                X = R[W],
                ue = V(X),
                De = q(X);
              if (ue <= Y && H <= De) return S(X, M, j, X);
              if (De <= Y) {
                Q = X, te = W + 1;
                continue;
              }
              if (H <= ue) {
                ee = X, oe = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if ($ && $.type === "TemplateLiteral") {
              var _W = $.quasis,
                _X = F(_W, M, j);
              Q && F(_W, Q, j) !== _X && (Q = null), ee && F(_W, ee, j) !== _X && (ee = null);
            }
            return {
              enclosingNode: $,
              precedingNode: Q,
              followingNode: ee
            };
          }
          var B = function B() {
            return !1;
          };
          function I(L, M, j, $) {
            if (!Array.isArray(L)) return;
            var V = [],
              q = $.locStart,
              Y = $.locEnd,
              _$$printer$handleComm = $.printer.handleComments,
              H = _$$printer$handleComm === void 0 ? {} : _$$printer$handleComm,
              R = H.avoidAstMutation,
              _H$ownLine = H.ownLine,
              Q = _H$ownLine === void 0 ? B : _H$ownLine,
              _H$endOfLine = H.endOfLine,
              ee = _H$endOfLine === void 0 ? B : _H$endOfLine,
              _H$remaining = H.remaining,
              te = _H$remaining === void 0 ? B : _H$remaining,
              oe = L.map(function (W, X) {
                return Object.assign(Object.assign({}, S(M, W, $)), {}, {
                  comment: W,
                  text: j,
                  options: $,
                  ast: M,
                  isLastComment: L.length - 1 === X
                });
              });
            var _iterator24 = _createForOfIteratorHelper(oe.entries()),
              _step24;
            try {
              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                var _step24$value = _slicedToArray(_step24.value, 2),
                  _W2 = _step24$value[0],
                  X = _step24$value[1];
                var ue = X.comment,
                  De = X.precedingNode,
                  ie = X.enclosingNode,
                  G = X.followingNode,
                  z = X.text,
                  U = X.options,
                  le = X.ast,
                  ge = X.isLastComment;
                if (U.parser === "json" || U.parser === "json5" || U.parser === "__js_expression" || U.parser === "__vue_expression" || U.parser === "__vue_ts_expression") {
                  if (q(ue) - q(le) <= 0) {
                    f(le, ue);
                    continue;
                  }
                  if (Y(ue) - Y(le) >= 0) {
                    w(le, ue);
                    continue;
                  }
                }
                var Ae = void 0;
                if (R ? Ae = [X] : (ue.enclosingNode = ie, ue.precedingNode = De, ue.followingNode = G, Ae = [ue, z, U, le, ge]), P(z, U, oe, _W2)) ue.placement = "ownLine", Q.apply(void 0, _toConsumableArray(Ae)) || (G ? f(G, ue) : De ? w(De, ue) : h(ie || le, ue));else if (C(z, U, oe, _W2)) ue.placement = "endOfLine", ee.apply(void 0, _toConsumableArray(Ae)) || (De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue));else if (ue.placement = "remaining", !te.apply(void 0, _toConsumableArray(Ae))) if (De && G) {
                  var Ne = V.length;
                  Ne > 0 && V[Ne - 1].followingNode !== G && D(V, z, U), V.push(X);
                } else De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue);
              }
            } catch (err) {
              _iterator24.e(err);
            } finally {
              _iterator24.f();
            }
            if (D(V, j, $), !R) {
              var _iterator25 = _createForOfIteratorHelper(L),
                _step25;
              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                  var W = _step25.value;
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
                }
              } catch (err) {
                _iterator25.e(err);
              } finally {
                _iterator25.f();
              }
            }
          }
          var k = function k(L) {
            return !/[\S\n\u2028\u2029]/.test(L);
          };
          function P(L, M, j, $) {
            var _j$$ = j[$],
              V = _j$$.comment,
              q = _j$$.precedingNode,
              Y = M.locStart,
              H = M.locEnd,
              R = Y(V);
            if (q) for (var Q = $ - 1; Q >= 0; Q--) {
              var _j$Q = j[Q],
                ee = _j$Q.comment,
                te = _j$Q.precedingNode;
              if (te !== q || !k(L.slice(H(ee), R))) break;
              R = Y(ee);
            }
            return v(L, R, {
              backwards: !0
            });
          }
          function C(L, M, j, $) {
            var _j$$2 = j[$],
              V = _j$$2.comment,
              q = _j$$2.followingNode,
              Y = M.locStart,
              H = M.locEnd,
              R = H(V);
            if (q) for (var Q = $ + 1; Q < j.length; Q++) {
              var _j$Q2 = j[Q],
                ee = _j$Q2.comment,
                te = _j$Q2.followingNode;
              if (te !== q || !k(L.slice(R, Y(ee)))) break;
              R = H(ee);
            }
            return v(L, R);
          }
          function D(L, M, j) {
            var $ = L.length;
            if ($ === 0) return;
            var _L$ = L[0],
              V = _L$.precedingNode,
              q = _L$.followingNode,
              Y = _L$.enclosingNode,
              H = j.printer.getGapRegex && j.printer.getGapRegex(Y) || /^[\s(]*$/,
              R = j.locStart(q),
              Q;
            for (Q = $; Q > 0; --Q) {
              var _L10 = L[Q - 1],
                ee = _L10.comment,
                te = _L10.precedingNode,
                oe = _L10.followingNode;
              t.strictEqual(te, V), t.strictEqual(oe, q);
              var W = M.slice(j.locEnd(ee), R);
              if (H.test(W)) R = j.locStart(ee);else break;
            }
            var _iterator26 = _createForOfIteratorHelper(L.entries()),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var _step26$value = _slicedToArray(_step26.value, 2),
                  _ee2 = _step26$value[0],
                  _te = _step26$value[1].comment;
                _ee2 < Q ? w(V, _te) : f(q, _te);
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
            for (var _i7 = 0, _arr2 = [V, q]; _i7 < _arr2.length; _i7++) {
              var _ee = _arr2[_i7];
              _ee.comments && _ee.comments.length > 1 && _ee.comments.sort(function (te, oe) {
                return j.locStart(te) - j.locStart(oe);
              });
            }
            L.length = 0;
          }
          function g(L, M) {
            var j = L.getValue();
            return j.printed = !0, M.printer.printComment(L, M);
          }
          function F(L, M, j) {
            var $ = j.locStart(M) - 1;
            for (var V = 1; V < L.length; ++V) {
              if ($ < j.locStart(L[V])) return V - 1;
            }
            return 0;
          }
          function l(L, M) {
            var j = L.getValue(),
              $ = [g(L, M)],
              V = M.printer,
              q = M.originalText,
              Y = M.locStart,
              H = M.locEnd;
            if (V.isBlockComment && V.isBlockComment(j)) {
              var ee = v(q, H(j)) ? v(q, Y(j), {
                backwards: !0
              }) ? a : s : " ";
              $.push(ee);
            } else $.push(a);
            var Q = m(q, d(q, H(j)));
            return Q !== !1 && v(q, Q) && $.push(a), $;
          }
          function E(L, M) {
            var j = L.getValue(),
              $ = g(L, M),
              V = M.printer,
              q = M.originalText,
              Y = M.locStart,
              H = V.isBlockComment && V.isBlockComment(j);
            if (v(q, Y(j), {
              backwards: !0
            })) {
              var Q = p(q, j, Y);
              return i([a, Q ? a : "", $]);
            }
            var R = [" ", $];
            return H || (R = [i(R), r]), R;
          }
          function y(L, M, j, $) {
            var V = [],
              q = L.getValue();
            return !q || !q.comments || (L.each(function () {
              var Y = L.getValue();
              !Y.leading && !Y.trailing && (!$ || $(Y)) && V.push(g(L, M));
            }, "comments"), V.length === 0) ? "" : j ? o(a, V) : u([a, o(a, V)]);
          }
          function N(L, M, j) {
            var $ = L.getValue();
            if (!$) return {};
            var V = $.comments || [];
            j && (V = V.filter(function (R) {
              return !j.has(R);
            }));
            var q = $ === M.cursorNode;
            if (V.length === 0) {
              var R = q ? c : "";
              return {
                leading: R,
                trailing: R
              };
            }
            var Y = [],
              H = [];
            return L.each(function () {
              var R = L.getValue();
              if (j && j.has(R)) return;
              var Q = R.leading,
                ee = R.trailing;
              Q ? Y.push(l(L, M)) : ee && H.push(E(L, M));
            }, "comments"), q && (Y.unshift(c), H.push(c)), {
              leading: Y,
              trailing: H
            };
          }
          function x(L, M, j, $) {
            var _N2 = N(L, j, $),
              V = _N2.leading,
              q = _N2.trailing;
            return !V && !q ? M : [V, M, q];
          }
          function b(L) {
            if (!!L) {
              var _iterator27 = _createForOfIteratorHelper(L),
                _step27;
              try {
                for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                  var M = _step27.value;
                  if (!M.printed) throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                  delete M.printed;
                }
              } catch (err) {
                _iterator27.e(err);
              } finally {
                _iterator27.f();
              }
            }
          }
          n.exports = {
            attach: I,
            printComments: x,
            printCommentsSeparately: N,
            printDanglingComments: y,
            getSortedChildNodes: A,
            ensureAllCommentsPrinted: b
          };
        }
      }),
      Cm = Z({
        "src/common/ast-path.js": function srcCommonAstPathJs(e, n) {
          "use strict";

          re();
          var t = it();
          function s(u, i) {
            var o = a(u.stack, i);
            return o === -1 ? null : u.stack[o];
          }
          function a(u, i) {
            for (var o = u.length - 1; o >= 0; o -= 2) {
              var c = u[o];
              if (c && !Array.isArray(c) && --i < 0) return o;
            }
            return -1;
          }
          var r = /*#__PURE__*/function () {
            function r(u) {
              _classCallCheck(this, r);
              this.stack = [u];
            }
            _createClass(r, [{
              key: "getName",
              value: function getName() {
                var u = this.stack,
                  i = u.length;
                return i > 1 ? u[i - 2] : null;
              }
            }, {
              key: "getValue",
              value: function getValue() {
                return t(this.stack);
              }
            }, {
              key: "getNode",
              value: function getNode() {
                var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
            }, {
              key: "getParentNode",
              value: function getParentNode() {
                var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
            }, {
              key: "call",
              value: function call(u) {
                var i = this.stack,
                  o = i.length,
                  c = t(i);
                for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) {
                  m[d - 1] = arguments[d];
                }
                for (var _i8 = 0, _m2 = m; _i8 < _m2.length; _i8++) {
                  var f = _m2[_i8];
                  c = c[f], i.push(f, c);
                }
                var p = u(this);
                return i.length = o, p;
              }
            }, {
              key: "callParent",
              value: function callParent(u) {
                var _this$stack;
                var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
                  o = a(this.stack, i + 1),
                  c = this.stack.splice(o + 1),
                  v = u(this);
                return (_this$stack = this.stack).push.apply(_this$stack, _toConsumableArray(c)), v;
              }
            }, {
              key: "each",
              value: function each(u) {
                var i = this.stack,
                  o = i.length,
                  c = t(i);
                for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) {
                  m[d - 1] = arguments[d];
                }
                for (var _i9 = 0, _m3 = m; _i9 < _m3.length; _i9++) {
                  var p = _m3[_i9];
                  c = c[p], i.push(p, c);
                }
                for (var _p3 = 0; _p3 < c.length; ++_p3) {
                  i.push(_p3, c[_p3]), u(this, _p3, c), i.length -= 2;
                }
                i.length = o;
              }
            }, {
              key: "map",
              value: function map(u) {
                var i = [];
                for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++) {
                  c[v - 1] = arguments[v];
                }
                return this.each.apply(this, [function (m, d, p) {
                  i[d] = u(m, d, p);
                }].concat(c)), i;
              }
            }, {
              key: "try",
              value: function _try(u) {
                var i = this.stack,
                  o = _toConsumableArray(i);
                try {
                  return u();
                } finally {
                  i.length = 0, i.push.apply(i, _toConsumableArray(o));
                }
              }
            }, {
              key: "match",
              value: function match() {
                var u = this.stack.length - 1,
                  i = null,
                  o = this.stack[u--];
                for (var c = arguments.length, v = new Array(c), m = 0; m < c; m++) {
                  v[m] = arguments[m];
                }
                for (var _i10 = 0, _v = v; _i10 < _v.length; _i10++) {
                  var d = _v[_i10];
                  if (o === void 0) return !1;
                  var p = null;
                  if (typeof i == "number" && (p = i, i = this.stack[u--], o = this.stack[u--]), d && !d(o, i, p)) return !1;
                  i = this.stack[u--], o = this.stack[u--];
                }
                return !0;
              }
            }, {
              key: "findAncestor",
              value: function findAncestor(u) {
                var i = this.stack.length - 1,
                  o = null,
                  c = this.stack[i--];
                for (; c;) {
                  var v = null;
                  if (typeof o == "number" && (v = o, o = this.stack[i--], c = this.stack[i--]), o !== null && u(c, o, v)) return c;
                  o = this.stack[i--], c = this.stack[i--];
                }
              }
            }]);
            return r;
          }();
          n.exports = r;
        }
      }),
      Em = Z({
        "src/main/multiparser.js": function srcMainMultiparserJs(e, n) {
          "use strict";

          re();
          var _Oe2 = Oe(),
            t = _Oe2.utils.stripTrailingHardline,
            _Wa = Wa(),
            s = _Wa.normalize,
            a = et();
          function r(i, o, c, v) {
            if (c.printer.embed && c.embeddedLanguageFormatting === "auto") return c.printer.embed(i, o, function (m, d, p) {
              return u(m, d, c, v, p);
            }, c);
          }
          function u(i, o, c, v) {
            var _ref14 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},
              _ref14$stripTrailingH = _ref14.stripTrailingHardline,
              m = _ref14$stripTrailingH === void 0 ? !1 : _ref14$stripTrailingH,
              d = s(Object.assign(Object.assign(Object.assign({}, c), o), {}, {
                parentParser: c.parser,
                originalText: i
              }), {
                passThrough: !0
              }),
              p = Gn().parse(i, d),
              f = p.ast;
            i = p.text;
            var h = f.comments;
            delete f.comments, a.attach(h, f, i, d), d[Symbol.for("comments")] = h || [], d[Symbol.for("tokens")] = f.tokens || [];
            var w = v(f, d);
            return a.ensureAllCommentsPrinted(h), m ? typeof w == "string" ? w.replace(/(?:\r?\n)*$/, "") : t(w) : w;
          }
          n.exports = {
            printSubtree: r
          };
        }
      }),
      Fm = Z({
        "src/main/ast-to-doc.js": function srcMainAstToDocJs(e, n) {
          "use strict";

          re();
          var t = Cm(),
            _Oe3 = Oe(),
            _Oe3$builders = _Oe3.builders,
            s = _Oe3$builders.hardline,
            a = _Oe3$builders.addAlignmentToDoc,
            r = _Oe3.utils.propagateBreaks,
            _et = et(),
            u = _et.printComments,
            i = Em();
          function o(m, d) {
            var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
              f = d.printer;
            f.preprocess && (m = f.preprocess(m, d));
            var h = new Map(),
              w = new t(m),
              T = A();
            return p > 0 && (T = a([s, T], p, d.tabWidth)), r(T), T;
            function A(B, I) {
              return B === void 0 || B === w ? S(I) : Array.isArray(B) ? w.call.apply(w, [function () {
                return S(I);
              }].concat(_toConsumableArray(B))) : w.call(function () {
                return S(I);
              }, B);
            }
            function S(B) {
              var I = w.getValue(),
                k = I && _typeof(I) == "object" && B === void 0;
              if (k && h.has(I)) return h.get(I);
              var P = v(w, d, A, B);
              return k && h.set(I, P), P;
            }
          }
          function c(m, d) {
            var p = d.originalText,
              f = d[Symbol.for("comments")],
              h = d.locStart,
              w = d.locEnd,
              T = h(m),
              A = w(m),
              S = new Set();
            var _iterator28 = _createForOfIteratorHelper(f),
              _step28;
            try {
              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                var B = _step28.value;
                h(B) >= T && w(B) <= A && (B.printed = !0, S.add(B));
              }
            } catch (err) {
              _iterator28.e(err);
            } finally {
              _iterator28.f();
            }
            return {
              doc: p.slice(T, A),
              printedComments: S
            };
          }
          function v(m, d, p, f) {
            var h = m.getValue(),
              w = d.printer,
              T,
              A;
            if (w.hasPrettierIgnore && w.hasPrettierIgnore(m)) {
              var _c4 = c(h, d);
              T = _c4.doc;
              A = _c4.printedComments;
            } else {
              if (h) try {
                T = i.printSubtree(m, p, d, o);
              } catch (S) {
                if (globalThis.PRETTIER_DEBUG) throw S;
              }
              T || (T = w.print(m, d, p, f));
            }
            return (!w.willPrintOwnComments || !w.willPrintOwnComments(m, d)) && (T = u(m, T, d, A)), T;
          }
          n.exports = o;
        }
      }),
      Am = Z({
        "src/main/range-util.js": function srcMainRangeUtilJs(e, n) {
          "use strict";

          re();
          var t = Xt(),
            s = et(),
            a = function a(f) {
              var h = f.parser;
              return h === "json" || h === "json5" || h === "json-stringify";
            };
          function r(f, h) {
            var w = [f.node].concat(_toConsumableArray(f.parentNodes)),
              T = new Set([h.node].concat(_toConsumableArray(h.parentNodes)));
            return w.find(function (A) {
              return v.has(A.type) && T.has(A);
            });
          }
          function u(f) {
            var h = f.length - 1;
            for (;;) {
              var _w3 = f[h];
              if (_w3 && (_w3.type === "Program" || _w3.type === "File")) h--;else break;
            }
            return f.slice(0, h + 1);
          }
          function i(f, h, w) {
            var T = w.locStart,
              A = w.locEnd,
              S = f.node,
              B = h.node;
            if (S === B) return {
              startNode: S,
              endNode: B
            };
            var I = T(f.node);
            var _iterator29 = _createForOfIteratorHelper(u(h.parentNodes)),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var P = _step29.value;
                if (T(P) >= I) B = P;else break;
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
            var k = A(h.node);
            var _iterator30 = _createForOfIteratorHelper(u(f.parentNodes)),
              _step30;
            try {
              for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                var _P = _step30.value;
                if (A(_P) <= k) S = _P;else break;
              }
            } catch (err) {
              _iterator30.e(err);
            } finally {
              _iterator30.f();
            }
            return {
              startNode: S,
              endNode: B
            };
          }
          function o(f, h, w, T) {
            var A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],
              S = arguments.length > 5 ? arguments[5] : void 0,
              B = w.locStart,
              I = w.locEnd,
              k = B(f),
              P = I(f);
            if (!(h > P || h < k || S === "rangeEnd" && h === k || S === "rangeStart" && h === P)) {
              var _iterator31 = _createForOfIteratorHelper(s.getSortedChildNodes(f, w)),
                _step31;
              try {
                for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
                  var C = _step31.value;
                  var D = o(C, h, w, T, [f].concat(_toConsumableArray(A)), S);
                  if (D) return D;
                }
              } catch (err) {
                _iterator31.e(err);
              } finally {
                _iterator31.f();
              }
              if (!T || T(f, A[0])) return {
                node: f,
                parentNodes: A
              };
            }
          }
          function c(f, h) {
            return h !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var v = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]),
            m = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function d(f, h, w) {
            if (!h) return !1;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return c(h.type, w && w.type);
              case "json":
              case "json5":
              case "json-stringify":
                return v.has(h.type);
              case "graphql":
                return m.has(h.kind);
              case "vue":
                return h.tag !== "root";
            }
            return !1;
          }
          function p(f, h, w) {
            var T = h.rangeStart,
              A = h.rangeEnd,
              S = h.locStart,
              B = h.locEnd;
            t.ok(A > T);
            var I = f.slice(T, A).search(/\S/),
              k = I === -1;
            if (!k) for (T += I; A > T && !/\S/.test(f[A - 1]); --A) {
              ;
            }
            var P = o(w, T, h, function (F, l) {
                return d(h, F, l);
              }, [], "rangeStart"),
              C = k ? P : o(w, A, h, function (F) {
                return d(h, F);
              }, [], "rangeEnd");
            if (!P || !C) return {
              rangeStart: 0,
              rangeEnd: 0
            };
            var D, g;
            if (a(h)) {
              var F = r(P, C);
              D = F, g = F;
            } else {
              var _i11 = i(P, C, h);
              D = _i11.startNode;
              g = _i11.endNode;
            }
            return {
              rangeStart: Math.min(S(D), S(g)),
              rangeEnd: Math.max(B(D), B(g))
            };
          }
          n.exports = {
            calculateRange: p,
            findNodeAtOffset: o
          };
        }
      }),
      Sm = Z({
        "src/main/core.js": function srcMainCoreJs(e, n) {
          "use strict";

          re();
          var _aD = aD(),
            t = _aD.diffArrays,
            _Oe4 = Oe(),
            s = _Oe4.printer.printDocToString,
            a = _Oe4.debug.printDocToDebug,
            _Ue2 = Ue(),
            r = _Ue2.getAlignmentSize,
            _jn2 = jn(),
            u = _jn2.guessEndOfLine,
            i = _jn2.convertEndOfLineToChars,
            o = _jn2.countEndOfLineChars,
            c = _jn2.normalizeEndOfLine,
            v = Wa().normalize,
            m = vm(),
            d = et(),
            p = Gn(),
            f = Fm(),
            h = Am(),
            w = "\uFEFF",
            T = Symbol("cursor");
          function A(g, F, l) {
            var E = F.comments;
            return E && (delete F.comments, d.attach(E, F, g, l)), l[Symbol.for("comments")] = E || [], l[Symbol.for("tokens")] = F.tokens || [], l.originalText = g, E;
          }
          function S(g, F) {
            var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!g || g.trim().length === 0) return {
              formatted: "",
              cursorOffset: -1,
              comments: []
            };
            var _p$parse = p.parse(g, F),
              E = _p$parse.ast,
              y = _p$parse.text;
            if (F.cursorOffset >= 0) {
              var L = h.findNodeAtOffset(E, F.cursorOffset, F);
              L && L.node && (F.cursorNode = L.node);
            }
            var N = A(y, E, F),
              x = f(E, F, l),
              b = s(x, F);
            if (d.ensureAllCommentsPrinted(N), l > 0) {
              var _L11 = b.formatted.trim();
              b.cursorNodeStart !== void 0 && (b.cursorNodeStart -= b.formatted.indexOf(_L11)), b.formatted = _L11 + i(F.endOfLine);
            }
            if (F.cursorOffset >= 0) {
              var _L12, M, j, $, V;
              if (F.cursorNode && b.cursorNodeText ? (_L12 = F.locStart(F.cursorNode), M = y.slice(_L12, F.locEnd(F.cursorNode)), j = F.cursorOffset - _L12, $ = b.cursorNodeStart, V = b.cursorNodeText) : (_L12 = 0, M = y, j = F.cursorOffset, $ = 0, V = b.formatted), M === V) return {
                formatted: b.formatted,
                cursorOffset: $ + j,
                comments: N
              };
              var q = _toConsumableArray(M);
              q.splice(j, 0, T);
              var Y = _toConsumableArray(V),
                H = t(q, Y),
                R = $;
              var _iterator32 = _createForOfIteratorHelper(H),
                _step32;
              try {
                for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                  var Q = _step32.value;
                  if (Q.removed) {
                    if (Q.value.includes(T)) break;
                  } else R += Q.count;
                }
              } catch (err) {
                _iterator32.e(err);
              } finally {
                _iterator32.f();
              }
              return {
                formatted: b.formatted,
                cursorOffset: R,
                comments: N
              };
            }
            return {
              formatted: b.formatted,
              cursorOffset: -1,
              comments: N
            };
          }
          function B(g, F) {
            var _p$parse2 = p.parse(g, F),
              l = _p$parse2.ast,
              E = _p$parse2.text,
              _h$calculateRange = h.calculateRange(E, F, l),
              y = _h$calculateRange.rangeStart,
              N = _h$calculateRange.rangeEnd,
              x = E.slice(y, N),
              b = Math.min(y, E.lastIndexOf("\n", y) + 1),
              L = E.slice(b, y).match(/^\s*/)[0],
              M = r(L, F.tabWidth),
              j = S(x, Object.assign(Object.assign({}, F), {}, {
                rangeStart: 0,
                rangeEnd: Number.POSITIVE_INFINITY,
                cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1,
                endOfLine: "lf"
              }), M),
              $ = j.formatted.trimEnd(),
              V = F.cursorOffset;
            V > N ? V += $.length - x.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);
            var q = E.slice(0, y) + $ + E.slice(N);
            if (F.endOfLine !== "lf") {
              var Y = i(F.endOfLine);
              V >= 0 && Y === "\r\n" && (V += o(q.slice(0, V), "\n")), q = q.replace(/\n/g, Y);
            }
            return {
              formatted: q,
              cursorOffset: V,
              comments: j.comments
            };
          }
          function I(g, F, l) {
            return typeof F != "number" || Number.isNaN(F) || F < 0 || F > g.length ? l : F;
          }
          function k(g, F) {
            var l = F.cursorOffset,
              E = F.rangeStart,
              y = F.rangeEnd;
            return l = I(g, l, -1), E = I(g, E, 0), y = I(g, y, g.length), Object.assign(Object.assign({}, F), {}, {
              cursorOffset: l,
              rangeStart: E,
              rangeEnd: y
            });
          }
          function P(g, F) {
            var _k = k(g, F),
              l = _k.cursorOffset,
              E = _k.rangeStart,
              y = _k.rangeEnd,
              N = _k.endOfLine,
              x = g.charAt(0) === w;
            if (x && (g = g.slice(1), l--, E--, y--), N === "auto" && (N = u(g)), g.includes("\r")) {
              var b = function b(L) {
                return o(g.slice(0, Math.max(L, 0)), "\r\n");
              };
              l -= b(l), E -= b(E), y -= b(y), g = c(g);
            }
            return {
              hasBOM: x,
              text: g,
              options: k(g, Object.assign(Object.assign({}, F), {}, {
                cursorOffset: l,
                rangeStart: E,
                rangeEnd: y,
                endOfLine: N
              }))
            };
          }
          function C(g, F) {
            var l = p.resolveParser(F);
            return !l.hasPragma || l.hasPragma(g);
          }
          function D(g, F) {
            var _P2 = P(g, v(F)),
              l = _P2.hasBOM,
              E = _P2.text,
              y = _P2.options;
            if (y.rangeStart >= y.rangeEnd && E !== "" || y.requirePragma && !C(E, y)) return {
              formatted: g,
              cursorOffset: F.cursorOffset,
              comments: []
            };
            var N;
            return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C(E, y) && (E = y.printer.insertPragma(E)), N = S(E, y)), l && (N.formatted = w + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;
          }
          n.exports = {
            formatWithCursor: D,
            parse: function parse(g, F, l) {
              var _P3 = P(g, v(F)),
                E = _P3.text,
                y = _P3.options,
                N = p.parse(E, y);
              return l && (N.ast = m(N.ast, y)), N;
            },
            formatAST: function formatAST(g, F) {
              F = v(F);
              var l = f(g, F);
              return s(l, F);
            },
            formatDoc: function formatDoc(g, F) {
              return D(a(g), Object.assign(Object.assign({}, F), {}, {
                parser: "__js_expression"
              })).formatted;
            },
            printToDoc: function printToDoc(g, F) {
              F = v(F);
              var _p$parse3 = p.parse(g, F),
                l = _p$parse3.ast,
                E = _p$parse3.text;
              return A(E, l, F), f(l, F);
            },
            printDocToString: function printDocToString(g, F) {
              return s(g, v(F));
            }
          };
        }
      }),
      xm = Z({
        "src/common/util-shared.js": function srcCommonUtilSharedJs(e, n) {
          "use strict";

          re();
          var _Ue3 = Ue(),
            t = _Ue3.getMaxContinuousCount,
            s = _Ue3.getStringWidth,
            a = _Ue3.getAlignmentSize,
            r = _Ue3.getIndentSize,
            u = _Ue3.skip,
            i = _Ue3.skipWhitespace,
            o = _Ue3.skipSpaces,
            c = _Ue3.skipNewline,
            v = _Ue3.skipToLineEnd,
            m = _Ue3.skipEverythingButNewLine,
            d = _Ue3.skipInlineComment,
            p = _Ue3.skipTrailingComment,
            f = _Ue3.hasNewline,
            h = _Ue3.hasNewlineInRange,
            w = _Ue3.hasSpaces,
            T = _Ue3.isNextLineEmpty,
            A = _Ue3.isNextLineEmptyAfterIndex,
            S = _Ue3.isPreviousLineEmpty,
            B = _Ue3.getNextNonSpaceNonCommentCharacterIndex,
            I = _Ue3.makeString,
            k = _Ue3.addLeadingComment,
            P = _Ue3.addDanglingComment,
            C = _Ue3.addTrailingComment;
          n.exports = {
            getMaxContinuousCount: t,
            getStringWidth: s,
            getAlignmentSize: a,
            getIndentSize: r,
            skip: u,
            skipWhitespace: i,
            skipSpaces: o,
            skipNewline: c,
            skipToLineEnd: v,
            skipEverythingButNewLine: m,
            skipInlineComment: d,
            skipTrailingComment: p,
            hasNewline: f,
            hasNewlineInRange: h,
            hasSpaces: w,
            isNextLineEmpty: T,
            isNextLineEmptyAfterIndex: A,
            isPreviousLineEmpty: S,
            getNextNonSpaceNonCommentCharacterIndex: B,
            makeString: I,
            addLeadingComment: k,
            addDanglingComment: P,
            addTrailingComment: C
          };
        }
      }),
      Bt = Z({
        "src/utils/create-language.js": function srcUtilsCreateLanguageJs(e, n) {
          "use strict";

          re(), n.exports = function (t, s) {
            var a = t.languageId,
              r = kn(t, Zf);
            return Object.assign(Object.assign({
              linguistLanguageId: a
            }, r), s(t));
          };
        }
      }),
      bm = Z({
        "node_modules/esutils/lib/ast.js": function node_modulesEsutilsLibAstJs(e, n) {
          re(), function () {
            "use strict";

            function t(o) {
              if (o == null) return !1;
              switch (o.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return !0;
              }
              return !1;
            }
            function s(o) {
              if (o == null) return !1;
              switch (o.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return !0;
              }
              return !1;
            }
            function a(o) {
              if (o == null) return !1;
              switch (o.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return !0;
              }
              return !1;
            }
            function r(o) {
              return a(o) || o != null && o.type === "FunctionDeclaration";
            }
            function u(o) {
              switch (o.type) {
                case "IfStatement":
                  return o.alternate != null ? o.alternate : o.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return o.body;
              }
              return null;
            }
            function i(o) {
              var c;
              if (o.type !== "IfStatement" || o.alternate == null) return !1;
              c = o.consequent;
              do {
                if (c.type === "IfStatement" && c.alternate == null) return !0;
                c = u(c);
              } while (c);
              return !1;
            }
            n.exports = {
              isExpression: t,
              isStatement: a,
              isIterationStatement: s,
              isSourceElement: r,
              isProblematicIfStatement: i,
              trailingStatement: u
            };
          }();
        }
      }),
      $a = Z({
        "node_modules/esutils/lib/code.js": function node_modulesEsutilsLibCodeJs(e, n) {
          re(), function () {
            "use strict";

            var t, s, a, r, u, i;
            s = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
            }, t = {
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            function o(A) {
              return 48 <= A && A <= 57;
            }
            function c(A) {
              return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;
            }
            function v(A) {
              return A >= 48 && A <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function m(A) {
              return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && a.indexOf(A) >= 0;
            }
            function d(A) {
              return A === 10 || A === 13 || A === 8232 || A === 8233;
            }
            function p(A) {
              if (A <= 65535) return String.fromCharCode(A);
              var S = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296),
                B = String.fromCharCode((A - 65536) % 1024 + 56320);
              return S + B;
            }
            for (r = new Array(128), i = 0; i < 128; ++i) {
              r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            }
            for (u = new Array(128), i = 0; i < 128; ++i) {
              u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            }
            function f(A) {
              return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));
            }
            function h(A) {
              return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));
            }
            function w(A) {
              return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));
            }
            function T(A) {
              return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));
            }
            n.exports = {
              isDecimalDigit: o,
              isHexDigit: c,
              isOctalDigit: v,
              isWhiteSpace: m,
              isLineTerminator: d,
              isIdentifierStartES5: f,
              isIdentifierPartES5: h,
              isIdentifierStartES6: w,
              isIdentifierPartES6: T
            };
          }();
        }
      }),
      Tm = Z({
        "node_modules/esutils/lib/keyword.js": function node_modulesEsutilsLibKeywordJs(e, n) {
          re(), function () {
            "use strict";

            var t = $a();
            function s(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return !0;
                default:
                  return !1;
              }
            }
            function a(f, h) {
              return !h && f === "yield" ? !1 : r(f, h);
            }
            function r(f, h) {
              if (h && s(f)) return !0;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return !1;
              }
            }
            function u(f, h) {
              return f === "null" || f === "true" || f === "false" || a(f, h);
            }
            function i(f, h) {
              return f === "null" || f === "true" || f === "false" || r(f, h);
            }
            function o(f) {
              return f === "eval" || f === "arguments";
            }
            function c(f) {
              var h, w, T;
              if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T))) return !1;
              for (h = 1, w = f.length; h < w; ++h) {
                if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T)) return !1;
              }
              return !0;
            }
            function v(f, h) {
              return (f - 55296) * 1024 + (h - 56320) + 65536;
            }
            function m(f) {
              var h, w, T, A, S;
              if (f.length === 0) return !1;
              for (S = t.isIdentifierStartES6, h = 0, w = f.length; h < w; ++h) {
                if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {
                  if (++h, h >= w || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343))) return !1;
                  T = v(T, A);
                }
                if (!S(T)) return !1;
                S = t.isIdentifierPartES6;
              }
              return !0;
            }
            function d(f, h) {
              return c(f) && !u(f, h);
            }
            function p(f, h) {
              return m(f) && !i(f, h);
            }
            n.exports = {
              isKeywordES5: a,
              isKeywordES6: r,
              isReservedWordES5: u,
              isReservedWordES6: i,
              isRestrictedWord: o,
              isIdentifierNameES5: c,
              isIdentifierNameES6: m,
              isIdentifierES5: d,
              isIdentifierES6: p
            };
          }();
        }
      }),
      Bm = Z({
        "node_modules/esutils/lib/utils.js": function node_modulesEsutilsLibUtilsJs(e) {
          re(), function () {
            "use strict";

            e.ast = bm(), e.code = $a(), e.keyword = Tm();
          }();
        }
      }),
      It = Z({
        "src/language-js/utils/is-block-comment.js": function srcLanguageJsUtilsIsBlockCommentJs(e, n) {
          "use strict";

          re();
          var t = new Set(["Block", "CommentBlock", "MultiLine"]),
            s = function s(a) {
              return t.has(a == null ? void 0 : a.type);
            };
          n.exports = s;
        }
      }),
      Nm = Z({
        "src/language-js/utils/is-node-matches.js": function srcLanguageJsUtilsIsNodeMatchesJs(e, n) {
          "use strict";

          re();
          function t(a, r) {
            var u = r.split(".");
            for (var i = u.length - 1; i >= 0; i--) {
              var o = u[i];
              if (i === 0) return a.type === "Identifier" && a.name === o;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== o) return !1;
              a = a.object;
            }
          }
          function s(a, r) {
            return r.some(function (u) {
              return t(a, u);
            });
          }
          n.exports = s;
        }
      }),
      Ke = Z({
        "src/language-js/utils/index.js": function srcLanguageJsUtilsIndexJs(e, n) {
          "use strict";

          re();
          var t = Bm().keyword.isIdentifierNameES5,
            _Ue4 = Ue(),
            s = _Ue4.getLast,
            a = _Ue4.hasNewline,
            r = _Ue4.skipWhitespace,
            u = _Ue4.isNonEmptyArray,
            i = _Ue4.isNextLineEmptyAfterIndex,
            o = _Ue4.getStringWidth,
            _st = st(),
            c = _st.locStart,
            v = _st.locEnd,
            m = _st.hasSameLocStart,
            d = It(),
            p = Nm(),
            f = "(?:(?=.)\\s)",
            h = new RegExp("^".concat(f, "*:")),
            w = new RegExp("^".concat(f, "*::"));
          function T(O) {
            var fe, Te;
            return ((fe = O.extra) === null || fe === void 0 ? void 0 : fe.parenthesized) && d((Te = O.trailingComments) === null || Te === void 0 ? void 0 : Te[0]) && h.test(O.trailingComments[0].value);
          }
          function A(O) {
            var fe = O == null ? void 0 : O[0];
            return d(fe) && w.test(fe.value);
          }
          function S(O, fe) {
            if (!O || _typeof(O) != "object") return !1;
            if (Array.isArray(O)) return O.some(function ($e) {
              return S($e, fe);
            });
            var Te = fe(O);
            return typeof Te == "boolean" ? Te : Object.values(O).some(function ($e) {
              return S($e, fe);
            });
          }
          function B(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || ue(O) || De(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || O.type === "TSAsExpression" || O.type === "TSNonNullExpression";
          }
          function I(O) {
            var fe, Te, $e, Je, Ze, ut;
            return O.expressions ? O.expressions[0] : (fe = (Te = ($e = (Je = (Ze = (ut = O.left) !== null && ut !== void 0 ? ut : O.test) !== null && Ze !== void 0 ? Ze : O.callee) !== null && Je !== void 0 ? Je : O.object) !== null && $e !== void 0 ? $e : O.tag) !== null && Te !== void 0 ? Te : O.argument) !== null && fe !== void 0 ? fe : O.expression;
          }
          function k(O, fe) {
            if (fe.expressions) return ["expressions", 0];
            if (fe.left) return ["left"];
            if (fe.test) return ["test"];
            if (fe.object) return ["object"];
            if (fe.callee) return ["callee"];
            if (fe.tag) return ["tag"];
            if (fe.argument) return ["argument"];
            if (fe.expression) return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function P(O) {
            return O = new Set(O), function (fe) {
              return O.has(fe == null ? void 0 : fe.type);
            };
          }
          var C = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]),
            D = P(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function g(O) {
            var fe = O.getParentNode();
            return O.getName() === "declaration" && D(fe) ? fe : null;
          }
          var F = P(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function l(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function E(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && l(O.argument);
          }
          function y(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var N = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]),
            x = P(["FunctionExpression", "ArrowFunctionExpression"]);
          function b(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function L(O) {
            return ue(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M = P(["JSXElement", "JSXFragment"]);
          function j(O, fe) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx") return !1;
            var Te = fe.getNode();
            if (!Te.expression || !M(Te.expression)) return !1;
            var $e = fe.getParentNode();
            return $e.type === "Program" && $e.body.length === 1;
          }
          function $(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function V(O) {
            return $(O) || m(O, O.value);
          }
          function q(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !V(O);
          }
          function Y(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !m(O, O.typeAnnotation);
          }
          var H = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function R(O) {
            return De(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Q = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ee(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Q.has(O.type)) : !1;
          }
          function te(O) {
            var fe = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && fe.test(O.callee.name) && O.arguments.length === 1;
          }
          var oe = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return p(O, oe);
          }
          function X(O, fe) {
            if (O.type !== "CallExpression") return !1;
            if (O.arguments.length === 1) {
              if (L(O) && fe && X(fe)) return x(O.arguments[0]);
              if (te(O)) return L(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || y(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !l(O.arguments[2]) ? !1 : (O.arguments.length === 2 ? x(O.arguments[1]) : b(O.arguments[1]) && Se(O.arguments[1]).length <= 1) || L(O.arguments[1]);
            return !1;
          }
          var ue = P(["CallExpression", "OptionalCallExpression"]),
            De = P(["MemberExpression", "OptionalMemberExpression"]);
          function ie(O) {
            var fe = "expressions";
            O.type === "TSTemplateLiteralType" && (fe = "types");
            var Te = O[fe];
            return Te.length === 0 ? !1 : Te.every(function ($e) {
              if (se($e)) return !1;
              if ($e.type === "Identifier" || $e.type === "ThisExpression") return !0;
              if (De($e)) {
                var Je = $e;
                for (; De(Je);) {
                  if (Je.property.type !== "Identifier" && Je.property.type !== "Literal" && Je.property.type !== "StringLiteral" && Je.property.type !== "NumericLiteral" || (Je = Je.object, se(Je))) return !1;
                }
                return Je.type === "Identifier" || Je.type === "ThisExpression";
              }
              return !1;
            });
          }
          function G(O, fe) {
            return O === "+" || O === "-" ? O + fe : fe;
          }
          function z(O, fe) {
            var Te = c(fe),
              $e = r(O, v(fe));
            return $e !== !1 && O.slice(Te, Te + 2) === "/*" && O.slice($e, $e + 2) === "*/";
          }
          function U(O, fe) {
            return M(fe) ? Re(fe) : se(fe, Le.Leading, function (Te) {
              return a(O, v(Te));
            });
          }
          function le(O, fe) {
            return fe.parser !== "json" && y(O.key) && ve(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(fe.parser === "babel-ts" && O.type === "ClassProperty" || fe.parser === "typescript" && O.type === "PropertyDefinition") || ge(O.key.value) && String(Number(O.key.value)) === O.key.value && (fe.parser === "babel" || fe.parser === "acorn" || fe.parser === "espree" || fe.parser === "meriyah" || fe.parser === "__babel_estree"));
          }
          function ge(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function Ae(O, fe) {
            var Te = /^[fx]?(?:describe|it|test)$/;
            return fe.type === "TaggedTemplateExpression" && fe.quasi === O && fe.tag.type === "MemberExpression" && fe.tag.property.type === "Identifier" && fe.tag.property.name === "each" && (fe.tag.object.type === "Identifier" && Te.test(fe.tag.object.name) || fe.tag.object.type === "MemberExpression" && fe.tag.object.property.type === "Identifier" && (fe.tag.object.property.name === "only" || fe.tag.object.property.name === "skip") && fe.tag.object.object.type === "Identifier" && Te.test(fe.tag.object.object.name));
          }
          function Ne(O) {
            return O.quasis.some(function (fe) {
              return fe.value.raw.includes("\n");
            });
          }
          function ke(O, fe) {
            return (O.type === "TemplateLiteral" && Ne(O) || O.type === "TaggedTemplateExpression" && Ne(O.quasi)) && !a(fe, c(O), {
              backwards: !0
            });
          }
          function ce(O) {
            if (!se(O)) return !1;
            var fe = s(He(O, Le.Dangling));
            return fe && !d(fe);
          }
          function pe(O) {
            if (O.length <= 1) return !1;
            var fe = 0;
            var _iterator33 = _createForOfIteratorHelper(O),
              _step33;
            try {
              for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                var Te = _step33.value;
                if (x(Te)) {
                  if (fe += 1, fe > 1) return !0;
                } else if (ue(Te)) {
                  var _iterator34 = _createForOfIteratorHelper(Te.arguments),
                    _step34;
                  try {
                    for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                      var $e = _step34.value;
                      if (x($e)) return !0;
                    }
                  } catch (err) {
                    _iterator34.e(err);
                  } finally {
                    _iterator34.f();
                  }
                }
              }
            } catch (err) {
              _iterator33.e(err);
            } finally {
              _iterator33.f();
            }
            return !1;
          }
          function de(O) {
            var fe = O.getValue(),
              Te = O.getParentNode();
            return ue(fe) && ue(Te) && Te.callee === fe && fe.arguments.length > Te.arguments.length && Te.arguments.length > 0;
          }
          function ae(O, fe) {
            if (fe >= 2) return !1;
            var Te = function Te(Je) {
                return ae(Je, fe + 1);
              },
              $e = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            return $e && o($e) > 5 ? !1 : O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import" ? !0 : O.type === "TemplateLiteral" ? O.quasis.every(function (Je) {
              return !Je.value.raw.includes("\n");
            }) && O.expressions.every(Te) : O.type === "ObjectExpression" ? O.properties.every(function (Je) {
              return !Je.computed && (Je.shorthand || Je.value && Te(Je.value));
            }) : O.type === "ArrayExpression" ? O.elements.every(function (Je) {
              return Je === null || Te(Je);
            }) : ze(O) ? (O.type === "ImportExpression" || ae(O.callee, fe)) && Xe(O).every(Te) : De(O) ? ae(O.object, fe) && ae(O.property, fe) : O.type === "UnaryExpression" && (O.operator === "!" || O.operator === "-") ? ae(O.argument, fe) : O.type === "TSNonNullExpression" ? ae(O.expression, fe) : !1;
          }
          function ve(O) {
            var fe, Te;
            return (fe = (Te = O.extra) === null || Te === void 0 ? void 0 : Te.raw) !== null && fe !== void 0 ? fe : O.raw;
          }
          function K(O) {
            return O;
          }
          function he(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function ye(O) {
            var fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && fe === "es5" || O.trailingComma === "all" && (fe === "all" || fe === "es5");
          }
          function Ce(O, fe) {
            switch (O = Ee(O), O.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return fe;
              case "ObjectExpression":
                return !0;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return Ce(O.object, fe);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? !1 : Ce(O.tag, fe);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? !1 : Ce(O.callee, fe);
              case "ConditionalExpression":
                return Ce(O.test, fe);
              case "UpdateExpression":
                return !O.prefix && Ce(O.argument, fe);
              case "BindExpression":
                return O.object && Ce(O.object, fe);
              case "SequenceExpression":
                return Ce(O.expressions[0], fe);
              case "TSAsExpression":
              case "TSNonNullExpression":
                return Ce(O.expression, fe);
              default:
                return !1;
            }
          }
          var Ie = {
              "==": !0,
              "!=": !0,
              "===": !0,
              "!==": !0
            },
            Fe = {
              "*": !0,
              "/": !0,
              "%": !0
            },
            me = {
              ">>": !0,
              ">>>": !0,
              "<<": !0
            };
          function _(O, fe) {
            return !(ne(fe) !== ne(O) || O === "**" || Ie[O] && Ie[fe] || fe === "%" && Fe[O] || O === "%" && Fe[fe] || fe !== O && Fe[fe] && Fe[O] || me[O] && me[fe]);
          }
          var J = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap(function (O, fe) {
            return O.map(function (Te) {
              return [Te, fe];
            });
          }));
          function ne(O) {
            return J.get(O);
          }
          function Ee(O) {
            for (; O.left;) {
              O = O.left;
            }
            return O;
          }
          function We(O) {
            return Boolean(me[O]) || O === "|" || O === "^" || O === "&";
          }
          function Be(O) {
            var fe;
            if (O.rest) return !0;
            var Te = Se(O);
            return ((fe = s(Te)) === null || fe === void 0 ? void 0 : fe.type) === "RestElement";
          }
          var Pe = new WeakMap();
          function Se(O) {
            if (Pe.has(O)) return Pe.get(O);
            var fe = [];
            return O.this && fe.push(O.this), Array.isArray(O.parameters) ? fe.push.apply(fe, _toConsumableArray(O.parameters)) : Array.isArray(O.params) && fe.push.apply(fe, _toConsumableArray(O.params)), O.rest && fe.push(O.rest), Pe.set(O, fe), fe;
          }
          function Qe(O, fe) {
            var Te = O.getValue(),
              $e = 0,
              Je = function Je(Ze) {
                return fe(Ze, $e++);
              };
            Te.this && O.call(Je, "this"), Array.isArray(Te.parameters) ? O.each(Je, "parameters") : Array.isArray(Te.params) && O.each(Je, "params"), Te.rest && O.call(Je, "rest");
          }
          var xe = new WeakMap();
          function Xe(O) {
            if (xe.has(O)) return xe.get(O);
            var fe = O.arguments;
            return O.type === "ImportExpression" && (fe = [O.source], O.attributes && fe.push(O.attributes)), xe.set(O, fe), fe;
          }
          function _e(O, fe) {
            var Te = O.getValue();
            Te.type === "ImportExpression" ? (O.call(function ($e) {
              return fe($e, 0);
            }, "source"), Te.attributes && O.call(function ($e) {
              return fe($e, 1);
            }, "attributes")) : O.each(fe, "arguments");
          }
          function je(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Re(O) {
            return O && (O.prettierIgnore || se(O, Le.PrettierIgnore));
          }
          function be(O) {
            var fe = O.getValue();
            return Re(fe);
          }
          var Le = {
              Leading: 1 << 1,
              Trailing: 1 << 2,
              Dangling: 1 << 3,
              Block: 1 << 4,
              Line: 1 << 5,
              PrettierIgnore: 1 << 6,
              First: 1 << 7,
              Last: 1 << 8
            },
            qe = function qe(O, fe) {
              if (typeof O == "function" && (fe = O, O = 0), O || fe) return function (Te, $e, Je) {
                return !(O & Le.Leading && !Te.leading || O & Le.Trailing && !Te.trailing || O & Le.Dangling && (Te.leading || Te.trailing) || O & Le.Block && !d(Te) || O & Le.Line && !C(Te) || O & Le.First && $e !== 0 || O & Le.Last && $e !== Je.length - 1 || O & Le.PrettierIgnore && !je(Te) || fe && !fe(Te));
              };
            };
          function se(O, fe, Te) {
            if (!u(O == null ? void 0 : O.comments)) return !1;
            var $e = qe(fe, Te);
            return $e ? O.comments.some($e) : !0;
          }
          function He(O, fe, Te) {
            if (!Array.isArray(O == null ? void 0 : O.comments)) return [];
            var $e = qe(fe, Te);
            return $e ? O.comments.filter($e) : O.comments;
          }
          var Me = function Me(O, fe) {
            var Te = fe.originalText;
            return i(Te, v(O));
          };
          function ze(O) {
            return ue(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function nt(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function tt(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var pt = Symbol("ifWithoutBlockAndSameLineComment");
          n.exports = {
            getFunctionParameters: Se,
            iterateFunctionParametersPath: Qe,
            getCallArguments: Xe,
            iterateCallArgumentsPath: _e,
            hasRestParameter: Be,
            getLeftSide: I,
            getLeftSidePathName: k,
            getParentExportDeclaration: g,
            getTypeScriptMappedTypeModifier: G,
            hasFlowAnnotationComment: A,
            hasFlowShorthandAnnotationComment: T,
            hasLeadingOwnLineComment: U,
            hasNakedLeftSide: B,
            hasNode: S,
            hasIgnoreComment: be,
            hasNodeIgnoreComment: Re,
            identity: K,
            isBinaryish: H,
            isCallLikeExpression: ze,
            isEnabledHackPipeline: tt,
            isLineComment: C,
            isPrettierIgnoreComment: je,
            isCallExpression: ue,
            isMemberExpression: De,
            isExportDeclaration: D,
            isFlowAnnotationComment: z,
            isFunctionCompositionArgs: pe,
            isFunctionNotation: V,
            isFunctionOrArrowExpression: x,
            isGetterOrSetter: $,
            isJestEachTemplateLiteral: Ae,
            isJsxNode: M,
            isLiteral: F,
            isLongCurriedCallExpression: de,
            isSimpleCallArgument: ae,
            isMemberish: R,
            isNumericLiteral: l,
            isSignedNumericLiteral: E,
            isObjectProperty: nt,
            isObjectType: N,
            isObjectTypePropertyAFunction: q,
            isSimpleType: ee,
            isSimpleNumber: ge,
            isSimpleTemplateLiteral: ie,
            isStringLiteral: y,
            isStringPropSafeToUnquote: le,
            isTemplateOnItsOwnLine: ke,
            isTestCall: X,
            isTheOnlyJsxElementInMarkdown: j,
            isTSXFile: he,
            isTypeAnnotationAFunction: Y,
            isNextLineEmpty: Me,
            needsHardlineAfterDanglingComment: ce,
            rawText: ve,
            shouldPrintComma: ye,
            isBitwiseOperator: We,
            shouldFlatten: _,
            startsWithNoLookaheadToken: Ce,
            getPrecedence: ne,
            hasComment: se,
            getComments: He,
            CommentCheckFlags: Le,
            markerForIfWithoutBlockAndSameLineComment: pt
          };
        }
      }),
      Lt = Z({
        "src/language-js/print/template-literal.js": function srcLanguageJsPrintTemplateLiteralJs(e, n) {
          "use strict";

          re();
          var t = it(),
            _Ue5 = Ue(),
            s = _Ue5.getStringWidth,
            a = _Ue5.getIndentSize,
            _Oe5 = Oe(),
            _Oe5$builders = _Oe5.builders,
            r = _Oe5$builders.join,
            u = _Oe5$builders.hardline,
            i = _Oe5$builders.softline,
            o = _Oe5$builders.group,
            c = _Oe5$builders.indent,
            v = _Oe5$builders.align,
            m = _Oe5$builders.lineSuffixBoundary,
            d = _Oe5$builders.addAlignmentToDoc,
            p = _Oe5.printer.printDocToString,
            f = _Oe5.utils.mapDoc,
            _Ke = Ke(),
            h = _Ke.isBinaryish,
            w = _Ke.isJestEachTemplateLiteral,
            T = _Ke.isSimpleTemplateLiteral,
            A = _Ke.hasComment,
            S = _Ke.isMemberExpression;
          function B(g, F, l) {
            var E = g.getValue();
            if (E.type === "TemplateLiteral" && w(E, g.getParentNode())) {
              var M = I(g, l, F);
              if (M) return M;
            }
            var N = "expressions";
            E.type === "TSTemplateLiteralType" && (N = "types");
            var x = [],
              b = g.map(F, N),
              L = T(E);
            return L && (b = b.map(function (M) {
              return p(M, Object.assign(Object.assign({}, l), {}, {
                printWidth: Number.POSITIVE_INFINITY
              })).formatted;
            })), x.push(m, "`"), g.each(function (M) {
              var j = M.getName();
              if (x.push(F()), j < b.length) {
                var $ = l.tabWidth,
                  V = M.getValue(),
                  q = a(V.value.raw, $),
                  Y = b[j];
                if (!L) {
                  var R = E[N][j];
                  (A(R) || S(R) || R.type === "ConditionalExpression" || R.type === "SequenceExpression" || R.type === "TSAsExpression" || h(R)) && (Y = [c([i, Y]), i]);
                }
                var H = q === 0 && V.value.raw.endsWith("\n") ? v(Number.NEGATIVE_INFINITY, Y) : d(Y, q, $);
                x.push(o(["${", H, m, "}"]));
              }
            }, "quasis"), x.push("`"), x;
          }
          function I(g, F, l) {
            var E = g.getNode(),
              y = E.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (y.length > 1 || y.some(function (N) {
              return N.length > 0;
            })) {
              F.__inJestEach = !0;
              var N = g.map(l, "expressions");
              F.__inJestEach = !1;
              var x = [],
                b = N.map(function (V) {
                  return "${" + p(V, Object.assign(Object.assign({}, F), {}, {
                    printWidth: Number.POSITIVE_INFINITY,
                    endOfLine: "lf"
                  })).formatted + "}";
                }),
                L = [{
                  hasLineBreak: !1,
                  cells: []
                }];
              for (var V = 1; V < E.quasis.length; V++) {
                var q = t(L),
                  Y = b[V - 1];
                q.cells.push(Y), Y.includes("\n") && (q.hasLineBreak = !0), E.quasis[V].value.raw.includes("\n") && L.push({
                  hasLineBreak: !1,
                  cells: []
                });
              }
              var M = Math.max.apply(Math, [y.length].concat(_toConsumableArray(L.map(function (V) {
                  return V.cells.length;
                })))),
                j = Array.from({
                  length: M
                }).fill(0),
                $ = [{
                  cells: y
                }].concat(_toConsumableArray(L.filter(function (V) {
                  return V.cells.length > 0;
                })));
              var _iterator35 = _createForOfIteratorHelper($.filter(function (q) {
                  return !q.hasLineBreak;
                })),
                _step35;
              try {
                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                  var _V2 = _step35.value.cells;
                  var _iterator36 = _createForOfIteratorHelper(_V2.entries()),
                    _step36;
                  try {
                    for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                      var _step36$value = _slicedToArray(_step36.value, 2),
                        _q2 = _step36$value[0],
                        _Y = _step36$value[1];
                      j[_q2] = Math.max(j[_q2], s(_Y));
                    }
                  } catch (err) {
                    _iterator36.e(err);
                  } finally {
                    _iterator36.f();
                  }
                }
              } catch (err) {
                _iterator35.e(err);
              } finally {
                _iterator35.f();
              }
              return x.push(m, "`", c([u, r(u, $.map(function (V) {
                return r(" | ", V.cells.map(function (q, Y) {
                  return V.hasLineBreak ? q : q + " ".repeat(j[Y] - s(q));
                }));
              }))]), u, "`"), x;
            }
          }
          function k(g, F) {
            var l = g.getValue(),
              E = F();
            return A(l) && (E = o([c([i, E]), i])), ["${", E, m, "}"];
          }
          function P(g, F) {
            return g.map(function (l) {
              return k(l, F);
            }, "expressions");
          }
          function C(g, F) {
            return f(g, function (l) {
              return typeof l == "string" ? F ? l.replace(/(\\*)`/g, "$1$1\\`") : D(l) : l;
            });
          }
          function D(g) {
            return g.replace(/([\\`]|\${)/g, "\\$1");
          }
          n.exports = {
            printTemplateLiteral: B,
            printTemplateExpressions: P,
            escapeTemplateCharacters: C,
            uncookTemplateElementValue: D
          };
        }
      }),
      wm = Z({
        "src/language-js/embed/markdown.js": function srcLanguageJsEmbedMarkdownJs(e, n) {
          "use strict";

          re();
          var _Oe6 = Oe(),
            _Oe6$builders = _Oe6.builders,
            t = _Oe6$builders.indent,
            s = _Oe6$builders.softline,
            a = _Oe6$builders.literalline,
            r = _Oe6$builders.dedentToRoot,
            _Lt = Lt(),
            u = _Lt.escapeTemplateCharacters;
          function i(c, v, m) {
            var p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, function (T, A) {
                return "\\".repeat(A.length / 2) + "`";
              }),
              f = o(p),
              h = f !== "";
            h && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
            var w = u(m(p, {
              parser: "markdown",
              __inJsTemplate: !0
            }, {
              stripTrailingHardline: !0
            }), !0);
            return ["`", h ? t([s, w]) : [a, r(w)], s, "`"];
          }
          function o(c) {
            var v = c.match(/^([^\S\n]*)\S/m);
            return v === null ? "" : v[1];
          }
          n.exports = i;
        }
      }),
      _m = Z({
        "src/language-js/embed/css.js": function srcLanguageJsEmbedCssJs(e, n) {
          "use strict";

          re();
          var _Ue6 = Ue(),
            t = _Ue6.isNonEmptyArray,
            _Oe7 = Oe(),
            _Oe7$builders = _Oe7.builders,
            s = _Oe7$builders.indent,
            a = _Oe7$builders.hardline,
            r = _Oe7$builders.softline,
            _Oe7$utils = _Oe7.utils,
            u = _Oe7$utils.mapDoc,
            i = _Oe7$utils.replaceEndOfLine,
            o = _Oe7$utils.cleanDoc,
            _Lt2 = Lt(),
            c = _Lt2.printTemplateExpressions;
          function v(p, f, h) {
            var w = p.getValue(),
              T = w.quasis.map(function (k) {
                return k.value.raw;
              }),
              A = 0,
              S = T.reduce(function (k, P, C) {
                return C === 0 ? P : k + "@prettier-placeholder-" + A++ + "-id" + P;
              }, ""),
              B = h(S, {
                parser: "scss"
              }, {
                stripTrailingHardline: !0
              }),
              I = c(p, f);
            return m(B, w, I);
          }
          function m(p, f, h) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return "``";
            var T = d(p, h);
            if (!T) throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, T]), r, "`"];
          }
          function d(p, f) {
            if (!t(f)) return p;
            var h = 0,
              w = u(o(p), function (T) {
                return typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map(function (A, S) {
                  return S % 2 === 0 ? i(A) : (h++, f[A]);
                });
              });
            return f.length === h ? w : null;
          }
          n.exports = v;
        }
      }),
      Pm = Z({
        "src/language-js/embed/graphql.js": function srcLanguageJsEmbedGraphqlJs(e, n) {
          "use strict";

          re();
          var _Oe8 = Oe(),
            _Oe8$builders = _Oe8.builders,
            t = _Oe8$builders.indent,
            s = _Oe8$builders.join,
            a = _Oe8$builders.hardline,
            _Lt3 = Lt(),
            r = _Lt3.escapeTemplateCharacters,
            u = _Lt3.printTemplateExpressions;
          function i(c, v, m) {
            var d = c.getValue(),
              p = d.quasis.length;
            if (p === 1 && d.quasis[0].value.raw.trim() === "") return "``";
            var f = u(c, v),
              h = [];
            for (var _w4 = 0; _w4 < p; _w4++) {
              var T = d.quasis[_w4],
                A = _w4 === 0,
                S = _w4 === p - 1,
                B = T.value.cooked,
                I = B.split("\n"),
                k = I.length,
                P = f[_w4],
                C = k > 2 && I[0].trim() === "" && I[1].trim() === "",
                D = k > 2 && I[k - 1].trim() === "" && I[k - 2].trim() === "",
                g = I.every(function (l) {
                  return /^\s*(?:#[^\n\r]*)?$/.test(l);
                });
              if (!S && /#[^\n\r]*$/.test(I[k - 1])) return null;
              var F = null;
              g ? F = o(I) : F = m(B, {
                parser: "graphql"
              }, {
                stripTrailingHardline: !0
              }), F ? (F = r(F, !1), !A && C && h.push(""), h.push(F), !S && D && h.push("")) : !A && !S && C && h.push(""), P && h.push(P);
            }
            return ["`", t([a, s(a, h)]), a, "`"];
          }
          function o(c) {
            var v = [],
              m = !1,
              d = c.map(function (p) {
                return p.trim();
              });
            var _iterator37 = _createForOfIteratorHelper(d.entries()),
              _step37;
            try {
              for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
                var _step37$value = _slicedToArray(_step37.value, 2),
                  p = _step37$value[0],
                  f = _step37$value[1];
                f !== "" && (d[p - 1] === "" && m ? v.push([a, f]) : v.push(f), m = !0);
              }
            } catch (err) {
              _iterator37.e(err);
            } finally {
              _iterator37.f();
            }
            return v.length === 0 ? null : s(a, v);
          }
          n.exports = i;
        }
      }),
      km = Z({
        "src/language-js/embed/html.js": function srcLanguageJsEmbedHtmlJs(e, n) {
          "use strict";

          re();
          var _Oe9 = Oe(),
            _Oe9$builders = _Oe9.builders,
            t = _Oe9$builders.indent,
            s = _Oe9$builders.line,
            a = _Oe9$builders.hardline,
            r = _Oe9$builders.group,
            u = _Oe9.utils.mapDoc,
            _Lt4 = Lt(),
            i = _Lt4.printTemplateExpressions,
            o = _Lt4.uncookTemplateElementValue,
            c = 0;
          function v(m, d, p, f, h) {
            var w = h.parser,
              T = m.getValue(),
              A = c;
            c = c + 1 >>> 0;
            var S = function S(E) {
                return "PRETTIER_HTML_PLACEHOLDER_".concat(E, "_").concat(A, "_IN_JS");
              },
              B = T.quasis.map(function (E, y, N) {
                return y === N.length - 1 ? E.value.cooked : E.value.cooked + S(y);
              }).join(""),
              I = i(m, d);
            if (I.length === 0 && B.trim().length === 0) return "``";
            var k = new RegExp(S("(\\d+)"), "g"),
              P = 0,
              C = p(B, {
                parser: w,
                __onHtmlRoot: function __onHtmlRoot(E) {
                  P = E.children.length;
                }
              }, {
                stripTrailingHardline: !0
              }),
              D = u(C, function (E) {
                if (typeof E != "string") return E;
                var y = [],
                  N = E.split(k);
                for (var x = 0; x < N.length; x++) {
                  var b = N[x];
                  if (x % 2 === 0) {
                    b && (b = o(b), f.__embeddedInHtml && (b = b.replace(/<\/(script)\b/gi, "<\\/$1")), y.push(b));
                    continue;
                  }
                  var L = Number(b);
                  y.push(I[L]);
                }
                return y;
              }),
              g = /^\s/.test(B) ? " " : "",
              F = /\s$/.test(B) ? " " : "",
              l = f.htmlWhitespaceSensitivity === "ignore" ? a : g && F ? s : null;
            return r(l ? ["`", t([l, r(D)]), l, "`"] : ["`", g, P > 1 ? t(r(D)) : r(D), F, "`"]);
          }
          n.exports = v;
        }
      }),
      Im = Z({
        "src/language-js/embed.js": function srcLanguageJsEmbedJs(e, n) {
          "use strict";

          re();
          var _Ke2 = Ke(),
            t = _Ke2.hasComment,
            s = _Ke2.CommentCheckFlags,
            a = _Ke2.isObjectProperty,
            r = wm(),
            u = _m(),
            i = Pm(),
            o = km();
          function c(C) {
            if (d(C) || w(C) || T(C) || p(C)) return "css";
            if (B(C)) return "graphql";
            if (k(C)) return "html";
            if (f(C)) return "angular";
            if (m(C)) return "markdown";
          }
          function v(C, D, g, F) {
            var l = C.getValue();
            if (l.type !== "TemplateLiteral" || P(l)) return;
            var E = c(C);
            if (!!E) {
              if (E === "markdown") return r(C, D, g);
              if (E === "css") return u(C, D, g);
              if (E === "graphql") return i(C, D, g);
              if (E === "html" || E === "angular") return o(C, D, g, F, {
                parser: E
              });
            }
          }
          function m(C) {
            var D = C.getValue(),
              g = C.getParentNode();
            return g && g.type === "TaggedTemplateExpression" && D.quasis.length === 1 && g.tag.type === "Identifier" && (g.tag.name === "md" || g.tag.name === "markdown");
          }
          function d(C) {
            var D = C.getValue(),
              g = C.getParentNode(),
              F = C.getParentNode(1);
            return F && D.quasis && g.type === "JSXExpressionContainer" && F.type === "JSXElement" && F.openingElement.name.name === "style" && F.openingElement.attributes.some(function (l) {
              return l.name.name === "jsx";
            }) || g && g.type === "TaggedTemplateExpression" && g.tag.type === "Identifier" && g.tag.name === "css" || g && g.type === "TaggedTemplateExpression" && g.tag.type === "MemberExpression" && g.tag.object.name === "css" && (g.tag.property.name === "global" || g.tag.property.name === "resolve");
          }
          function p(C) {
            return C.match.apply(C, [function (D) {
              return D.type === "TemplateLiteral";
            }, function (D, g) {
              return D.type === "ArrayExpression" && g === "elements";
            }, function (D, g) {
              return a(D) && D.key.type === "Identifier" && D.key.name === "styles" && g === "value";
            }].concat(h));
          }
          function f(C) {
            return C.match.apply(C, [function (D) {
              return D.type === "TemplateLiteral";
            }, function (D, g) {
              return a(D) && D.key.type === "Identifier" && D.key.name === "template" && g === "value";
            }].concat(h));
          }
          var h = [function (C, D) {
            return C.type === "ObjectExpression" && D === "properties";
          }, function (C, D) {
            return C.type === "CallExpression" && C.callee.type === "Identifier" && C.callee.name === "Component" && D === "arguments";
          }, function (C, D) {
            return C.type === "Decorator" && D === "expression";
          }];
          function w(C) {
            var D = C.getParentNode();
            if (!D || D.type !== "TaggedTemplateExpression") return !1;
            var g = D.tag.type === "ParenthesizedExpression" ? D.tag.expression : D.tag;
            switch (g.type) {
              case "MemberExpression":
                return A(g.object) || S(g);
              case "CallExpression":
                return A(g.callee) || g.callee.type === "MemberExpression" && (g.callee.object.type === "MemberExpression" && (A(g.callee.object.object) || S(g.callee.object)) || g.callee.object.type === "CallExpression" && A(g.callee.object.callee));
              case "Identifier":
                return g.name === "css";
              default:
                return !1;
            }
          }
          function T(C) {
            var D = C.getParentNode(),
              g = C.getParentNode(1);
            return g && D.type === "JSXExpressionContainer" && g.type === "JSXAttribute" && g.name.type === "JSXIdentifier" && g.name.name === "css";
          }
          function A(C) {
            return C.type === "Identifier" && C.name === "styled";
          }
          function S(C) {
            return /^[A-Z]/.test(C.object.name) && C.property.name === "extend";
          }
          function B(C) {
            var D = C.getValue(),
              g = C.getParentNode();
            return I(D, "GraphQL") || g && (g.type === "TaggedTemplateExpression" && (g.tag.type === "MemberExpression" && g.tag.object.name === "graphql" && g.tag.property.name === "experimental" || g.tag.type === "Identifier" && (g.tag.name === "gql" || g.tag.name === "graphql")) || g.type === "CallExpression" && g.callee.type === "Identifier" && g.callee.name === "graphql");
          }
          function I(C, D) {
            return t(C, s.Block | s.Leading, function (g) {
              var F = g.value;
              return F === " ".concat(D, " ");
            });
          }
          function k(C) {
            return I(C.getValue(), "HTML") || C.match(function (D) {
              return D.type === "TemplateLiteral";
            }, function (D, g) {
              return D.type === "TaggedTemplateExpression" && D.tag.type === "Identifier" && D.tag.name === "html" && g === "quasi";
            });
          }
          function P(C) {
            var D = C.quasis;
            return D.some(function (g) {
              var F = g.value.cooked;
              return F === null;
            });
          }
          n.exports = v;
        }
      }),
      Lm = Z({
        "src/language-js/clean.js": function srcLanguageJsCleanJs(e, n) {
          "use strict";

          re();
          var t = It(),
            s = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]),
            a = function a(u) {
              var _iterator38 = _createForOfIteratorHelper(u.quasis),
                _step38;
              try {
                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                  var i = _step38.value;
                  delete i.value;
                }
              } catch (err) {
                _iterator38.e(err);
              } finally {
                _iterator38.f();
              }
            };
          function r(u, i, o) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ") return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && _typeof(u.key) == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some(function (m) {
              return m.name.name === "jsx";
            })) {
              var _iterator39 = _createForOfIteratorHelper(i.children),
                _step39;
              try {
                for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                  var _step39$value = _step39.value,
                    m = _step39$value.type,
                    d = _step39$value.expression;
                  m === "JSXExpressionContainer" && d.type === "TemplateLiteral" && a(d);
                }
              } catch (err) {
                _iterator39.e(err);
              } finally {
                _iterator39.f();
              }
            }
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            var c = u.expression || u.callee;
            if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
              var _m4 = u.expression.arguments[0].properties;
              var _iterator40 = _createForOfIteratorHelper(i.expression.arguments[0].properties.entries()),
                _step40;
              try {
                for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                  var _step40$value = _slicedToArray(_step40.value, 2),
                    _d2 = _step40$value[0],
                    p = _step40$value[1];
                  switch (_m4[_d2].key.name) {
                    case "styles":
                      p.value.type === "ArrayExpression" && a(p.value.elements[0]);
                      break;
                    case "template":
                      p.value.type === "TemplateLiteral" && a(p.value);
                      break;
                  }
                }
              } catch (err) {
                _iterator40.e(err);
              } finally {
                _iterator40.f();
              }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var v;
              (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some(function (d) {
                return t(d) && ["GraphQL", "HTML"].some(function (p) {
                  return d.value === " ".concat(p, " ");
                });
              })) || o.type === "CallExpression" && o.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1) return i.types[0];
          }
          r.ignoredProperties = s, n.exports = r;
        }
      }),
      Ha = {};
    Ut(Ha, {
      EOL: function EOL() {
        return Pn;
      },
      arch: function arch() {
        return jm;
      },
      cpus: function cpus() {
        return Ya;
      },
      default: function _default() {
        return ro;
      },
      endianness: function endianness() {
        return Ga;
      },
      freemem: function freemem() {
        return Xa;
      },
      getNetworkInterfaces: function getNetworkInterfaces() {
        return to;
      },
      hostname: function hostname() {
        return Ja;
      },
      loadavg: function loadavg() {
        return Ua;
      },
      networkInterfaces: function networkInterfaces() {
        return eo;
      },
      platform: function platform() {
        return Om;
      },
      release: function release() {
        return Za;
      },
      tmpDir: function tmpDir() {
        return wn;
      },
      tmpdir: function tmpdir() {
        return _n;
      },
      totalmem: function totalmem() {
        return Ka;
      },
      type: function type() {
        return Qa;
      },
      uptime: function uptime() {
        return za;
      }
    });
    function Ga() {
      if (_typeof(Sr) > "u") {
        var e = new ArrayBuffer(2),
          n = new Uint8Array(e),
          t = new Uint16Array(e);
        if (n[0] = 1, n[1] = 2, t[0] === 258) Sr = "BE";else if (t[0] === 513) Sr = "LE";else throw new Error("unable to figure out endianess");
      }
      return Sr;
    }
    function Ja() {
      return _typeof(globalThis.location) < "u" ? globalThis.location.hostname : "";
    }
    function Ua() {
      return [];
    }
    function za() {
      return 0;
    }
    function Xa() {
      return Number.MAX_VALUE;
    }
    function Ka() {
      return Number.MAX_VALUE;
    }
    function Ya() {
      return [];
    }
    function Qa() {
      return "Browser";
    }
    function Za() {
      return _typeof(globalThis.navigator) < "u" ? globalThis.navigator.appVersion : "";
    }
    function eo() {}
    function to() {}
    function jm() {
      return "javascript";
    }
    function Om() {
      return "browser";
    }
    function wn() {
      return "/tmp";
    }
    var Sr,
      _n,
      Pn,
      ro,
      qm = mt({
        "node-modules-polyfills:os": function nodeModulesPolyfillsOs() {
          re(), _n = wn, Pn = "\n", ro = {
            EOL: Pn,
            tmpdir: _n,
            tmpDir: wn,
            networkInterfaces: eo,
            getNetworkInterfaces: to,
            release: Za,
            type: Qa,
            cpus: Ya,
            totalmem: Ka,
            freemem: Xa,
            uptime: za,
            loadavg: Ua,
            hostname: Ja,
            endianness: Ga
          };
        }
      }),
      Mm = Z({
        "node-modules-polyfills-commonjs:os": function nodeModulesPolyfillsCommonjsOs(e, n) {
          re();
          var t = (qm(), lt(Ha));
          if (t && t.default) {
            n.exports = t.default;
            for (var s in t) {
              n.exports[s] = t[s];
            }
          } else t && (n.exports = t);
        }
      }),
      Rm = Z({
        "node_modules/detect-newline/index.js": function node_modulesDetectNewlineIndexJs(e, n) {
          "use strict";

          re();
          var t = function t(s) {
            if (typeof s != "string") throw new TypeError("Expected a string");
            var a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0) return;
            var r = a.filter(function (i) {
                return i === "\r\n";
              }).length,
              u = a.length - r;
            return r > u ? "\r\n" : "\n";
          };
          n.exports = t, n.exports.graceful = function (s) {
            return typeof s == "string" && t(s) || "\n";
          };
        }
      }),
      Vm = Z({
        "node_modules/jest-docblock/build/index.js": function node_modulesJestDocblockBuildIndexJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.extract = p, e.parse = h, e.parseWithComments = w, e.print = T, e.strip = f;
          function n() {
            var S = Mm();
            return n = function n() {
              return S;
            }, S;
          }
          function t() {
            var S = s(Rm());
            return t = function t() {
              return S;
            }, S;
          }
          function s(S) {
            return S && S.__esModule ? S : {
              default: S
            };
          }
          var a = /\*\/$/,
            r = /^\/\*\*/,
            u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
            i = /(^|\s+)\/\/([^\r\n]*)/g,
            o = /^(\r?\n)+/,
            c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
            v = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
            m = /(\r?\n|^) *\* ?/g,
            d = [];
          function p(S) {
            var B = S.match(u);
            return B ? B[0].trimLeft() : "";
          }
          function f(S) {
            var B = S.match(u);
            return B && B[0] ? S.substring(B[0].length) : S;
          }
          function h(S) {
            return w(S).pragmas;
          }
          function w(S) {
            var B = (0, t().default)(S) || n().EOL;
            S = S.replace(r, "").replace(a, "").replace(m, "$1");
            var I = "";
            for (; I !== S;) {
              I = S, S = S.replace(c, "".concat(B, "$1 $2").concat(B));
            }
            S = S.replace(o, "").trimRight();
            var k = Object.create(null),
              P = S.replace(v, "").replace(o, "").trimRight(),
              C;
            for (; C = v.exec(S);) {
              var D = C[2].replace(i, "");
              typeof k[C[1]] == "string" || Array.isArray(k[C[1]]) ? k[C[1]] = d.concat(k[C[1]], D) : k[C[1]] = D;
            }
            return {
              comments: P,
              pragmas: k
            };
          }
          function T(S) {
            var _S$comments = S.comments,
              B = _S$comments === void 0 ? "" : _S$comments,
              _S$pragmas = S.pragmas,
              I = _S$pragmas === void 0 ? {} : _S$pragmas,
              k = (0, t().default)(B) || n().EOL,
              P = "/**",
              C = " *",
              D = " */",
              g = Object.keys(I),
              F = g.map(function (E) {
                return A(E, I[E]);
              }).reduce(function (E, y) {
                return E.concat(y);
              }, []).map(function (E) {
                return C + " " + E + k;
              }).join("");
            if (!B) {
              if (g.length === 0) return "";
              if (g.length === 1 && !Array.isArray(I[g[0]])) {
                var E = I[g[0]];
                return "".concat(P, " ").concat(A(g[0], E)[0]).concat(D);
              }
            }
            var l = B.split(k).map(function (E) {
              return "".concat(C, " ").concat(E);
            }).join(k) + k;
            return P + k + (B ? l : "") + (B && g.length ? C + k : "") + F + D;
          }
          function A(S, B) {
            return d.concat(B).map(function (I) {
              return "@".concat(S, " ").concat(I).trim();
            });
          }
        }
      }),
      Wm = Z({
        "src/language-js/utils/get-shebang.js": function srcLanguageJsUtilsGetShebangJs(e, n) {
          "use strict";

          re();
          function t(s) {
            if (!s.startsWith("#!")) return "";
            var a = s.indexOf("\n");
            return a === -1 ? s : s.slice(0, a);
          }
          n.exports = t;
        }
      }),
      no = Z({
        "src/language-js/pragma.js": function srcLanguageJsPragmaJs(e, n) {
          "use strict";

          re();
          var _Vm = Vm(),
            t = _Vm.parseWithComments,
            s = _Vm.strip,
            a = _Vm.extract,
            r = _Vm.print,
            _jn3 = jn(),
            u = _jn3.normalizeEndOfLine,
            i = Wm();
          function o(m) {
            var d = i(m);
            d && (m = m.slice(d.length + 1));
            var p = a(m),
              _t2 = t(p),
              f = _t2.pragmas,
              h = _t2.comments;
            return {
              shebang: d,
              text: m,
              pragmas: f,
              comments: h
            };
          }
          function c(m) {
            var d = Object.keys(o(m).pragmas);
            return d.includes("prettier") || d.includes("format");
          }
          function v(m) {
            var _o3 = o(m),
              d = _o3.shebang,
              p = _o3.text,
              f = _o3.pragmas,
              h = _o3.comments,
              w = s(p),
              T = r({
                pragmas: Object.assign({
                  format: ""
                }, f),
                comments: h.trimStart()
              });
            return (d ? "".concat(d, "\n") : "") + u(T) + (w.startsWith("\n") ? "\n" : "\n\n") + w;
          }
          n.exports = {
            hasPragma: c,
            insertPragma: v
          };
        }
      }),
      uo = Z({
        "src/language-js/comments.js": function srcLanguageJsCommentsJs(e, n) {
          "use strict";

          re();
          var _Ue7 = Ue(),
            t = _Ue7.getLast,
            s = _Ue7.hasNewline,
            a = _Ue7.getNextNonSpaceNonCommentCharacterIndexWithStartIndex,
            r = _Ue7.getNextNonSpaceNonCommentCharacter,
            u = _Ue7.hasNewlineInRange,
            i = _Ue7.addLeadingComment,
            o = _Ue7.addTrailingComment,
            c = _Ue7.addDanglingComment,
            v = _Ue7.getNextNonSpaceNonCommentCharacterIndex,
            m = _Ue7.isNonEmptyArray,
            _Ke3 = Ke(),
            d = _Ke3.getFunctionParameters,
            p = _Ke3.isPrettierIgnoreComment,
            f = _Ke3.isJsxNode,
            h = _Ke3.hasFlowShorthandAnnotationComment,
            w = _Ke3.hasFlowAnnotationComment,
            T = _Ke3.hasIgnoreComment,
            A = _Ke3.isCallLikeExpression,
            S = _Ke3.getCallArguments,
            B = _Ke3.isCallExpression,
            I = _Ke3.isMemberExpression,
            k = _Ke3.isObjectProperty,
            P = _Ke3.isLineComment,
            C = _Ke3.getComments,
            D = _Ke3.CommentCheckFlags,
            g = _Ke3.markerForIfWithoutBlockAndSameLineComment,
            _st2 = st(),
            F = _st2.locStart,
            l = _st2.locEnd,
            E = It();
          function y(me) {
            return [ve, De, q, j, $, V, Q, Ae, U, ge, Ne, ke, te, ie, G].some(function (_) {
              return _(me);
            });
          }
          function N(me) {
            return [M, De, Y, Ne, j, $, V, Q, ie, z, le, ge, de, G, he].some(function (_) {
              return _(me);
            });
          }
          function x(me) {
            return [ve, j, $, H, ue, te, ge, X, W, K, G, ae].some(function (_) {
              return _(me);
            });
          }
          function b(me, _) {
            var J = (me.body || me.properties).find(function (ne) {
              var Ee = ne.type;
              return Ee !== "EmptyStatement";
            });
            J ? i(J, _) : c(me, _);
          }
          function L(me, _) {
            me.type === "BlockStatement" ? b(me, _) : i(me, _);
          }
          function M(me) {
            var _ = me.comment,
              J = me.followingNode;
            return J && Ie(_) ? (i(J, _), !0) : !1;
          }
          function j(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode,
              We = me.text;
            if ((ne == null ? void 0 : ne.type) !== "IfStatement" || !Ee) return !1;
            if (r(We, _, l) === ")") return o(J, _), !0;
            if (J === ne.consequent && Ee === ne.alternate) {
              if (J.type === "BlockStatement") o(J, _);else {
                var Pe = _.type === "SingleLine" || _.loc.start.line === _.loc.end.line,
                  Se = _.loc.start.line === J.loc.start.line;
                Pe && Se ? c(J, _, g) : c(ne, _);
              }
              return !0;
            }
            return Ee.type === "BlockStatement" ? (b(Ee, _), !0) : Ee.type === "IfStatement" ? (L(Ee.consequent, _), !0) : ne.consequent === Ee ? (i(Ee, _), !0) : !1;
          }
          function $(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode,
              We = me.text;
            return (ne == null ? void 0 : ne.type) !== "WhileStatement" || !Ee ? !1 : r(We, _, l) === ")" ? (o(J, _), !0) : Ee.type === "BlockStatement" ? (b(Ee, _), !0) : ne.body === Ee ? (i(Ee, _), !0) : !1;
          }
          function V(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode;
            return (ne == null ? void 0 : ne.type) !== "TryStatement" && (ne == null ? void 0 : ne.type) !== "CatchClause" || !Ee ? !1 : ne.type === "CatchClause" && J ? (o(J, _), !0) : Ee.type === "BlockStatement" ? (b(Ee, _), !0) : Ee.type === "TryStatement" ? (L(Ee.finalizer, _), !0) : Ee.type === "CatchClause" ? (L(Ee.body, _), !0) : !1;
          }
          function q(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode;
            return I(J) && (ne == null ? void 0 : ne.type) === "Identifier" ? (i(J, _), !0) : !1;
          }
          function Y(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode,
              We = me.text,
              Be = J && !u(We, l(J), F(_));
            return (!J || !Be) && ((ne == null ? void 0 : ne.type) === "ConditionalExpression" || (ne == null ? void 0 : ne.type) === "TSConditionalType") && Ee ? (i(Ee, _), !0) : !1;
          }
          function H(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode;
            return k(ne) && ne.shorthand && ne.key === J && ne.value.type === "AssignmentPattern" ? (o(ne.value.left, _), !0) : !1;
          }
          var R = new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function Q(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode;
            if (R.has(ne == null ? void 0 : ne.type)) {
              if (m(ne.decorators) && !(Ee && Ee.type === "Decorator")) return o(t(ne.decorators), _), !0;
              if (ne.body && Ee === ne.body) return b(ne.body, _), !0;
              if (Ee) {
                if (ne.superClass && Ee === ne.superClass && J && (J === ne.id || J === ne.typeParameters)) return o(J, _), !0;
                for (var _i12 = 0, _arr3 = ["implements", "extends", "mixins"]; _i12 < _arr3.length; _i12++) {
                  var We = _arr3[_i12];
                  if (ne[We] && Ee === ne[We][0]) return J && (J === ne.id || J === ne.typeParameters || J === ne.superClass) ? o(J, _) : c(ne, _, We), !0;
                }
              }
            }
            return !1;
          }
          var ee = new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
          function te(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.text;
            return ne && J && r(Ee, _, l) === "(" && (ne.type === "Property" || ne.type === "TSDeclareMethod" || ne.type === "TSAbstractMethodDefinition") && J.type === "Identifier" && ne.key === J && r(Ee, J, l) !== ":" || (J == null ? void 0 : J.type) === "Decorator" && ee.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;
          }
          var oe = new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function W(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.text;
            return r(Ee, _, l) !== "(" ? !1 : J && oe.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;
          }
          function X(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.text;
            if ((J == null ? void 0 : J.type) !== "ArrowFunctionExpression") return !1;
            var Ee = v(ne, _, l);
            return Ee !== !1 && ne.slice(Ee, Ee + 2) === "=>" ? (c(J, _), !0) : !1;
          }
          function ue(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.text;
            return r(ne, _, l) !== ")" ? !1 : J && (ye(J) && d(J).length === 0 || A(J) && S(J).length === 0) ? (c(J, _), !0) : ((J == null ? void 0 : J.type) === "MethodDefinition" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && d(J.value).length === 0 ? (c(J.value, _), !0) : !1;
          }
          function De(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode,
              We = me.text;
            if ((J == null ? void 0 : J.type) === "FunctionTypeParam" && (ne == null ? void 0 : ne.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((J == null ? void 0 : J.type) === "Identifier" || (J == null ? void 0 : J.type) === "AssignmentPattern") && ne && ye(ne) && r(We, _, l) === ")") return o(J, _), !0;
            if ((ne == null ? void 0 : ne.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
              var Be = function () {
                var Pe = d(ne);
                if (Pe.length > 0) return a(We, l(t(Pe)));
                var Se = a(We, l(ne.id));
                return Se !== !1 && a(We, Se + 1);
              }();
              if (F(_) > Be) return b(Ee, _), !0;
            }
            return !1;
          }
          function ie(me) {
            var _ = me.comment,
              J = me.enclosingNode;
            return (J == null ? void 0 : J.type) === "LabeledStatement" ? (i(J, _), !0) : !1;
          }
          function G(me) {
            var _ = me.comment,
              J = me.enclosingNode;
            return ((J == null ? void 0 : J.type) === "ContinueStatement" || (J == null ? void 0 : J.type) === "BreakStatement") && !J.label ? (o(J, _), !0) : !1;
          }
          function z(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode;
            return B(ne) && J && ne.callee === J && ne.arguments.length > 0 ? (i(ne.arguments[0], _), !0) : !1;
          }
          function U(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode;
            return (ne == null ? void 0 : ne.type) === "UnionTypeAnnotation" || (ne == null ? void 0 : ne.type) === "TSUnionType" ? (p(_) && (Ee.prettierIgnore = !0, _.unignore = !0), J ? (o(J, _), !0) : !1) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(_) && (Ee.types[0].prettierIgnore = !0, _.unignore = !0), !1);
          }
          function le(me) {
            var _ = me.comment,
              J = me.enclosingNode;
            return k(J) ? (i(J, _), !0) : !1;
          }
          function ge(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode,
              Ee = me.ast,
              We = me.isLastComment;
            return Ee && Ee.body && Ee.body.length === 0 ? (We ? c(Ee, _) : i(Ee, _), !0) : (J == null ? void 0 : J.type) === "Program" && (J == null ? void 0 : J.body.length) === 0 && !m(J.directives) ? (We ? c(J, _) : i(J, _), !0) : (ne == null ? void 0 : ne.type) === "Program" && (ne == null ? void 0 : ne.body.length) === 0 && (J == null ? void 0 : J.type) === "ModuleExpression" ? (c(ne, _), !0) : !1;
          }
          function Ae(me) {
            var _ = me.comment,
              J = me.enclosingNode;
            return (J == null ? void 0 : J.type) === "ForInStatement" || (J == null ? void 0 : J.type) === "ForOfStatement" ? (i(J, _), !0) : !1;
          }
          function Ne(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.text;
            if ((ne == null ? void 0 : ne.type) === "ImportSpecifier" || (ne == null ? void 0 : ne.type) === "ExportSpecifier") return i(ne, _), !0;
            var We = (J == null ? void 0 : J.type) === "ImportSpecifier" && (ne == null ? void 0 : ne.type) === "ImportDeclaration",
              Be = (J == null ? void 0 : J.type) === "ExportSpecifier" && (ne == null ? void 0 : ne.type) === "ExportNamedDeclaration";
            return (We || Be) && s(Ee, l(_)) ? (o(J, _), !0) : !1;
          }
          function ke(me) {
            var _ = me.comment,
              J = me.enclosingNode;
            return (J == null ? void 0 : J.type) === "AssignmentPattern" ? (i(J, _), !0) : !1;
          }
          var ce = new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]),
            pe = new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function de(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode;
            return ce.has(J == null ? void 0 : J.type) && ne && (pe.has(ne.type) || E(_)) ? (i(ne, _), !0) : !1;
          }
          function ae(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode,
              Ee = me.text;
            return !ne && ((J == null ? void 0 : J.type) === "TSMethodSignature" || (J == null ? void 0 : J.type) === "TSDeclareFunction" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && r(Ee, _, l) === ";" ? (o(J, _), !0) : !1;
          }
          function ve(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode;
            if (p(_) && (J == null ? void 0 : J.type) === "TSMappedType" && (ne == null ? void 0 : ne.type) === "TSTypeParameter" && ne.constraint) return J.prettierIgnore = !0, _.unignore = !0, !0;
          }
          function K(me) {
            var _ = me.comment,
              J = me.precedingNode,
              ne = me.enclosingNode,
              Ee = me.followingNode;
            return (ne == null ? void 0 : ne.type) !== "TSMappedType" ? !1 : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i(Ee.name, _), !0) : (J == null ? void 0 : J.type) === "TSTypeParameter" && J.constraint ? (o(J.constraint, _), !0) : !1;
          }
          function he(me) {
            var _ = me.comment,
              J = me.enclosingNode,
              ne = me.followingNode;
            return !J || J.type !== "SwitchCase" || J.test ? !1 : (ne.type === "BlockStatement" && P(_) ? b(ne, _) : c(J, _), !0);
          }
          function ye(me) {
            return me.type === "ArrowFunctionExpression" || me.type === "FunctionExpression" || me.type === "FunctionDeclaration" || me.type === "ObjectMethod" || me.type === "ClassMethod" || me.type === "TSDeclareFunction" || me.type === "TSCallSignatureDeclaration" || me.type === "TSConstructSignatureDeclaration" || me.type === "TSMethodSignature" || me.type === "TSConstructorType" || me.type === "TSFunctionType" || me.type === "TSDeclareMethod";
          }
          function Ce(me, _) {
            if ((_.parser === "typescript" || _.parser === "flow" || _.parser === "acorn" || _.parser === "espree" || _.parser === "meriyah" || _.parser === "__babel_estree") && me.type === "MethodDefinition" && me.value && me.value.type === "FunctionExpression" && d(me.value).length === 0 && !me.value.returnType && !m(me.value.typeParameters) && me.value.body) return [].concat(_toConsumableArray(me.decorators || []), [me.key, me.value.body]);
          }
          function Ie(me) {
            return E(me) && me.value[0] === "*" && /@type\b/.test(me.value);
          }
          function Fe(me) {
            var _ = me.getValue(),
              J = me.getParentNode(),
              ne = function ne(Ee) {
                return w(C(Ee, D.Leading)) || w(C(Ee, D.Trailing));
              };
            return (_ && (f(_) || h(_) || B(J) && ne(_)) || J && (J.type === "JSXSpreadAttribute" || J.type === "JSXSpreadChild" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || (J.type === "ClassDeclaration" || J.type === "ClassExpression") && J.superClass === _)) && (!T(me) || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType");
          }
          n.exports = {
            handleOwnLineComment: y,
            handleEndOfLineComment: N,
            handleRemainingComment: x,
            isTypeCastComment: Ie,
            getCommentChildNodes: Ce,
            willPrintOwnComments: Fe
          };
        }
      }),
      jt = Z({
        "src/language-js/needs-parens.js": function srcLanguageJsNeedsParensJs(e, n) {
          "use strict";

          re();
          var t = it(),
            s = Rn(),
            _Ke4 = Ke(),
            a = _Ke4.getFunctionParameters,
            r = _Ke4.getLeftSidePathName,
            u = _Ke4.hasFlowShorthandAnnotationComment,
            i = _Ke4.hasNakedLeftSide,
            o = _Ke4.hasNode,
            c = _Ke4.isBitwiseOperator,
            v = _Ke4.startsWithNoLookaheadToken,
            m = _Ke4.shouldFlatten,
            d = _Ke4.getPrecedence,
            p = _Ke4.isCallExpression,
            f = _Ke4.isMemberExpression,
            h = _Ke4.isObjectProperty;
          function w(P, C) {
            var D = P.getParentNode();
            if (!D) return !1;
            var g = P.getName(),
              F = P.getNode();
            if (C.__isInHtmlInterpolation && !C.bracketSpacing && B(F) && I(P)) return !0;
            if (T(F)) return !1;
            if (C.parser !== "flow" && u(P.getValue())) return !0;
            if (F.type === "Identifier") return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name) || g === "left" && F.name === "async" && D.type === "ForOfStatement" && !D.await);
            switch (D.type) {
              case "ParenthesizedExpression":
                return !1;
              case "ClassDeclaration":
              case "ClassExpression":
                {
                  if (g === "superClass" && (F.type === "ArrowFunctionExpression" || F.type === "AssignmentExpression" || F.type === "AwaitExpression" || F.type === "BinaryExpression" || F.type === "ConditionalExpression" || F.type === "LogicalExpression" || F.type === "NewExpression" || F.type === "ObjectExpression" || F.type === "SequenceExpression" || F.type === "TaggedTemplateExpression" || F.type === "UnaryExpression" || F.type === "UpdateExpression" || F.type === "YieldExpression" || F.type === "TSNonNullExpression")) return !0;
                  break;
                }
              case "ExportDefaultDeclaration":
                return k(P, C) || F.type === "SequenceExpression";
              case "Decorator":
                {
                  if (g === "expression") {
                    var l = !1,
                      E = !1,
                      y = F;
                    for (; y;) {
                      switch (y.type) {
                        case "MemberExpression":
                          E = !0, y = y.object;
                          break;
                        case "CallExpression":
                          if (E || l) return C.parser !== "typescript";
                          l = !0, y = y.callee;
                          break;
                        case "Identifier":
                          return !1;
                        case "TaggedTemplateExpression":
                          return C.parser !== "typescript";
                        default:
                          return !0;
                      }
                    }
                    return !0;
                  }
                  break;
                }
              case "ExpressionStatement":
                {
                  if (v(F, !0)) return !0;
                  break;
                }
              case "ArrowFunctionExpression":
                {
                  if (g === "body" && F.type !== "SequenceExpression" && v(F, !1)) return !0;
                  break;
                }
            }
            switch (F.type) {
              case "UpdateExpression":
                if (D.type === "UnaryExpression") return F.prefix && (F.operator === "++" && D.operator === "+" || F.operator === "--" && D.operator === "-");
              case "UnaryExpression":
                switch (D.type) {
                  case "UnaryExpression":
                    return F.operator === D.operator && (F.operator === "+" || F.operator === "-");
                  case "BindExpression":
                    return !0;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "TaggedTemplateExpression":
                    return !0;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "BinaryExpression":
                    return g === "left" && D.operator === "**";
                  case "TSNonNullExpression":
                    return !0;
                  default:
                    return !1;
                }
              case "BinaryExpression":
                {
                  if (D.type === "UpdateExpression" || F.operator === "in" && A(P)) return !0;
                  if (F.operator === "|>" && F.extra && F.extra.parenthesized) {
                    var _l2 = P.getParentNode(1);
                    if (_l2.type === "BinaryExpression" && _l2.operator === "|>") return !0;
                  }
                }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "LogicalExpression":
                switch (D.type) {
                  case "TSAsExpression":
                    return F.type !== "TSAsExpression";
                  case "ConditionalExpression":
                    return F.type === "TSAsExpression";
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return g === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return !0;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return g === "left" && (F.type === "TSTypeAssertion" || F.type === "TSAsExpression");
                  case "LogicalExpression":
                    if (F.type === "LogicalExpression") return D.operator !== F.operator;
                  case "BinaryExpression":
                    {
                      var _l3 = F.operator,
                        _E3 = F.type;
                      if (!_l3 && _E3 !== "TSTypeAssertion") return !0;
                      var _y3 = d(_l3),
                        N = D.operator,
                        x = d(N);
                      return x > _y3 || g === "right" && x === _y3 || x === _y3 && !m(N, _l3) ? !0 : x < _y3 && _l3 === "%" ? N === "+" || N === "-" : !!c(N);
                    }
                  default:
                    return !1;
                }
              case "SequenceExpression":
                switch (D.type) {
                  case "ReturnStatement":
                    return !1;
                  case "ForStatement":
                    return !1;
                  case "ExpressionStatement":
                    return g !== "expression";
                  case "ArrowFunctionExpression":
                    return g !== "body";
                  default:
                    return !0;
                }
              case "YieldExpression":
                if (D.type === "UnaryExpression" || D.type === "AwaitExpression" || D.type === "TSAsExpression" || D.type === "TSNonNullExpression") return !0;
              case "AwaitExpression":
                switch (D.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return !0;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ConditionalExpression":
                    return g === "test";
                  case "BinaryExpression":
                    return !(!F.argument && D.operator === "|>");
                  default:
                    return !1;
                }
              case "TSConditionalType":
                if (g === "extendsType" && D.type === "TSConditionalType") return !0;
              case "TSFunctionType":
              case "TSConstructorType":
                if (g === "checkType" && D.type === "TSConditionalType") return !0;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((D.type === "TSUnionType" || D.type === "TSIntersectionType") && D.types.length > 1 && (!F.types || F.types.length > 1)) return !0;
              case "TSInferType":
                if (F.type === "TSInferType" && D.type === "TSRestType") return !1;
              case "TSTypeOperator":
                return D.type === "TSArrayType" || D.type === "TSOptionalType" || D.type === "TSRestType" || g === "objectType" && D.type === "TSIndexedAccessType" || D.type === "TSTypeOperator" || D.type === "TSTypeAnnotation" && P.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return D.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return D.type === "ArrayTypeAnnotation" || D.type === "NullableTypeAnnotation" || D.type === "IntersectionTypeAnnotation" || D.type === "UnionTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return D.type === "ArrayTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation":
                {
                  var _l4 = D.type === "NullableTypeAnnotation" ? P.getParentNode(1) : D;
                  return _l4.type === "UnionTypeAnnotation" || _l4.type === "IntersectionTypeAnnotation" || _l4.type === "ArrayTypeAnnotation" || g === "objectType" && (_l4.type === "IndexedAccessType" || _l4.type === "OptionalIndexedAccessType") || _l4.type === "NullableTypeAnnotation" || D.type === "FunctionTypeParam" && D.name === null && a(F).some(function (E) {
                    return E.typeAnnotation && E.typeAnnotation.type === "NullableTypeAnnotation";
                  });
                }
              case "OptionalIndexedAccessType":
                return g === "objectType" && D.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof F.value == "string" && D.type === "ExpressionStatement" && !D.directive) {
                  var _l5 = P.getParentNode(1);
                  return _l5.type === "Program" || _l5.type === "BlockStatement";
                }
                return g === "object" && D.type === "MemberExpression" && typeof F.value == "number";
              case "AssignmentExpression":
                {
                  var _l6 = P.getParentNode(1);
                  return g === "body" && D.type === "ArrowFunctionExpression" ? !0 : g === "key" && (D.type === "ClassProperty" || D.type === "PropertyDefinition") && D.computed || (g === "init" || g === "update") && D.type === "ForStatement" ? !1 : D.type === "ExpressionStatement" ? F.left.type === "ObjectPattern" : !(g === "key" && D.type === "TSPropertySignature" || D.type === "AssignmentExpression" || D.type === "SequenceExpression" && _l6 && _l6.type === "ForStatement" && (_l6.init === D || _l6.update === D) || g === "value" && D.type === "Property" && _l6 && _l6.type === "ObjectPattern" && _l6.properties.includes(D) || D.type === "NGChainedExpression");
                }
              case "ConditionalExpression":
                switch (D.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                    return !0;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ConditionalExpression":
                    return g === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  default:
                    return !1;
                }
              case "FunctionExpression":
                switch (D.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "TaggedTemplateExpression":
                    return !0;
                  default:
                    return !1;
                }
              case "ArrowFunctionExpression":
                switch (D.type) {
                  case "BinaryExpression":
                    return D.operator !== "|>" || F.extra && F.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return !0;
                  case "ConditionalExpression":
                    return g === "test";
                  default:
                    return !1;
                }
              case "ClassExpression":
                if (s(F.decorators)) return !0;
                switch (D.type) {
                  case "NewExpression":
                    return g === "callee";
                  default:
                    return !1;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression":
                {
                  var _l7 = P.getParentNode(1);
                  if (g === "object" && D.type === "MemberExpression" || g === "callee" && (D.type === "CallExpression" || D.type === "NewExpression") || D.type === "TSNonNullExpression" && _l7.type === "MemberExpression" && _l7.object === D) return !0;
                }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression")) {
                  var _l8 = F;
                  for (; _l8;) {
                    switch (_l8.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return !0;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        _l8 = _l8.object;
                        break;
                      case "TaggedTemplateExpression":
                        _l8 = _l8.tag;
                        break;
                      case "TSNonNullExpression":
                        _l8 = _l8.expression;
                        break;
                      default:
                        return !1;
                    }
                  }
                }
                return !1;
              case "BindExpression":
                return g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression") || g === "object" && f(D);
              case "NGPipeExpression":
                return !(D.type === "NGRoot" || D.type === "NGMicrosyntaxExpression" || D.type === "ObjectProperty" && !(F.extra && F.extra.parenthesized) || D.type === "ArrayExpression" || p(D) && D.arguments[g] === F || g === "right" && D.type === "NGPipeExpression" || g === "property" && D.type === "MemberExpression" || D.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return g === "callee" || g === "left" && D.type === "BinaryExpression" && D.operator === "<" || D.type !== "ArrayExpression" && D.type !== "ArrowFunctionExpression" && D.type !== "AssignmentExpression" && D.type !== "AssignmentPattern" && D.type !== "BinaryExpression" && D.type !== "NewExpression" && D.type !== "ConditionalExpression" && D.type !== "ExpressionStatement" && D.type !== "JsExpressionRoot" && D.type !== "JSXAttribute" && D.type !== "JSXElement" && D.type !== "JSXExpressionContainer" && D.type !== "JSXFragment" && D.type !== "LogicalExpression" && !p(D) && !h(D) && D.type !== "ReturnStatement" && D.type !== "ThrowStatement" && D.type !== "TypeCastExpression" && D.type !== "VariableDeclarator" && D.type !== "YieldExpression";
              case "TypeAnnotation":
                return g === "returnType" && D.type === "ArrowFunctionExpression" && S(F);
            }
            return !1;
          }
          function T(P) {
            return P.type === "BlockStatement" || P.type === "BreakStatement" || P.type === "ClassBody" || P.type === "ClassDeclaration" || P.type === "ClassMethod" || P.type === "ClassProperty" || P.type === "PropertyDefinition" || P.type === "ClassPrivateProperty" || P.type === "ContinueStatement" || P.type === "DebuggerStatement" || P.type === "DeclareClass" || P.type === "DeclareExportAllDeclaration" || P.type === "DeclareExportDeclaration" || P.type === "DeclareFunction" || P.type === "DeclareInterface" || P.type === "DeclareModule" || P.type === "DeclareModuleExports" || P.type === "DeclareVariable" || P.type === "DoWhileStatement" || P.type === "EnumDeclaration" || P.type === "ExportAllDeclaration" || P.type === "ExportDefaultDeclaration" || P.type === "ExportNamedDeclaration" || P.type === "ExpressionStatement" || P.type === "ForInStatement" || P.type === "ForOfStatement" || P.type === "ForStatement" || P.type === "FunctionDeclaration" || P.type === "IfStatement" || P.type === "ImportDeclaration" || P.type === "InterfaceDeclaration" || P.type === "LabeledStatement" || P.type === "MethodDefinition" || P.type === "ReturnStatement" || P.type === "SwitchStatement" || P.type === "ThrowStatement" || P.type === "TryStatement" || P.type === "TSDeclareFunction" || P.type === "TSEnumDeclaration" || P.type === "TSImportEqualsDeclaration" || P.type === "TSInterfaceDeclaration" || P.type === "TSModuleDeclaration" || P.type === "TSNamespaceExportDeclaration" || P.type === "TypeAlias" || P.type === "VariableDeclaration" || P.type === "WhileStatement" || P.type === "WithStatement";
          }
          function A(P) {
            var C = 0,
              D = P.getValue();
            for (; D;) {
              var g = P.getParentNode(C++);
              if (g && g.type === "ForStatement" && g.init === D) return !0;
              D = g;
            }
            return !1;
          }
          function S(P) {
            return o(P, function (C) {
              return C.type === "ObjectTypeAnnotation" && o(C, function (D) {
                return D.type === "FunctionTypeAnnotation" || void 0;
              }) || void 0;
            });
          }
          function B(P) {
            switch (P.type) {
              case "ObjectExpression":
                return !0;
              default:
                return !1;
            }
          }
          function I(P) {
            var C = P.getValue(),
              D = P.getParentNode(),
              g = P.getName();
            switch (D.type) {
              case "NGPipeExpression":
                if (typeof g == "number" && D.arguments[g] === C && D.arguments.length - 1 === g) return P.callParent(I);
                break;
              case "ObjectProperty":
                if (g === "value") {
                  var F = P.getParentNode(1);
                  return t(F.properties) === D;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (g === "right") return P.callParent(I);
                break;
              case "ConditionalExpression":
                if (g === "alternate") return P.callParent(I);
                break;
              case "UnaryExpression":
                if (D.prefix) return P.callParent(I);
                break;
            }
            return !1;
          }
          function k(P, C) {
            var D = P.getValue(),
              g = P.getParentNode();
            return D.type === "FunctionExpression" || D.type === "ClassExpression" ? g.type === "ExportDefaultDeclaration" || !w(P, C) : !i(D) || g.type !== "ExportDefaultDeclaration" && w(P, C) ? !1 : P.call.apply(P, [function (F) {
              return k(F, C);
            }].concat(_toConsumableArray(r(P, D))));
          }
          n.exports = w;
        }
      }),
      so = Z({
        "src/language-js/print-preprocess.js": function srcLanguageJsPrintPreprocessJs(e, n) {
          "use strict";

          re();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, {
                  type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
                  node: s,
                  comments: [],
                  rootMarker: a.rootMarker
                });
              default:
                return s;
            }
          }
          n.exports = t;
        }
      }),
      $m = Z({
        "src/language-js/print/html-binding.js": function srcLanguageJsPrintHtmlBindingJs(e, n) {
          "use strict";

          re();
          var _Oe10 = Oe(),
            _Oe10$builders = _Oe10.builders,
            t = _Oe10$builders.join,
            s = _Oe10$builders.line,
            a = _Oe10$builders.group,
            r = _Oe10$builders.softline,
            u = _Oe10$builders.indent;
          function i(c, v, m) {
            var d = c.getValue();
            if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d, v), d.type === "File") {
              if (v.__isVueForBindingLeft) return c.call(function (p) {
                var f = t([",", s], p.map(m, "params")),
                  _p$getValue = p.getValue(),
                  h = _p$getValue.params;
                return h.length === 1 ? f : ["(", u([r, a(f)]), r, ")"];
              }, "program", "body", 0);
              if (v.__isVueBindings) return c.call(function (p) {
                return t([",", s], p.map(m, "params"));
              }, "program", "body", 0);
            }
          }
          function o(c) {
            switch (c.type) {
              case "MemberExpression":
                switch (c.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return o(c.object);
                }
                return !1;
              case "Identifier":
                return !0;
              default:
                return !1;
            }
          }
          n.exports = {
            isVueEventBindingExpression: o,
            printHtmlBinding: i
          };
        }
      }),
      Jn = Z({
        "src/language-js/print/binaryish.js": function srcLanguageJsPrintBinaryishJs(e, n) {
          "use strict";

          re();
          var _et2 = et(),
            t = _et2.printComments,
            _Ue8 = Ue(),
            s = _Ue8.getLast,
            _Oe11 = Oe(),
            _Oe11$builders = _Oe11.builders,
            a = _Oe11$builders.join,
            r = _Oe11$builders.line,
            u = _Oe11$builders.softline,
            i = _Oe11$builders.group,
            o = _Oe11$builders.indent,
            c = _Oe11$builders.align,
            v = _Oe11$builders.ifBreak,
            m = _Oe11$builders.indentIfBreak,
            _Oe11$utils = _Oe11.utils,
            d = _Oe11$utils.cleanDoc,
            p = _Oe11$utils.getDocParts,
            f = _Oe11$utils.isConcat,
            _Ke5 = Ke(),
            h = _Ke5.hasLeadingOwnLineComment,
            w = _Ke5.isBinaryish,
            T = _Ke5.isJsxNode,
            A = _Ke5.shouldFlatten,
            S = _Ke5.hasComment,
            B = _Ke5.CommentCheckFlags,
            I = _Ke5.isCallExpression,
            k = _Ke5.isMemberExpression,
            P = _Ke5.isObjectProperty,
            C = _Ke5.isEnabledHackPipeline,
            D = 0;
          function g(E, y, N) {
            var x = E.getValue(),
              b = E.getParentNode(),
              L = E.getParentNode(1),
              M = x !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"),
              j = C(y) && x.operator === "|>",
              $ = F(E, N, y, !1, M);
            if (M) return $;
            if (j) return i($);
            if (I(b) && b.callee === x || b.type === "UnaryExpression" || k(b) && !b.computed) return i([o([u].concat(_toConsumableArray($))), u]);
            var V = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x.operator !== "|" && b.type === "JsExpressionRoot" || x.type !== "NGPipeExpression" && (b.type === "NGRoot" && y.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x === b.body && b.type === "ArrowFunctionExpression" || x !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !I(L) || b.type === "TemplateLiteral",
              q = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b),
              Y = w(x.left) && A(x.operator, x.left.operator);
            if (V || l(x) && !Y || !l(x) && q) return i($);
            if ($.length === 0) return "";
            var H = T(x.right),
              R = $.findIndex(function (X) {
                return typeof X != "string" && !Array.isArray(X) && X.type === "group";
              }),
              Q = $.slice(0, R === -1 ? 1 : R + 1),
              ee = $.slice(Q.length, H ? -1 : void 0),
              te = Symbol("logicalChain-" + ++D),
              oe = i([].concat(_toConsumableArray(Q), [o(ee)]), {
                id: te
              });
            if (!H) return oe;
            var W = s($);
            return i([oe, m(W, {
              groupId: te
            })]);
          }
          function F(E, y, N, x, b) {
            var L = E.getValue();
            if (!w(L)) return [i(y())];
            var M = [];
            A(L.operator, L.left.operator) ? M = E.call(function (ee) {
              return F(ee, y, N, !0, b);
            }, "left") : M.push(i(y("left")));
            var j = l(L),
              $ = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && N.parser === "__vue_expression") && !h(N.originalText, L.right),
              V = L.type === "NGPipeExpression" ? "|" : L.operator,
              q = L.type === "NGPipeExpression" && L.arguments.length > 0 ? i(o([u, ": ", a([u, ":", v(" ")], E.map(y, "arguments").map(function (ee) {
                return c(2, i(ee));
              }))])) : "",
              Y;
            if (j) Y = [V, " ", y("right"), q];else {
              var te = C(N) && V === "|>" ? E.call(function (oe) {
                return F(oe, y, N, !0, b);
              }, "right") : y("right");
              Y = [$ ? r : "", V, $ ? " " : r, te, q];
            }
            var H = E.getParentNode(),
              R = S(L.left, B.Trailing | B.Line),
              Q = R || !(b && L.type === "LogicalExpression") && H.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
            if (M.push($ ? "" : " ", Q ? i(Y, {
              shouldBreak: R
            }) : Y), x && S(L)) {
              var ee = d(t(E, M, N));
              return f(ee) || ee.type === "fill" ? p(ee) : [ee];
            }
            return M;
          }
          function l(E) {
            return E.type !== "LogicalExpression" ? !1 : !!(E.right.type === "ObjectExpression" && E.right.properties.length > 0 || E.right.type === "ArrayExpression" && E.right.elements.length > 0 || T(E.right));
          }
          n.exports = {
            printBinaryishExpression: g,
            shouldInlineLogicalExpression: l
          };
        }
      }),
      Hm = Z({
        "src/language-js/print/angular.js": function srcLanguageJsPrintAngularJs(e, n) {
          "use strict";

          re();
          var _Oe12 = Oe(),
            _Oe12$builders = _Oe12.builders,
            t = _Oe12$builders.join,
            s = _Oe12$builders.line,
            a = _Oe12$builders.group,
            _Ke6 = Ke(),
            r = _Ke6.hasNode,
            u = _Ke6.hasComment,
            i = _Ke6.getComments,
            _Jn = Jn(),
            o = _Jn.printBinaryishExpression;
          function c(d, p, f) {
            var h = d.getValue();
            if (!!h.type.startsWith("NG")) switch (h.type) {
              case "NGRoot":
                return [f("node"), u(h.node) ? " //" + i(h.node)[0].value.trimEnd() : ""];
              case "NGPipeExpression":
                return o(d, p, f);
              case "NGChainedExpression":
                return a(t([";", s], d.map(function (w) {
                  return m(w) ? f() : ["(", f(), ")"];
                }, "expressions")));
              case "NGEmptyExpression":
                return "";
              case "NGQuotedExpression":
                return [h.prefix, ": ", h.value.trim()];
              case "NGMicrosyntax":
                return d.map(function (w, T) {
                  return [T === 0 ? "" : v(w.getValue(), T, h) ? " " : [";", s], f()];
                }, "body");
              case "NGMicrosyntaxKey":
                return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);
              case "NGMicrosyntaxExpression":
                return [f("expression"), h.alias === null ? "" : [" as ", f("alias")]];
              case "NGMicrosyntaxKeyedExpression":
                {
                  var _w5 = d.getName(),
                    T = d.getParentNode(),
                    A = v(h, _w5, T) || (_w5 === 1 && (h.key.name === "then" || h.key.name === "else") || _w5 === 2 && h.key.name === "else" && T.body[_w5 - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[_w5 - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                  return [f("key"), A ? " " : ": ", f("expression")];
                }
              case "NGMicrosyntaxLet":
                return ["let ", f("key"), h.value === null ? "" : [" = ", f("value")]];
              case "NGMicrosyntaxAs":
                return [f("key"), " as ", f("alias")];
              default:
                throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h.type), "."));
            }
          }
          function v(d, p, f) {
            return d.type === "NGMicrosyntaxKeyedExpression" && d.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function m(d) {
            return r(d.getValue(), function (p) {
              switch (p.type) {
                case void 0:
                  return !1;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return !0;
              }
            });
          }
          n.exports = {
            printAngular: c
          };
        }
      }),
      Gm = Z({
        "src/language-js/print/jsx.js": function srcLanguageJsPrintJsxJs(e, n) {
          "use strict";

          re();
          var _et3 = et(),
            t = _et3.printComments,
            s = _et3.printDanglingComments,
            _Oe13 = Oe(),
            _Oe13$builders = _Oe13.builders,
            a = _Oe13$builders.line,
            r = _Oe13$builders.hardline,
            u = _Oe13$builders.softline,
            i = _Oe13$builders.group,
            o = _Oe13$builders.indent,
            c = _Oe13$builders.conditionalGroup,
            v = _Oe13$builders.fill,
            m = _Oe13$builders.ifBreak,
            d = _Oe13$builders.lineSuffixBoundary,
            p = _Oe13$builders.join,
            f = _Oe13.utils.willBreak,
            _Ue9 = Ue(),
            h = _Ue9.getLast,
            w = _Ue9.getPreferredQuote,
            _Ke7 = Ke(),
            T = _Ke7.isJsxNode,
            A = _Ke7.rawText,
            S = _Ke7.isLiteral,
            B = _Ke7.isCallExpression,
            I = _Ke7.isStringLiteral,
            k = _Ke7.isBinaryish,
            P = _Ke7.hasComment,
            C = _Ke7.CommentCheckFlags,
            D = _Ke7.hasNodeIgnoreComment,
            g = jt(),
            _uo = uo(),
            F = _uo.willPrintOwnComments,
            l = function l(ie) {
              return ie === "" || ie === a || ie === r || ie === u;
            };
          function E(ie, G, z) {
            var U = ie.getValue();
            if (U.type === "JSXElement" && W(U)) return [z("openingElement"), z("closingElement")];
            var le = U.type === "JSXElement" ? z("openingElement") : z("openingFragment"),
              ge = U.type === "JSXElement" ? z("closingElement") : z("closingFragment");
            if (U.children.length === 1 && U.children[0].type === "JSXExpressionContainer" && (U.children[0].expression.type === "TemplateLiteral" || U.children[0].expression.type === "TaggedTemplateExpression")) return [le].concat(_toConsumableArray(ie.map(z, "children")), [ge]);
            U.children = U.children.map(function (Fe) {
              return ue(Fe) ? {
                type: "JSXText",
                value: " ",
                raw: " "
              } : Fe;
            });
            var Ae = U.children.some(T),
              Ne = U.children.filter(function (Fe) {
                return Fe.type === "JSXExpressionContainer";
              }).length > 1,
              ke = U.type === "JSXElement" && U.openingElement.attributes.length > 1,
              ce = f(le) || Ae || ke || Ne,
              pe = ie.getParentNode().rootMarker === "mdx",
              de = G.singleQuote ? "{' '}" : '{" "}',
              ae = pe ? " " : m([de, u], " "),
              ve = U.openingElement && U.openingElement.name && U.openingElement.name.name === "fbt",
              K = y(ie, G, z, ae, ve),
              he = U.children.some(function (Fe) {
                return X(Fe);
              });
            for (var Fe = K.length - 2; Fe >= 0; Fe--) {
              var me = K[Fe] === "" && K[Fe + 1] === "",
                _ = K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === r,
                J = (K[Fe] === u || K[Fe] === r) && K[Fe + 1] === "" && K[Fe + 2] === ae,
                ne = K[Fe] === ae && K[Fe + 1] === "" && (K[Fe + 2] === u || K[Fe + 2] === r),
                Ee = K[Fe] === ae && K[Fe + 1] === "" && K[Fe + 2] === ae,
                We = K[Fe] === u && K[Fe + 1] === "" && K[Fe + 2] === r || K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === u;
              _ && he || me || J || Ee || We ? K.splice(Fe, 2) : ne && K.splice(Fe + 1, 2);
            }
            for (; K.length > 0 && l(h(K));) {
              K.pop();
            }
            for (; K.length > 1 && l(K[0]) && l(K[1]);) {
              K.shift(), K.shift();
            }
            var ye = [];
            var _iterator41 = _createForOfIteratorHelper(K.entries()),
              _step41;
            try {
              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                var _step41$value = _slicedToArray(_step41.value, 2),
                  _Fe = _step41$value[0],
                  _me = _step41$value[1];
                if (_me === ae) {
                  if (_Fe === 1 && K[_Fe - 1] === "") {
                    if (K.length === 2) {
                      ye.push(de);
                      continue;
                    }
                    ye.push([de, r]);
                    continue;
                  } else if (_Fe === K.length - 1) {
                    ye.push(de);
                    continue;
                  } else if (K[_Fe - 1] === "" && K[_Fe - 2] === r) {
                    ye.push(de);
                    continue;
                  }
                }
                ye.push(_me), f(_me) && (ce = !0);
              }
            } catch (err) {
              _iterator41.e(err);
            } finally {
              _iterator41.f();
            }
            var Ce = he ? v(ye) : i(ye, {
              shouldBreak: !0
            });
            if (pe) return Ce;
            var Ie = i([le, o([r, Ce]), r, ge]);
            return ce ? Ie : c([i([le].concat(_toConsumableArray(K), [ge])), Ie]);
          }
          function y(ie, G, z, U, le) {
            var ge = [];
            return ie.each(function (Ae, Ne, ke) {
              var ce = Ae.getValue();
              if (S(ce)) {
                var pe = A(ce);
                if (X(ce)) {
                  var de = pe.split(ee);
                  if (de[0] === "") {
                    if (ge.push(""), de.shift(), /\n/.test(de[0])) {
                      var ve = ke[Ne + 1];
                      ge.push(x(le, de[1], ce, ve));
                    } else ge.push(U);
                    de.shift();
                  }
                  var ae;
                  if (h(de) === "" && (de.pop(), ae = de.pop()), de.length === 0) return;
                  var _iterator42 = _createForOfIteratorHelper(de.entries()),
                    _step42;
                  try {
                    for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
                      var _step42$value = _slicedToArray(_step42.value, 2),
                        _ve3 = _step42$value[0],
                        K = _step42$value[1];
                      _ve3 % 2 === 1 ? ge.push(a) : ge.push(K);
                    }
                  } catch (err) {
                    _iterator42.e(err);
                  } finally {
                    _iterator42.f();
                  }
                  if (ae !== void 0) {
                    if (/\n/.test(ae)) {
                      var _ve = ke[Ne + 1];
                      ge.push(x(le, h(ge), ce, _ve));
                    } else ge.push(U);
                  } else {
                    var _ve2 = ke[Ne + 1];
                    ge.push(N(le, h(ge), ce, _ve2));
                  }
                } else /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", r) : ge.push("", U);
              } else {
                var _pe = z();
                ge.push(_pe);
                var _de = ke[Ne + 1];
                if (_de && X(_de)) {
                  var _ve4 = oe(A(_de)).split(ee)[0];
                  ge.push(N(le, _ve4, ce, _de));
                } else ge.push(r);
              }
            }, "children"), ge;
          }
          function N(ie, G, z, U) {
            return ie ? "" : z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? G.length === 1 ? u : r : u;
          }
          function x(ie, G, z, U) {
            return ie ? r : G.length === 1 ? z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? r : u : r;
          }
          function b(ie, G, z) {
            var U = ie.getParentNode();
            if (!U || {
              ArrayExpression: !0,
              JSXAttribute: !0,
              JSXElement: !0,
              JSXExpressionContainer: !0,
              JSXFragment: !0,
              ExpressionStatement: !0,
              CallExpression: !0,
              OptionalCallExpression: !0,
              ConditionalExpression: !0,
              JsExpressionRoot: !0
            }[U.type]) return G;
            var ge = ie.match(void 0, function (Ne) {
                return Ne.type === "ArrowFunctionExpression";
              }, B, function (Ne) {
                return Ne.type === "JSXExpressionContainer";
              }),
              Ae = g(ie, z);
            return i([Ae ? "" : m("("), o([u, G]), u, Ae ? "" : m(")")], {
              shouldBreak: ge
            });
          }
          function L(ie, G, z) {
            var U = ie.getValue(),
              le = [];
            if (le.push(z("name")), U.value) {
              var ge;
              if (I(U.value)) {
                var Ne = A(U.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'),
                  _w6 = w(Ne, G.jsxSingleQuote ? "'" : '"'),
                  ke = _w6.escaped,
                  ce = _w6.quote,
                  pe = _w6.regex;
                Ne = Ne.replace(pe, ke), ge = [ce, Ne, ce];
              } else ge = z("value");
              le.push("=", ge);
            }
            return le;
          }
          function M(ie, G, z) {
            var U = ie.getValue(),
              le = function le(ge, Ae) {
                return ge.type === "JSXEmptyExpression" || !P(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (le(ge.argument, ge) || ge.argument.type === "JSXElement") || B(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || T(Ae) && (ge.type === "ConditionalExpression" || k(ge)));
              };
            return le(U.expression, ie.getParentNode(0)) ? i(["{", z("expression"), d, "}"]) : i(["{", o([u, z("expression")]), u, d, "}"]);
          }
          function j(ie, G, z) {
            var U = ie.getValue(),
              le = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);
            if (U.selfClosing && U.attributes.length === 0 && !le) return ["<", z("name"), z("typeParameters"), " />"];
            if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I(U.attributes[0].value) && !U.attributes[0].value.value.includes("\n") && !le && !P(U.attributes[0])) return i(["<", z("name"), z("typeParameters"), " "].concat(_toConsumableArray(ie.map(z, "attributes")), [U.selfClosing ? " />" : ">"]));
            var ge = U.attributes.length > 0 && P(h(U.attributes), C.Trailing),
              Ae = U.attributes.length === 0 && !le || (G.bracketSameLine || G.jsxBracketSameLine) && (!le || U.attributes.length > 0) && !ge,
              Ne = U.attributes && U.attributes.some(function (ce) {
                return ce.value && I(ce.value) && ce.value.value.includes("\n");
              }),
              ke = G.singleAttributePerLine && U.attributes.length > 1 ? r : a;
            return i(["<", z("name"), z("typeParameters"), o(ie.map(function () {
              return [ke, z()];
            }, "attributes")), U.selfClosing ? a : Ae ? ">" : u, U.selfClosing ? "/>" : Ae ? "" : ">"], {
              shouldBreak: Ne
            });
          }
          function $(ie, G, z) {
            var U = ie.getValue(),
              le = [];
            le.push("</");
            var ge = z("name");
            return P(U.name, C.Leading | C.Line) ? le.push(o([r, ge]), r) : P(U.name, C.Leading | C.Block) ? le.push(" ", ge) : le.push(ge), le.push(">"), le;
          }
          function V(ie, G) {
            var z = ie.getValue(),
              U = P(z),
              le = P(z, C.Line),
              ge = z.type === "JSXOpeningFragment";
            return [ge ? "<" : "</", o([le ? r : U && !ge ? " " : "", s(ie, G, !0)]), le ? r : "", ">"];
          }
          function q(ie, G, z) {
            var U = t(ie, E(ie, G, z), G);
            return b(ie, U, G);
          }
          function Y(ie, G) {
            var z = ie.getValue(),
              U = P(z, C.Line);
            return [s(ie, G, !U), U ? r : ""];
          }
          function H(ie, G, z) {
            var U = ie.getValue();
            return ["{", ie.call(function (le) {
              var ge = ["...", z()],
                Ae = le.getValue();
              return !P(Ae) || !F(le) ? ge : [o([u, t(le, ge, G)]), u];
            }, U.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function R(ie, G, z) {
            var U = ie.getValue();
            if (!!U.type.startsWith("JSX")) switch (U.type) {
              case "JSXAttribute":
                return L(ie, G, z);
              case "JSXIdentifier":
                return String(U.name);
              case "JSXNamespacedName":
                return p(":", [z("namespace"), z("name")]);
              case "JSXMemberExpression":
                return p(".", [z("object"), z("property")]);
              case "JSXSpreadAttribute":
                return H(ie, G, z);
              case "JSXSpreadChild":
                return H(ie, G, z);
              case "JSXExpressionContainer":
                return M(ie, G, z);
              case "JSXFragment":
              case "JSXElement":
                return q(ie, G, z);
              case "JSXOpeningElement":
                return j(ie, G, z);
              case "JSXClosingElement":
                return $(ie, G, z);
              case "JSXOpeningFragment":
              case "JSXClosingFragment":
                return V(ie, G);
              case "JSXEmptyExpression":
                return Y(ie, G);
              case "JSXText":
                throw new Error("JSXTest should be handled by JSXElement");
              default:
                throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type), "."));
            }
          }
          var Q = " \n\r\t",
            ee = new RegExp("([" + Q + "]+)"),
            te = new RegExp("[^" + Q + "]"),
            oe = function oe(ie) {
              return ie.replace(new RegExp("(?:^" + ee.source + "|" + ee.source + "$)"), "");
            };
          function W(ie) {
            if (ie.children.length === 0) return !0;
            if (ie.children.length > 1) return !1;
            var G = ie.children[0];
            return S(G) && !X(G);
          }
          function X(ie) {
            return S(ie) && (te.test(A(ie)) || !/\n/.test(A(ie)));
          }
          function ue(ie) {
            return ie.type === "JSXExpressionContainer" && S(ie.expression) && ie.expression.value === " " && !P(ie.expression);
          }
          function De(ie) {
            var G = ie.getValue(),
              z = ie.getParentNode();
            if (!z || !G || !T(G) || !T(z)) return !1;
            var U = z.children.indexOf(G),
              le = null;
            for (var ge = U; ge > 0; ge--) {
              var Ae = z.children[ge - 1];
              if (!(Ae.type === "JSXText" && !X(Ae))) {
                le = Ae;
                break;
              }
            }
            return le && le.type === "JSXExpressionContainer" && le.expression.type === "JSXEmptyExpression" && D(le.expression);
          }
          n.exports = {
            hasJsxIgnoreComment: De,
            printJsx: R
          };
        }
      }),
      ct = Z({
        "src/language-js/print/misc.js": function srcLanguageJsPrintMiscJs(e, n) {
          "use strict";

          re();
          var _Ue10 = Ue(),
            t = _Ue10.isNonEmptyArray,
            _Oe14 = Oe(),
            _Oe14$builders = _Oe14.builders,
            s = _Oe14$builders.indent,
            a = _Oe14$builders.join,
            r = _Oe14$builders.line,
            _Ke8 = Ke(),
            u = _Ke8.isFlowAnnotationComment;
          function i(h) {
            var w = h.getValue();
            return !w.optional || w.type === "Identifier" && w === h.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function o(h) {
            return h.getValue().definite || h.match(void 0, function (w, T) {
              return T === "id" && w.type === "VariableDeclarator" && w.definite;
            }) ? "!" : "";
          }
          function c(h, w, T) {
            var A = h.getValue();
            return A.typeArguments ? T("typeArguments") : A.typeParameters ? T("typeParameters") : "";
          }
          function v(h, w, T) {
            var A = h.getValue();
            if (!A.typeAnnotation) return "";
            var S = h.getParentNode(),
              B = S.type === "DeclareFunction" && S.id === A;
            return u(w.originalText, A.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [B ? "" : ": ", T("typeAnnotation")];
          }
          function m(h, w, T) {
            return ["::", T("callee")];
          }
          function d(h, w, T) {
            var A = h.getValue();
            return t(A.modifiers) ? [a(" ", h.map(T, "modifiers")), " "] : "";
          }
          function p(h, w, T) {
            return h.type === "EmptyStatement" ? ";" : h.type === "BlockStatement" || T ? [" ", w] : s([r, w]);
          }
          function f(h, w, T) {
            return ["...", T("argument"), v(h, w, T)];
          }
          n.exports = {
            printOptionalToken: i,
            printDefiniteToken: o,
            printFunctionTypeParameters: c,
            printBindExpressionCallee: m,
            printTypeScriptModifiers: d,
            printTypeAnnotation: v,
            printRestSpread: f,
            adjustClause: p
          };
        }
      }),
      Kt = Z({
        "src/language-js/print/array.js": function srcLanguageJsPrintArrayJs(e, n) {
          "use strict";

          re();
          var _et4 = et(),
            t = _et4.printDanglingComments,
            _Oe15 = Oe(),
            _Oe15$builders = _Oe15.builders,
            s = _Oe15$builders.line,
            a = _Oe15$builders.softline,
            r = _Oe15$builders.hardline,
            u = _Oe15$builders.group,
            i = _Oe15$builders.indent,
            o = _Oe15$builders.ifBreak,
            c = _Oe15$builders.fill,
            _Ue11 = Ue(),
            v = _Ue11.getLast,
            m = _Ue11.hasNewline,
            _Ke9 = Ke(),
            d = _Ke9.shouldPrintComma,
            p = _Ke9.hasComment,
            f = _Ke9.CommentCheckFlags,
            h = _Ke9.isNextLineEmpty,
            w = _Ke9.isNumericLiteral,
            T = _Ke9.isSignedNumericLiteral,
            _st3 = st(),
            A = _st3.locStart,
            _ct = ct(),
            S = _ct.printOptionalToken,
            B = _ct.printTypeAnnotation;
          function I(D, g, F) {
            var l = D.getValue(),
              E = [],
              y = l.type === "TupleExpression" ? "#[" : "[",
              N = "]";
            if (l.elements.length === 0) p(l, f.Dangling) ? E.push(u([y, t(D, g), a, N])) : E.push(y, N);else {
              var x = v(l.elements),
                b = !(x && x.type === "RestElement"),
                L = x === null,
                M = Symbol("array"),
                j = !g.__inJestEach && l.elements.length > 1 && l.elements.every(function (q, Y, H) {
                  var R = q && q.type;
                  if (R !== "ArrayExpression" && R !== "ObjectExpression") return !1;
                  var Q = H[Y + 1];
                  if (Q && R !== Q.type) return !1;
                  var ee = R === "ArrayExpression" ? "elements" : "properties";
                  return q[ee] && q[ee].length > 1;
                }),
                $ = k(l, g),
                V = b ? L ? "," : d(g) ? $ ? o(",", "", {
                  groupId: M
                }) : o(",") : "" : "";
              E.push(u([y, i([a, $ ? C(D, g, F, V) : [P(D, g, "elements", F), V], t(D, g, !0)]), a, N], {
                shouldBreak: j,
                id: M
              }));
            }
            return E.push(S(D), B(D, g, F)), E;
          }
          function k(D, g) {
            return D.elements.length > 1 && D.elements.every(function (F) {
              return F && (w(F) || T(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, function (l) {
                return !m(g.originalText, A(l), {
                  backwards: !0
                });
              });
            });
          }
          function P(D, g, F, l) {
            var E = [],
              y = [];
            return D.each(function (N) {
              E.push(y, u(l())), y = [",", s], N.getValue() && h(N.getValue(), g) && y.push(a);
            }, F), E;
          }
          function C(D, g, F, l) {
            var E = [];
            return D.each(function (y, N, x) {
              var b = N === x.length - 1;
              E.push([F(), b ? l : ","]), b || E.push(h(y.getValue(), g) ? [r, r] : p(x[N + 1], f.Leading | f.Line) ? r : s);
            }, "elements"), c(E);
          }
          n.exports = {
            printArray: I,
            printArrayItems: P,
            isConciselyPrintedArray: k
          };
        }
      }),
      io = Z({
        "src/language-js/print/call-arguments.js": function srcLanguageJsPrintCallArgumentsJs(e, n) {
          "use strict";

          re();
          var _et5 = et(),
            t = _et5.printDanglingComments,
            _Ue12 = Ue(),
            s = _Ue12.getLast,
            a = _Ue12.getPenultimate,
            _Ke10 = Ke(),
            r = _Ke10.getFunctionParameters,
            u = _Ke10.hasComment,
            i = _Ke10.CommentCheckFlags,
            o = _Ke10.isFunctionCompositionArgs,
            c = _Ke10.isJsxNode,
            v = _Ke10.isLongCurriedCallExpression,
            m = _Ke10.shouldPrintComma,
            d = _Ke10.getCallArguments,
            p = _Ke10.iterateCallArgumentsPath,
            f = _Ke10.isNextLineEmpty,
            h = _Ke10.isCallExpression,
            w = _Ke10.isStringLiteral,
            T = _Ke10.isObjectProperty,
            _Oe16 = Oe(),
            _Oe16$builders = _Oe16.builders,
            A = _Oe16$builders.line,
            S = _Oe16$builders.hardline,
            B = _Oe16$builders.softline,
            I = _Oe16$builders.group,
            k = _Oe16$builders.indent,
            P = _Oe16$builders.conditionalGroup,
            C = _Oe16$builders.ifBreak,
            D = _Oe16$builders.breakParent,
            g = _Oe16.utils.willBreak,
            _zt3 = zt(),
            F = _zt3.ArgExpansionBailout,
            _Kt = Kt(),
            l = _Kt.isConciselyPrintedArray;
          function E(j, $, V) {
            var q = j.getValue(),
              Y = q.type === "ImportExpression",
              H = d(q);
            if (H.length === 0) return ["(", t(j, $, !0), ")"];
            if (b(H)) return ["(", V(["arguments", 0]), ", ", V(["arguments", 1]), ")"];
            var R = !1,
              Q = !1,
              ee = H.length - 1,
              te = [];
            p(j, function (ie, G) {
              var z = ie.getNode(),
                U = [V()];
              G === ee || (f(z, $) ? (G === 0 && (Q = !0), R = !0, U.push(",", S, S)) : U.push(",", A)), te.push(U);
            });
            var oe = !(Y || q.callee && q.callee.type === "Import") && m($, "all") ? "," : "";
            function W() {
              return I(["(", k([A].concat(te)), oe, A, ")"], {
                shouldBreak: !0
              });
            }
            if (R || j.getParentNode().type !== "Decorator" && o(H)) return W();
            var X = x(H),
              ue = N(H, $);
            if (X || ue) {
              if (X ? te.slice(1).some(g) : te.slice(0, -1).some(g)) return W();
              var ie = [];
              try {
                j.try(function () {
                  p(j, function (G, z) {
                    X && z === 0 && (ie = [[V([], {
                      expandFirstArg: !0
                    }), te.length > 1 ? "," : "", Q ? S : A, Q ? S : ""]].concat(_toConsumableArray(te.slice(1)))), ue && z === ee && (ie = [].concat(_toConsumableArray(te.slice(0, -1)), [V([], {
                      expandLastArg: !0
                    })]));
                  });
                });
              } catch (G) {
                if (G instanceof F) return W();
                throw G;
              }
              return [te.some(g) ? D : "", P([["("].concat(_toConsumableArray(ie), [")"]), X ? ["(", I(ie[0], {
                shouldBreak: !0
              })].concat(_toConsumableArray(ie.slice(1)), [")"]) : ["("].concat(_toConsumableArray(te.slice(0, -1)), [I(s(ie), {
                shouldBreak: !0
              }), ")"]), W()])];
            }
            var De = ["(", k([B].concat(te)), C(oe), B, ")"];
            return v(j) ? De : I(De, {
              shouldBreak: te.some(g) || R
            });
          }
          function y(j) {
            var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return j.type === "ObjectExpression" && (j.properties.length > 0 || u(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || u(j)) || j.type === "TSTypeAssertion" && y(j.expression) || j.type === "TSAsExpression" && y(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && y(j.body, !0) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !$ && (h(j.body) || j.body.type === "ConditionalExpression") || c(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
          }
          function N(j, $) {
            var V = s(j),
              q = a(j);
            return !u(V, i.Leading) && !u(V, i.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== "ArrowFunctionExpression" || V.type !== "ArrayExpression") && !(j.length > 1 && V.type === "ArrayExpression" && l(V, $));
          }
          function x(j) {
            if (j.length !== 2) return !1;
            var _j2 = _slicedToArray(j, 2),
              $ = _j2[0],
              V = _j2[1];
            return $.type === "ModuleExpression" && M(V) ? !0 : !u($) && ($.type === "FunctionExpression" || $.type === "ArrowFunctionExpression" && $.body.type === "BlockStatement") && V.type !== "FunctionExpression" && V.type !== "ArrowFunctionExpression" && V.type !== "ConditionalExpression" && !y(V);
          }
          function b(j) {
            return j.length === 2 && j[0].type === "ArrowFunctionExpression" && r(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some(function ($) {
              return u($);
            });
          }
          function L(j) {
            return j.type === "BlockStatement" && (j.body.some(function ($) {
              return $.type !== "EmptyStatement";
            }) || u(j, i.Dangling));
          }
          function M(j) {
            return j.type === "ObjectExpression" && j.properties.length === 1 && T(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && w(j.properties[0].value) && j.properties[0].value.value === "module";
          }
          n.exports = E;
        }
      }),
      ao = Z({
        "src/language-js/print/member.js": function srcLanguageJsPrintMemberJs(e, n) {
          "use strict";

          re();
          var _Oe17 = Oe(),
            _Oe17$builders = _Oe17.builders,
            t = _Oe17$builders.softline,
            s = _Oe17$builders.group,
            a = _Oe17$builders.indent,
            r = _Oe17$builders.label,
            _Ke11 = Ke(),
            u = _Ke11.isNumericLiteral,
            i = _Ke11.isMemberExpression,
            o = _Ke11.isCallExpression,
            _ct2 = ct(),
            c = _ct2.printOptionalToken;
          function v(d, p, f) {
            var h = d.getValue(),
              w = d.getParentNode(),
              T,
              A = 0;
            do {
              T = d.getParentNode(A), A++;
            } while (T && (i(T) || T.type === "TSNonNullExpression"));
            var S = f("object"),
              B = m(d, p, f),
              I = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || h.computed || h.object.type === "Identifier" && h.property.type === "Identifier" && !i(w) || (w.type === "AssignmentExpression" || w.type === "VariableDeclarator") && (o(h.object) && h.object.arguments.length > 0 || h.object.type === "TSNonNullExpression" && o(h.object.expression) && h.object.expression.arguments.length > 0 || S.label === "member-chain");
            return r(S.label === "member-chain" ? "member-chain" : "member", [S, I ? B : s(a([t, B]))]);
          }
          function m(d, p, f) {
            var h = f("property"),
              w = d.getValue(),
              T = c(d);
            return w.computed ? !w.property || u(w.property) ? [T, "[", h, "]"] : s([T, "[", a([t, h]), t, "]"]) : [T, ".", h];
          }
          n.exports = {
            printMemberExpression: v,
            printMemberLookup: m
          };
        }
      }),
      Jm = Z({
        "src/language-js/print/member-chain.js": function srcLanguageJsPrintMemberChainJs(e, n) {
          "use strict";

          re();
          var _et6 = et(),
            t = _et6.printComments,
            _Ue13 = Ue(),
            s = _Ue13.getLast,
            a = _Ue13.isNextLineEmptyAfterIndex,
            r = _Ue13.getNextNonSpaceNonCommentCharacterIndex,
            u = jt(),
            _Ke12 = Ke(),
            i = _Ke12.isCallExpression,
            o = _Ke12.isMemberExpression,
            c = _Ke12.isFunctionOrArrowExpression,
            v = _Ke12.isLongCurriedCallExpression,
            m = _Ke12.isMemberish,
            d = _Ke12.isNumericLiteral,
            p = _Ke12.isSimpleCallArgument,
            f = _Ke12.hasComment,
            h = _Ke12.CommentCheckFlags,
            w = _Ke12.isNextLineEmpty,
            _st4 = st(),
            T = _st4.locEnd,
            _Oe18 = Oe(),
            _Oe18$builders = _Oe18.builders,
            A = _Oe18$builders.join,
            S = _Oe18$builders.hardline,
            B = _Oe18$builders.group,
            I = _Oe18$builders.indent,
            k = _Oe18$builders.conditionalGroup,
            P = _Oe18$builders.breakParent,
            C = _Oe18$builders.label,
            D = _Oe18.utils.willBreak,
            g = io(),
            _ao = ao(),
            F = _ao.printMemberLookup,
            _ct3 = ct(),
            l = _ct3.printOptionalToken,
            E = _ct3.printFunctionTypeParameters,
            y = _ct3.printBindExpressionCallee;
          function N(x, b, L) {
            var M = x.getParentNode(),
              j = !M || M.type === "ExpressionStatement",
              $ = [];
            function V(de) {
              var ae = b.originalText,
                ve = r(ae, de, T);
              return ae.charAt(ve) === ")" ? ve !== !1 && a(ae, ve + 1) : w(de, b);
            }
            function q(de) {
              var ae = de.getValue();
              i(ae) && (m(ae.callee) || i(ae.callee)) ? ($.unshift({
                node: ae,
                printed: [t(de, [l(de), E(de, b, L), g(de, b, L)], b), V(ae) ? S : ""]
              }), de.call(function (ve) {
                return q(ve);
              }, "callee")) : m(ae) ? ($.unshift({
                node: ae,
                needsParens: u(de, b),
                printed: t(de, o(ae) ? F(de, b, L) : y(de, b, L), b)
              }), de.call(function (ve) {
                return q(ve);
              }, "object")) : ae.type === "TSNonNullExpression" ? ($.unshift({
                node: ae,
                printed: t(de, "!", b)
              }), de.call(function (ve) {
                return q(ve);
              }, "expression")) : $.unshift({
                node: ae,
                printed: L()
              });
            }
            var Y = x.getValue();
            $.unshift({
              node: Y,
              printed: [l(x), E(x, b, L), g(x, b, L)]
            }), Y.callee && x.call(function (de) {
              return q(de);
            }, "callee");
            var H = [],
              R = [$[0]],
              Q = 1;
            for (; Q < $.length && ($[Q].node.type === "TSNonNullExpression" || i($[Q].node) || o($[Q].node) && $[Q].node.computed && d($[Q].node.property)); ++Q) {
              R.push($[Q]);
            }
            if (!i($[0].node)) for (; Q + 1 < $.length && m($[Q].node) && m($[Q + 1].node); ++Q) {
              R.push($[Q]);
            }
            H.push(R), R = [];
            var ee = !1;
            for (; Q < $.length; ++Q) {
              if (ee && m($[Q].node)) {
                if ($[Q].node.computed && d($[Q].node.property)) {
                  R.push($[Q]);
                  continue;
                }
                H.push(R), R = [], ee = !1;
              }
              (i($[Q].node) || $[Q].node.type === "ImportExpression") && (ee = !0), R.push($[Q]), f($[Q].node, h.Trailing) && (H.push(R), R = [], ee = !1);
            }
            R.length > 0 && H.push(R);
            function te(de) {
              return /^[A-Z]|^[$_]+$/.test(de);
            }
            function oe(de) {
              return de.length <= b.tabWidth;
            }
            function W(de) {
              var ae = de[1].length > 0 && de[1][0].node.computed;
              if (de[0].length === 1) {
                var K = de[0][0].node;
                return K.type === "ThisExpression" || K.type === "Identifier" && (te(K.name) || j && oe(K.name) || ae);
              }
              var ve = s(de[0]).node;
              return o(ve) && ve.property.type === "Identifier" && (te(ve.property.name) || ae);
            }
            var X = H.length >= 2 && !f(H[1][0].node) && W(H);
            function ue(de) {
              var ae = de.map(function (ve) {
                return ve.printed;
              });
              return de.length > 0 && s(de).needsParens ? ["("].concat(_toConsumableArray(ae), [")"]) : ae;
            }
            function De(de) {
              return de.length === 0 ? "" : I(B([S, A(S, de.map(ue))]));
            }
            var ie = H.map(ue),
              G = ie,
              z = X ? 3 : 2,
              U = H.flat(),
              le = U.slice(1, -1).some(function (de) {
                return f(de.node, h.Leading);
              }) || U.slice(0, -1).some(function (de) {
                return f(de.node, h.Trailing);
              }) || H[z] && f(H[z][0].node, h.Leading);
            if (H.length <= z && !le) return v(x) ? G : B(G);
            var ge = s(H[X ? 1 : 0]).node,
              Ae = !i(ge) && V(ge),
              Ne = [ue(H[0]), X ? H.slice(1, 2).map(ue) : "", Ae ? S : "", De(H.slice(X ? 2 : 1))],
              ke = $.map(function (de) {
                var ae = de.node;
                return ae;
              }).filter(i);
            function ce() {
              var de = s(s(H)).node,
                ae = s(ie);
              return i(de) && D(ae) && ke.slice(0, -1).some(function (ve) {
                return ve.arguments.some(c);
              });
            }
            var pe;
            return le || ke.length > 2 && ke.some(function (de) {
              return !de.arguments.every(function (ae) {
                return p(ae, 0);
              });
            }) || ie.slice(0, -1).some(D) || ce() ? pe = B(Ne) : pe = [D(G) || Ae ? P : "", k([G, Ne])], C("member-chain", pe);
          }
          n.exports = N;
        }
      }),
      oo = Z({
        "src/language-js/print/call-expression.js": function srcLanguageJsPrintCallExpressionJs(e, n) {
          "use strict";

          re();
          var _Oe19 = Oe(),
            _Oe19$builders = _Oe19.builders,
            t = _Oe19$builders.join,
            s = _Oe19$builders.group,
            a = jt(),
            _Ke13 = Ke(),
            r = _Ke13.getCallArguments,
            u = _Ke13.hasFlowAnnotationComment,
            i = _Ke13.isCallExpression,
            o = _Ke13.isMemberish,
            c = _Ke13.isStringLiteral,
            v = _Ke13.isTemplateOnItsOwnLine,
            m = _Ke13.isTestCall,
            d = _Ke13.iterateCallArgumentsPath,
            p = Jm(),
            f = io(),
            _ct4 = ct(),
            h = _ct4.printOptionalToken,
            w = _ct4.printFunctionTypeParameters;
          function T(S, B, I) {
            var k = S.getValue(),
              P = S.getParentNode(),
              C = k.type === "NewExpression",
              D = k.type === "ImportExpression",
              g = h(S),
              F = r(k);
            if (F.length > 0 && (!D && !C && A(k, P) || F.length === 1 && v(F[0], B.originalText) || !C && m(k, P))) {
              var y = [];
              return d(S, function () {
                y.push(I());
              }), [C ? "new " : "", I("callee"), g, w(S, B, I), "(", t(", ", y), ")"];
            }
            var l = (B.parser === "babel" || B.parser === "babel-flow") && k.callee && k.callee.type === "Identifier" && u(k.callee.trailingComments);
            if (l && (k.callee.trailingComments[0].printed = !0), !D && !C && o(k.callee) && !S.call(function (y) {
              return a(y, B);
            }, "callee")) return p(S, B, I);
            var E = [C ? "new " : "", D ? "import" : I("callee"), g, l ? "/*:: ".concat(k.callee.trailingComments[0].value.slice(2).trim(), " */") : "", w(S, B, I), f(S, B, I)];
            return D || i(k.callee) ? s(E) : E;
          }
          function A(S, B) {
            if (S.callee.type !== "Identifier") return !1;
            if (S.callee.name === "require") return !0;
            if (S.callee.name === "define") {
              var I = r(S);
              return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c(I[0]) && I[1].type === "ArrayExpression");
            }
            return !1;
          }
          n.exports = {
            printCallExpression: T
          };
        }
      }),
      Yt = Z({
        "src/language-js/print/assignment.js": function srcLanguageJsPrintAssignmentJs(e, n) {
          "use strict";

          re();
          var _Ue14 = Ue(),
            t = _Ue14.isNonEmptyArray,
            s = _Ue14.getStringWidth,
            _Oe20 = Oe(),
            _Oe20$builders = _Oe20.builders,
            a = _Oe20$builders.line,
            r = _Oe20$builders.group,
            u = _Oe20$builders.indent,
            i = _Oe20$builders.indentIfBreak,
            o = _Oe20$builders.lineSuffixBoundary,
            _Oe20$utils = _Oe20.utils,
            c = _Oe20$utils.cleanDoc,
            v = _Oe20$utils.willBreak,
            m = _Oe20$utils.canBreak,
            _Ke14 = Ke(),
            d = _Ke14.hasLeadingOwnLineComment,
            p = _Ke14.isBinaryish,
            f = _Ke14.isStringLiteral,
            h = _Ke14.isLiteral,
            w = _Ke14.isNumericLiteral,
            T = _Ke14.isCallExpression,
            A = _Ke14.isMemberExpression,
            S = _Ke14.getCallArguments,
            B = _Ke14.rawText,
            I = _Ke14.hasComment,
            k = _Ke14.isSignedNumericLiteral,
            P = _Ke14.isObjectProperty,
            _Jn2 = Jn(),
            C = _Jn2.shouldInlineLogicalExpression,
            _oo = oo(),
            D = _oo.printCallExpression;
          function g(W, X, ue, De, ie, G) {
            var z = E(W, X, ue, De, G),
              U = ue(G, {
                assignmentLayout: z
              });
            switch (z) {
              case "break-after-operator":
                return r([r(De), ie, r(u([a, U]))]);
              case "never-break-after-operator":
                return r([r(De), ie, " ", U]);
              case "fluid":
                {
                  var le = Symbol("assignment");
                  return r([r(De), ie, r(u(a), {
                    id: le
                  }), o, i(U, {
                    groupId: le
                  })]);
                }
              case "break-lhs":
                return r([De, ie, " ", r(U)]);
              case "chain":
                return [r(De), ie, a, U];
              case "chain-tail":
                return [r(De), ie, u([a, U])];
              case "chain-tail-arrow-chain":
                return [r(De), ie, U];
              case "only-left":
                return De;
            }
          }
          function F(W, X, ue) {
            var De = W.getValue();
            return g(W, X, ue, ue("left"), [" ", De.operator], "right");
          }
          function l(W, X, ue) {
            return g(W, X, ue, ue("id"), " =", "init");
          }
          function E(W, X, ue, De, ie) {
            var G = W.getValue(),
              z = G[ie];
            if (!z) return "only-left";
            var U = !x(z);
            if (W.match(x, b, function (Ne) {
              return !U || Ne.type !== "ExpressionStatement" && Ne.type !== "VariableDeclaration";
            })) return U ? z.type === "ArrowFunctionExpression" && z.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!U && x(z.right) || d(X.originalText, z)) return "break-after-operator";
            if (z.type === "CallExpression" && z.callee.name === "require" || X.parser === "json5" || X.parser === "json") return "never-break-after-operator";
            if (N(G) || L(G) || $(G) || V(G) && m(De)) return "break-lhs";
            var Ae = ee(G, De, X);
            return W.call(function () {
              return y(W, X, ue, Ae);
            }, ie) ? "break-after-operator" : Ae || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "BooleanLiteral" || w(z) || z.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function y(W, X, ue, De) {
            var ie = W.getValue();
            if (p(ie) && !C(ie)) return !0;
            switch (ie.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return !0;
              case "ConditionalExpression":
                {
                  var U = ie.test;
                  return p(U) && !C(U);
                }
              case "ClassExpression":
                return t(ie.decorators);
            }
            if (De) return !1;
            var G = ie,
              z = [];
            for (;;) {
              if (G.type === "UnaryExpression") G = G.argument, z.push("argument");else if (G.type === "TSNonNullExpression") G = G.expression, z.push("expression");else break;
            }
            return !!(f(G) || W.call.apply(W, [function () {
              return H(W, X, ue);
            }].concat(z)));
          }
          function N(W) {
            if (b(W)) {
              var X = W.left || W.id;
              return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some(function (ue) {
                return P(ue) && (!ue.shorthand || ue.value && ue.value.type === "AssignmentPattern");
              });
            }
            return !1;
          }
          function x(W) {
            return W.type === "AssignmentExpression";
          }
          function b(W) {
            return x(W) || W.type === "VariableDeclarator";
          }
          function L(W) {
            var X = M(W);
            if (t(X)) {
              var ue = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (X.length > 1 && X.some(function (De) {
                return De[ue] || De.default;
              })) return !0;
            }
            return !1;
          }
          function M(W) {
            return j(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function j(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function $(W) {
            if (W.type !== "VariableDeclarator") return !1;
            var X = W.id.typeAnnotation;
            if (!X || !X.typeAnnotation) return !1;
            var ue = q(X.typeAnnotation);
            return t(ue) && ue.length > 1 && ue.some(function (De) {
              return t(q(De)) || De.type === "TSConditionalType";
            });
          }
          function V(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function q(W) {
            return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Y(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function H(W, X, ue) {
            var De = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
              ie = W.getValue(),
              G = function G() {
                return H(W, X, ue, !0);
              };
            if (ie.type === "TSNonNullExpression") return W.call(G, "expression");
            if (T(ie)) {
              if (D(W, X, ue).label === "member-chain") return !1;
              var U = S(ie);
              return !(U.length === 0 || U.length === 1 && Q(U[0], X)) || te(ie, ue) ? !1 : W.call(G, "callee");
            }
            return A(ie) ? W.call(G, "object") : De && (ie.type === "Identifier" || ie.type === "ThisExpression");
          }
          var R = .25;
          function Q(W, X) {
            var ue = X.printWidth;
            if (I(W)) return !1;
            var De = ue * R;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= De || k(W) && !I(W.argument)) return !0;
            var ie = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return ie ? ie.length <= De : f(W) ? B(W).length <= De : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= De && !W.quasis[0].value.raw.includes("\n") : h(W);
          }
          function ee(W, X, ue) {
            if (!P(W)) return !1;
            X = c(X);
            var De = 3;
            return typeof X == "string" && s(X) < ue.tabWidth + De;
          }
          function te(W, X) {
            var ue = oe(W);
            if (t(ue)) {
              if (ue.length > 1) return !0;
              if (ue.length === 1) {
                var ie = ue[0];
                if (ie.type === "TSUnionType" || ie.type === "UnionTypeAnnotation" || ie.type === "TSIntersectionType" || ie.type === "IntersectionTypeAnnotation" || ie.type === "TSTypeLiteral" || ie.type === "ObjectTypeAnnotation") return !0;
              }
              var De = W.typeParameters ? "typeParameters" : "typeArguments";
              if (v(X(De))) return !0;
            }
            return !1;
          }
          function oe(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          n.exports = {
            printVariableDeclarator: l,
            printAssignmentExpression: F,
            printAssignment: g,
            isArrowFunctionVariableDeclarator: V
          };
        }
      }),
      Pr = Z({
        "src/language-js/print/function-parameters.js": function srcLanguageJsPrintFunctionParametersJs(e, n) {
          "use strict";

          re();
          var _Ue15 = Ue(),
            t = _Ue15.getNextNonSpaceNonCommentCharacter,
            _et7 = et(),
            s = _et7.printDanglingComments,
            _Oe21 = Oe(),
            _Oe21$builders = _Oe21.builders,
            a = _Oe21$builders.line,
            r = _Oe21$builders.hardline,
            u = _Oe21$builders.softline,
            i = _Oe21$builders.group,
            o = _Oe21$builders.indent,
            c = _Oe21$builders.ifBreak,
            _Oe21$utils = _Oe21.utils,
            v = _Oe21$utils.removeLines,
            m = _Oe21$utils.willBreak,
            _Ke15 = Ke(),
            d = _Ke15.getFunctionParameters,
            p = _Ke15.iterateFunctionParametersPath,
            f = _Ke15.isSimpleType,
            h = _Ke15.isTestCall,
            w = _Ke15.isTypeAnnotationAFunction,
            T = _Ke15.isObjectType,
            A = _Ke15.isObjectTypePropertyAFunction,
            S = _Ke15.hasRestParameter,
            B = _Ke15.shouldPrintComma,
            I = _Ke15.hasComment,
            k = _Ke15.isNextLineEmpty,
            _st5 = st(),
            P = _st5.locEnd,
            _zt4 = zt(),
            C = _zt4.ArgExpansionBailout,
            _ct5 = ct(),
            D = _ct5.printFunctionTypeParameters;
          function g(y, N, x, b, L) {
            var M = y.getValue(),
              j = d(M),
              $ = L ? D(y, x, N) : "";
            if (j.length === 0) return [$, "(", s(y, x, !0, function (ee) {
              return t(x.originalText, ee, P) === ")";
            }), ")"];
            var V = y.getParentNode(),
              q = h(V),
              Y = F(M),
              H = [];
            if (p(y, function (ee, te) {
              var oe = te === j.length - 1;
              oe && M.rest && H.push("..."), H.push(N()), !oe && (H.push(","), q || Y ? H.push(" ") : k(j[te], x) ? H.push(r, r) : H.push(a));
            }), b) {
              if (m($) || m(H)) throw new C();
              return i([v($), "(", v(H), ")"]);
            }
            var R = j.every(function (ee) {
              return !ee.decorators;
            });
            return Y && R ? [$, "("].concat(H, [")"]) : q ? [$, "("].concat(H, [")"]) : (A(V) || w(V) || V.type === "TypeAlias" || V.type === "UnionTypeAnnotation" || V.type === "TSUnionType" || V.type === "IntersectionTypeAnnotation" || V.type === "FunctionTypeAnnotation" && V.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && f(j[0].typeAnnotation) && !M.rest ? x.arrowParens === "always" ? ["("].concat(H, [")"]) : H : [$, "(", o([u].concat(H)), c(!S(M) && B(x, "all") ? "," : ""), u, ")"];
          }
          function F(y) {
            if (!y) return !1;
            var N = d(y);
            if (N.length !== 1) return !1;
            var _N3 = _slicedToArray(N, 1),
              x = _N3[0];
            return !I(x) && (x.type === "ObjectPattern" || x.type === "ArrayPattern" || x.type === "Identifier" && x.typeAnnotation && (x.typeAnnotation.type === "TypeAnnotation" || x.typeAnnotation.type === "TSTypeAnnotation") && T(x.typeAnnotation.typeAnnotation) || x.type === "FunctionTypeParam" && T(x.typeAnnotation) || x.type === "AssignmentPattern" && (x.left.type === "ObjectPattern" || x.left.type === "ArrayPattern") && (x.right.type === "Identifier" || x.right.type === "ObjectExpression" && x.right.properties.length === 0 || x.right.type === "ArrayExpression" && x.right.elements.length === 0));
          }
          function l(y) {
            var N;
            return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;
          }
          function E(y, N) {
            var x = l(y);
            if (!x) return !1;
            var b = y.typeParameters && y.typeParameters.params;
            if (b) {
              if (b.length > 1) return !1;
              if (b.length === 1) {
                var L = b[0];
                if (L.constraint || L.default) return !1;
              }
            }
            return d(y).length === 1 && (T(x) || m(N));
          }
          n.exports = {
            printFunctionParameters: g,
            shouldHugFunctionParameters: F,
            shouldGroupFunctionParameters: E
          };
        }
      }),
      kr = Z({
        "src/language-js/print/type-annotation.js": function srcLanguageJsPrintTypeAnnotationJs(e, n) {
          "use strict";

          re();
          var _et8 = et(),
            t = _et8.printComments,
            s = _et8.printDanglingComments,
            _Ue16 = Ue(),
            a = _Ue16.isNonEmptyArray,
            _Oe22 = Oe(),
            _Oe22$builders = _Oe22.builders,
            r = _Oe22$builders.group,
            u = _Oe22$builders.join,
            i = _Oe22$builders.line,
            o = _Oe22$builders.softline,
            c = _Oe22$builders.indent,
            v = _Oe22$builders.align,
            m = _Oe22$builders.ifBreak,
            d = jt(),
            _st6 = st(),
            p = _st6.locStart,
            _Ke16 = Ke(),
            f = _Ke16.isSimpleType,
            h = _Ke16.isObjectType,
            w = _Ke16.hasLeadingOwnLineComment,
            T = _Ke16.isObjectTypePropertyAFunction,
            A = _Ke16.shouldPrintComma,
            _Yt = Yt(),
            S = _Yt.printAssignment,
            _Pr = Pr(),
            B = _Pr.printFunctionParameters,
            I = _Pr.shouldGroupFunctionParameters,
            _Kt2 = Kt(),
            k = _Kt2.printArrayItems;
          function P(x) {
            if (f(x) || h(x)) return !0;
            if (x.type === "UnionTypeAnnotation" || x.type === "TSUnionType") {
              var b = x.types.filter(function (M) {
                  return M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword";
                }).length,
                L = x.types.some(function (M) {
                  return M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference";
                });
              if (x.types.length - 1 === b && L) return !0;
            }
            return !1;
          }
          function C(x, b, L) {
            var M = b.semi ? ";" : "",
              j = x.getValue(),
              $ = [];
            return $.push("opaque type ", L("id"), L("typeParameters")), j.supertype && $.push(": ", L("supertype")), j.impltype && $.push(" = ", L("impltype")), $.push(M), $;
          }
          function D(x, b, L) {
            var M = b.semi ? ";" : "",
              j = x.getValue(),
              $ = [];
            j.declare && $.push("declare "), $.push("type ", L("id"), L("typeParameters"));
            var V = j.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [S(x, b, L, $, " =", V), M];
          }
          function g(x, b, L) {
            var M = x.getValue(),
              j = x.map(L, "types"),
              $ = [],
              V = !1;
            for (var q = 0; q < j.length; ++q) {
              q === 0 ? $.push(j[q]) : h(M.types[q - 1]) && h(M.types[q]) ? $.push([" & ", V ? c(j[q]) : j[q]]) : !h(M.types[q - 1]) && !h(M.types[q]) ? $.push(c([" &", i, j[q]])) : (q > 1 && (V = !0), $.push(" & ", q > 1 ? c(j[q]) : j[q]));
            }
            return r($);
          }
          function F(x, b, L) {
            var M = x.getValue(),
              j = x.getParentNode(),
              $ = j.type !== "TypeParameterInstantiation" && j.type !== "TSTypeParameterInstantiation" && j.type !== "GenericTypeAnnotation" && j.type !== "TSTypeReference" && j.type !== "TSTypeAssertion" && j.type !== "TupleTypeAnnotation" && j.type !== "TSTupleType" && !(j.type === "FunctionTypeParam" && !j.name && x.getParentNode(1).this !== j) && !((j.type === "TypeAlias" || j.type === "VariableDeclarator" || j.type === "TSTypeAliasDeclaration") && w(b.originalText, M)),
              V = P(M),
              q = x.map(function (R) {
                var Q = L();
                return V || (Q = v(2, Q)), t(R, Q, b);
              }, "types");
            if (V) return u(" | ", q);
            var Y = $ && !w(b.originalText, M),
              H = [m([Y ? i : "", "| "]), u([i, "| "], q)];
            return d(x, b) ? r([c(H), o]) : j.type === "TupleTypeAnnotation" && j.types.length > 1 || j.type === "TSTupleType" && j.elementTypes.length > 1 ? r([c([m(["(", o]), H]), o, m(")")]) : r($ ? c(H) : H);
          }
          function l(x, b, L) {
            var M = x.getValue(),
              j = [],
              $ = x.getParentNode(0),
              V = x.getParentNode(1),
              q = x.getParentNode(2),
              Y = M.type === "TSFunctionType" || !(($.type === "ObjectTypeProperty" || $.type === "ObjectTypeInternalSlot") && !$.variance && !$.optional && p($) === p(M) || $.type === "ObjectTypeCallProperty" || q && q.type === "DeclareFunction"),
              H = Y && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation"),
              R = H && Y && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation") && V.type === "ArrowFunctionExpression";
            T($) && (Y = !0, H = !0), R && j.push("(");
            var Q = B(x, L, b, !1, !0),
              ee = M.returnType || M.predicate || M.typeAnnotation ? [Y ? " => " : ": ", L("returnType"), L("predicate"), L("typeAnnotation")] : "",
              te = I(M, ee);
            return j.push(te ? r(Q) : Q), ee && j.push(ee), R && j.push(")"), r(j);
          }
          function E(x, b, L) {
            var M = x.getValue(),
              j = M.type === "TSTupleType" ? "elementTypes" : "types",
              $ = M[j],
              V = a($),
              q = V ? o : "";
            return r(["[", c([q, k(x, b, j, L)]), m(V && A(b, "all") ? "," : ""), s(x, b, !0), q, "]"]);
          }
          function y(x, b, L) {
            var M = x.getValue(),
              j = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [L("objectType"), j, L("indexType"), "]"];
          }
          function N(x, b, L) {
            var M = x.getValue();
            return [M.postfix ? "" : L, b("typeAnnotation"), M.postfix ? L : ""];
          }
          n.exports = {
            printOpaqueType: C,
            printTypeAlias: D,
            printIntersectionType: g,
            printUnionType: F,
            printFunctionType: l,
            printTupleType: E,
            printIndexedAccessType: y,
            shouldHugType: P,
            printJSDocType: N
          };
        }
      }),
      Ir = Z({
        "src/language-js/print/type-parameters.js": function srcLanguageJsPrintTypeParametersJs(e, n) {
          "use strict";

          re();
          var _et9 = et(),
            t = _et9.printDanglingComments,
            _Oe23 = Oe(),
            _Oe23$builders = _Oe23.builders,
            s = _Oe23$builders.join,
            a = _Oe23$builders.line,
            r = _Oe23$builders.hardline,
            u = _Oe23$builders.softline,
            i = _Oe23$builders.group,
            o = _Oe23$builders.indent,
            c = _Oe23$builders.ifBreak,
            _Ke17 = Ke(),
            v = _Ke17.isTestCall,
            m = _Ke17.hasComment,
            d = _Ke17.CommentCheckFlags,
            p = _Ke17.isTSXFile,
            f = _Ke17.shouldPrintComma,
            h = _Ke17.getFunctionParameters,
            w = _Ke17.isObjectType,
            _Ue17 = Ue(),
            T = _Ue17.createGroupIdMapper,
            _kr = kr(),
            A = _kr.shouldHugType,
            _Yt2 = Yt(),
            S = _Yt2.isArrowFunctionVariableDeclarator,
            B = T("typeParameters");
          function I(C, D, g, F) {
            var l = C.getValue();
            if (!l[F]) return "";
            if (!Array.isArray(l[F])) return g(F);
            var E = C.getNode(2),
              y = E && v(E);
            if (!C.match(function (L) {
              return !(L[F].length === 1 && w(L[F][0]));
            }, void 0, function (L, M) {
              return M === "typeAnnotation";
            }, function (L) {
              return L.type === "Identifier";
            }, S) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === "NullableTypeAnnotation" || A(l[F][0])))) return ["<", s(", ", C.map(g, F)), k(C, D), ">"];
            var b = l.type === "TSTypeParameterInstantiation" ? "" : h(l).length === 1 && p(D) && !l[F][0].constraint && C.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D, "all") ? c(",") : "";
            return i(["<", o([u, s([",", a], C.map(g, F))]), b, u, ">"], {
              id: B(l)
            });
          }
          function k(C, D) {
            var g = C.getValue();
            if (!m(g, d.Dangling)) return "";
            var F = !m(g, d.Line),
              l = t(C, D, F);
            return F ? l : [l, r];
          }
          function P(C, D, g) {
            var F = C.getValue(),
              l = [],
              E = C.getParentNode();
            return E.type === "TSMappedType" ? (l.push("[", g("name")), F.constraint && l.push(" in ", g("constraint")), E.nameType && l.push(" as ", C.callParent(function () {
              return g("nameType");
            })), l.push("]"), l) : (F.variance && l.push(g("variance")), F.in && l.push("in "), F.out && l.push("out "), l.push(g("name")), F.bound && l.push(": ", g("bound")), F.constraint && l.push(" extends ", g("constraint")), F.default && l.push(" = ", g("default")), l);
          }
          n.exports = {
            printTypeParameter: P,
            printTypeParameters: I,
            getTypeParametersGroupId: B
          };
        }
      }),
      Qt = Z({
        "src/language-js/print/property.js": function srcLanguageJsPrintPropertyJs(e, n) {
          "use strict";

          re();
          var _et10 = et(),
            t = _et10.printComments,
            _Ue18 = Ue(),
            s = _Ue18.printString,
            a = _Ue18.printNumber,
            _Ke18 = Ke(),
            r = _Ke18.isNumericLiteral,
            u = _Ke18.isSimpleNumber,
            i = _Ke18.isStringLiteral,
            o = _Ke18.isStringPropSafeToUnquote,
            c = _Ke18.rawText,
            _Yt3 = Yt(),
            v = _Yt3.printAssignment,
            m = new WeakMap();
          function d(f, h, w) {
            var T = f.getNode();
            if (T.computed) return ["[", w("key"), "]"];
            var A = f.getParentNode(),
              S = T.key;
            if (T.type === "ClassPrivateProperty" && S.type === "Identifier") return ["#", w("key")];
            if (h.quoteProps === "consistent" && !m.has(A)) {
              var B = (A.properties || A.body || A.members).some(function (I) {
                return !I.computed && I.key && i(I.key) && !o(I, h);
              });
              m.set(A, B);
            }
            if ((S.type === "Identifier" || r(S) && u(a(c(S))) && String(S.value) === a(c(S)) && !(h.parser === "typescript" || h.parser === "babel-ts")) && (h.parser === "json" || h.quoteProps === "consistent" && m.get(A))) {
              var _B = s(JSON.stringify(S.type === "Identifier" ? S.name : S.value.toString()), h);
              return f.call(function (I) {
                return t(I, _B, h);
              }, "key");
            }
            return o(T, h) && (h.quoteProps === "as-needed" || h.quoteProps === "consistent" && !m.get(A)) ? f.call(function (B) {
              return t(B, /^\d/.test(S.value) ? a(S.value) : S.value, h);
            }, "key") : w("key");
          }
          function p(f, h, w) {
            return f.getValue().shorthand ? w("value") : v(f, h, w, d(f, h, w), ":", "value");
          }
          n.exports = {
            printProperty: p,
            printPropertyKey: d
          };
        }
      }),
      Lr = Z({
        "src/language-js/print/function.js": function srcLanguageJsPrintFunctionJs(e, n) {
          "use strict";

          re();
          var t = Xt(),
            _et11 = et(),
            s = _et11.printDanglingComments,
            a = _et11.printCommentsSeparately,
            r = it(),
            _Ue19 = Ue(),
            u = _Ue19.getNextNonSpaceNonCommentCharacterIndex,
            _Oe24 = Oe(),
            _Oe24$builders = _Oe24.builders,
            i = _Oe24$builders.line,
            o = _Oe24$builders.softline,
            c = _Oe24$builders.group,
            v = _Oe24$builders.indent,
            m = _Oe24$builders.ifBreak,
            d = _Oe24$builders.hardline,
            p = _Oe24$builders.join,
            f = _Oe24$builders.indentIfBreak,
            _Oe24$utils = _Oe24.utils,
            h = _Oe24$utils.removeLines,
            w = _Oe24$utils.willBreak,
            _zt5 = zt(),
            T = _zt5.ArgExpansionBailout,
            _Ke19 = Ke(),
            A = _Ke19.getFunctionParameters,
            S = _Ke19.hasLeadingOwnLineComment,
            B = _Ke19.isFlowAnnotationComment,
            I = _Ke19.isJsxNode,
            k = _Ke19.isTemplateOnItsOwnLine,
            P = _Ke19.shouldPrintComma,
            C = _Ke19.startsWithNoLookaheadToken,
            D = _Ke19.isBinaryish,
            g = _Ke19.isLineComment,
            F = _Ke19.hasComment,
            l = _Ke19.getComments,
            E = _Ke19.CommentCheckFlags,
            y = _Ke19.isCallLikeExpression,
            N = _Ke19.isCallExpression,
            x = _Ke19.getCallArguments,
            b = _Ke19.hasNakedLeftSide,
            L = _Ke19.getLeftSide,
            _st7 = st(),
            M = _st7.locEnd,
            _Pr2 = Pr(),
            j = _Pr2.printFunctionParameters,
            $ = _Pr2.shouldGroupFunctionParameters,
            _Qt = Qt(),
            V = _Qt.printPropertyKey,
            _ct6 = ct(),
            q = _ct6.printFunctionTypeParameters;
          function Y(z, U, le, ge) {
            var Ae = z.getValue(),
              Ne = !1;
            if ((Ae.type === "FunctionDeclaration" || Ae.type === "FunctionExpression") && ge && ge.expandLastArg) {
              var ae = z.getParentNode();
              N(ae) && x(ae).length > 1 && (Ne = !0);
            }
            var ke = [];
            Ae.type === "TSDeclareFunction" && Ae.declare && ke.push("declare "), Ae.async && ke.push("async "), Ae.generator ? ke.push("function* ") : ke.push("function "), Ae.id && ke.push(U("id"));
            var ce = j(z, U, le, Ne),
              pe = X(z, U, le),
              de = $(Ae, pe);
            return ke.push(q(z, le, U), c([de ? c(ce) : ce, pe]), Ae.body ? " " : "", U("body")), le.semi && (Ae.declare || !Ae.body) && ke.push(";"), ke;
          }
          function H(z, U, le) {
            var ge = z.getNode(),
              Ae = ge.kind,
              Ne = ge.value || ge,
              ke = [];
            return !Ae || Ae === "init" || Ae === "method" || Ae === "constructor" ? Ne.async && ke.push("async ") : (t.ok(Ae === "get" || Ae === "set"), ke.push(Ae, " ")), Ne.generator && ke.push("*"), ke.push(V(z, U, le), ge.optional || ge.key.optional ? "?" : ""), ge === Ne ? ke.push(R(z, U, le)) : Ne.type === "FunctionExpression" ? ke.push(z.call(function (ce) {
              return R(ce, U, le);
            }, "value")) : ke.push(le("value")), ke;
          }
          function R(z, U, le) {
            var ge = z.getNode(),
              Ae = j(z, le, U),
              Ne = X(z, le, U),
              ke = $(ge, Ne),
              ce = [q(z, U, le), c([ke ? c(Ae) : Ae, Ne])];
            return ge.body ? ce.push(" ", le("body")) : ce.push(U.semi ? ";" : ""), ce;
          }
          function Q(z, U, le, ge) {
            var Ae = z.getValue(),
              Ne = [];
            if (Ae.async && Ne.push("async "), W(z, U)) Ne.push(le(["params", 0]));else {
              var ce = ge && (ge.expandLastArg || ge.expandFirstArg),
                pe = X(z, le, U);
              if (ce) {
                if (w(pe)) throw new T();
                pe = c(h(pe));
              }
              Ne.push(c([j(z, le, U, ce, !0), pe]));
            }
            var ke = s(z, U, !0, function (ce) {
              var pe = u(U.originalText, ce, M);
              return pe !== !1 && U.originalText.slice(pe, pe + 2) === "=>";
            });
            return ke && Ne.push(" ", ke), Ne;
          }
          function ee(z, U, le, ge, Ae, Ne) {
            var ke = z.getName(),
              ce = z.getParentNode(),
              pe = y(ce) && ke === "callee",
              de = Boolean(U && U.assignmentLayout),
              ae = Ne.body.type !== "BlockStatement" && Ne.body.type !== "ObjectExpression" && Ne.body.type !== "SequenceExpression",
              ve = pe && ae || U && U.assignmentLayout === "chain-tail-arrow-chain",
              K = Symbol("arrow-chain");
            return Ne.body.type === "SequenceExpression" && (Ae = c(["(", v([o, Ae]), o, ")"])), c([c(v([pe || de ? o : "", c(p([" =>", i], le), {
              shouldBreak: ge
            })]), {
              id: K,
              shouldBreak: ve
            }), " =>", f(ae ? v([i, Ae]) : [" ", Ae], {
              groupId: K
            }), pe ? m(o, "", {
              groupId: K
            }) : ""]);
          }
          function te(z, U, le, ge) {
            var Ae = z.getValue(),
              Ne = [],
              ke = [],
              ce = !1;
            if (function K() {
              var he = Q(z, U, le, ge);
              if (Ne.length === 0) Ne.push(he);else {
                var _a4 = a(z, U),
                  ye = _a4.leading,
                  Ce = _a4.trailing;
                Ne.push([ye, he]), ke.unshift(Ce);
              }
              ce = ce || Ae.returnType && A(Ae).length > 0 || Ae.typeParameters || A(Ae).some(function (ye) {
                return ye.type !== "Identifier";
              }), Ae.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? ke.unshift(le("body", ge)) : (Ae = Ae.body, z.call(K, "body"));
            }(), Ne.length > 1) return ee(z, ge, Ne, ce, ke, Ae);
            var pe = Ne;
            if (pe.push(" =>"), !S(U.originalText, Ae.body) && (Ae.body.type === "ArrayExpression" || Ae.body.type === "ObjectExpression" || Ae.body.type === "BlockStatement" || I(Ae.body) || k(Ae.body, U.originalText) || Ae.body.type === "ArrowFunctionExpression" || Ae.body.type === "DoExpression")) return c([].concat(pe, [" ", ke]));
            if (Ae.body.type === "SequenceExpression") return c([].concat(pe, [c([" (", v([o, ke]), o, ")"])]));
            var de = (ge && ge.expandLastArg || z.getParentNode().type === "JSXExpressionContainer") && !F(Ae),
              ae = ge && ge.expandLastArg && P(U, "all"),
              ve = Ae.body.type === "ConditionalExpression" && !C(Ae.body, !1);
            return c([].concat(pe, [c([v([i, ve ? m("", "(") : "", ke, ve ? m("", ")") : ""]), de ? [m(ae ? "," : ""), o] : ""])]));
          }
          function oe(z) {
            var U = A(z);
            return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === "Identifier" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;
          }
          function W(z, U) {
            if (U.arrowParens === "always") return !1;
            if (U.arrowParens === "avoid") {
              var le = z.getValue();
              return oe(le);
            }
            return !1;
          }
          function X(z, U, le) {
            var ge = z.getValue(),
              Ae = U("returnType");
            if (ge.returnType && B(le.originalText, ge.returnType)) return [" /*: ", Ae, " */"];
            var Ne = [Ae];
            return ge.returnType && ge.returnType.typeAnnotation && Ne.unshift(": "), ge.predicate && Ne.push(ge.returnType ? " " : ": ", U("predicate")), Ne;
          }
          function ue(z, U, le) {
            var ge = z.getValue(),
              Ae = U.semi ? ";" : "",
              Ne = [];
            ge.argument && (G(U, ge.argument) ? Ne.push([" (", v([d, le("argument")]), d, ")"]) : D(ge.argument) || ge.argument.type === "SequenceExpression" ? Ne.push(c([m(" (", " "), v([o, le("argument")]), o, m(")")])) : Ne.push(" ", le("argument")));
            var ke = l(ge),
              ce = r(ke),
              pe = ce && g(ce);
            return pe && Ne.push(Ae), F(ge, E.Dangling) && Ne.push(" ", s(z, U, !0)), pe || Ne.push(Ae), Ne;
          }
          function De(z, U, le) {
            return ["return", ue(z, U, le)];
          }
          function ie(z, U, le) {
            return ["throw", ue(z, U, le)];
          }
          function G(z, U) {
            if (S(z.originalText, U)) return !0;
            if (b(U)) {
              var le = U,
                ge;
              for (; ge = L(le);) {
                if (le = ge, S(z.originalText, le)) return !0;
              }
            }
            return !1;
          }
          n.exports = {
            printFunction: Y,
            printArrowFunction: te,
            printMethod: H,
            printReturnStatement: De,
            printThrowStatement: ie,
            printMethodInternal: R,
            shouldPrintParamsWithoutParens: W
          };
        }
      }),
      Un = Z({
        "src/language-js/print/decorators.js": function srcLanguageJsPrintDecoratorsJs(e, n) {
          "use strict";

          re();
          var _Ue20 = Ue(),
            t = _Ue20.isNonEmptyArray,
            s = _Ue20.hasNewline,
            _Oe25 = Oe(),
            _Oe25$builders = _Oe25.builders,
            a = _Oe25$builders.line,
            r = _Oe25$builders.hardline,
            u = _Oe25$builders.join,
            i = _Oe25$builders.breakParent,
            o = _Oe25$builders.group,
            _st8 = st(),
            c = _st8.locStart,
            v = _st8.locEnd,
            _Ke20 = Ke(),
            m = _Ke20.getParentExportDeclaration;
          function d(T, A, S) {
            var B = T.getValue();
            return o([u(a, T.map(S, "decorators")), h(B, A) ? r : a]);
          }
          function p(T, A, S) {
            return [u(r, T.map(S, "declaration", "decorators")), r];
          }
          function f(T, A, S) {
            var B = T.getValue(),
              I = B.decorators;
            if (!t(I) || w(T.getParentNode())) return;
            var k = B.type === "ClassExpression" || B.type === "ClassDeclaration" || h(B, A);
            return [m(T) ? r : k ? i : "", u(a, T.map(S, "decorators")), a];
          }
          function h(T, A) {
            return T.decorators.some(function (S) {
              return s(A.originalText, v(S));
            });
          }
          function w(T) {
            if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration") return !1;
            var A = T.declaration && T.declaration.decorators;
            return t(A) && c(T, {
              ignoreDecorators: !0
            }) > c(A[0]);
          }
          n.exports = {
            printDecorators: f,
            printClassMemberDecorators: d,
            printDecoratorsBeforeExport: p,
            hasDecoratorsBeforeExport: w
          };
        }
      }),
      Zt = Z({
        "src/language-js/print/class.js": function srcLanguageJsPrintClassJs(e, n) {
          "use strict";

          re();
          var _Ue21 = Ue(),
            t = _Ue21.isNonEmptyArray,
            s = _Ue21.createGroupIdMapper,
            _et12 = et(),
            a = _et12.printComments,
            r = _et12.printDanglingComments,
            _Oe26 = Oe(),
            _Oe26$builders = _Oe26.builders,
            u = _Oe26$builders.join,
            i = _Oe26$builders.line,
            o = _Oe26$builders.hardline,
            c = _Oe26$builders.softline,
            v = _Oe26$builders.group,
            m = _Oe26$builders.indent,
            d = _Oe26$builders.ifBreak,
            _Ke21 = Ke(),
            p = _Ke21.hasComment,
            f = _Ke21.CommentCheckFlags,
            _Ir = Ir(),
            h = _Ir.getTypeParametersGroupId,
            _Lr = Lr(),
            w = _Lr.printMethod,
            _ct7 = ct(),
            T = _ct7.printOptionalToken,
            A = _ct7.printTypeAnnotation,
            S = _ct7.printDefiniteToken,
            _Qt2 = Qt(),
            B = _Qt2.printPropertyKey,
            _Yt4 = Yt(),
            I = _Yt4.printAssignment,
            _Un = Un(),
            k = _Un.printClassMemberDecorators;
          function P(x, b, L) {
            var M = x.getValue(),
              j = [];
            M.declare && j.push("declare "), M.abstract && j.push("abstract "), j.push("class");
            var $ = M.id && p(M.id, f.Trailing) || M.typeParameters && p(M.typeParameters, f.Trailing) || M.superClass && p(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements),
              V = [],
              q = [];
            if (M.id && V.push(" ", L("id")), V.push(L("typeParameters")), M.superClass) {
              var Y = [E(x, b, L), L("superTypeParameters")],
                H = x.call(function (R) {
                  return ["extends ", a(R, Y, b)];
                }, "superClass");
              $ ? q.push(i, v(H)) : q.push(" ", H);
            } else q.push(l(x, b, L, "extends"));
            if (q.push(l(x, b, L, "mixins"), l(x, b, L, "implements")), $) {
              var _Y2;
              F(M) ? _Y2 = [].concat(V, [m(q)]) : _Y2 = m([].concat(V, [q])), j.push(v(_Y2, {
                id: C(M)
              }));
            } else j.push.apply(j, V.concat(q));
            return j.push(" ", L("body")), j;
          }
          var C = s("heritageGroup");
          function D(x) {
            return d(o, "", {
              groupId: C(x)
            });
          }
          function g(x) {
            return ["superClass", "extends", "mixins", "implements"].filter(function (b) {
              return Boolean(x[b]);
            }).length > 1;
          }
          function F(x) {
            return x.typeParameters && !p(x.typeParameters, f.Trailing | f.Line) && !g(x);
          }
          function l(x, b, L, M) {
            var j = x.getValue();
            if (!t(j[M])) return "";
            var $ = r(x, b, !0, function (V) {
              var q = V.marker;
              return q === M;
            });
            return [F(j) ? d(" ", i, {
              groupId: h(j.typeParameters)
            }) : i, $, $ && o, M, v(m([i, u([",", i], x.map(L, M))]))];
          }
          function E(x, b, L) {
            var M = L("superClass");
            return x.getParentNode().type === "AssignmentExpression" ? v(d(["(", m([c, M]), c, ")"], M)) : M;
          }
          function y(x, b, L) {
            var M = x.getValue(),
              j = [];
            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.readonly && j.push("readonly "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), j.push(w(x, b, L)), j;
          }
          function N(x, b, L) {
            var M = x.getValue(),
              j = [],
              $ = b.semi ? ";" : "";
            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), M.readonly && j.push("readonly "), M.variance && j.push(L("variance")), M.type === "ClassAccessorProperty" && j.push("accessor "), j.push(B(x, b, L), T(x), S(x), A(x, b, L)), [I(x, b, L, j, " =", "value"), $];
          }
          n.exports = {
            printClass: P,
            printClassMethod: y,
            printClassProperty: N,
            printHardlineAfterHeritage: D
          };
        }
      }),
      lo = Z({
        "src/language-js/print/interface.js": function srcLanguageJsPrintInterfaceJs(e, n) {
          "use strict";

          re();
          var _Ue22 = Ue(),
            t = _Ue22.isNonEmptyArray,
            _Oe27 = Oe(),
            _Oe27$builders = _Oe27.builders,
            s = _Oe27$builders.join,
            a = _Oe27$builders.line,
            r = _Oe27$builders.group,
            u = _Oe27$builders.indent,
            i = _Oe27$builders.ifBreak,
            _Ke22 = Ke(),
            o = _Ke22.hasComment,
            c = _Ke22.identity,
            v = _Ke22.CommentCheckFlags,
            _Ir2 = Ir(),
            m = _Ir2.getTypeParametersGroupId,
            _ct8 = ct(),
            d = _ct8.printTypeScriptModifiers;
          function p(f, h, w) {
            var T = f.getValue(),
              A = [];
            T.declare && A.push("declare "), T.type === "TSInterfaceDeclaration" && A.push(T.abstract ? "abstract " : "", d(f, h, w)), A.push("interface");
            var S = [],
              B = [];
            T.type !== "InterfaceTypeAnnotation" && S.push(" ", w("id"), w("typeParameters"));
            var I = T.typeParameters && !o(T.typeParameters, v.Trailing | v.Line);
            return t(T.extends) && B.push(I ? i(" ", a, {
              groupId: m(T.typeParameters)
            }) : a, "extends ", (T.extends.length === 1 ? c : u)(s([",", a], f.map(w, "extends")))), T.id && o(T.id, v.Trailing) || t(T.extends) ? I ? A.push(r([].concat(S, [u(B)]))) : A.push(r(u([].concat(S, B)))) : A.push.apply(A, S.concat(B)), A.push(" ", w("body")), r(A);
          }
          n.exports = {
            printInterface: p
          };
        }
      }),
      co = Z({
        "src/language-js/print/module.js": function srcLanguageJsPrintModuleJs(e, n) {
          "use strict";

          re();
          var _Ue23 = Ue(),
            t = _Ue23.isNonEmptyArray,
            _Oe28 = Oe(),
            _Oe28$builders = _Oe28.builders,
            s = _Oe28$builders.softline,
            a = _Oe28$builders.group,
            r = _Oe28$builders.indent,
            u = _Oe28$builders.join,
            i = _Oe28$builders.line,
            o = _Oe28$builders.ifBreak,
            c = _Oe28$builders.hardline,
            _et13 = et(),
            v = _et13.printDanglingComments,
            _Ke23 = Ke(),
            m = _Ke23.hasComment,
            d = _Ke23.CommentCheckFlags,
            p = _Ke23.shouldPrintComma,
            f = _Ke23.needsHardlineAfterDanglingComment,
            h = _Ke23.isStringLiteral,
            w = _Ke23.rawText,
            _st9 = st(),
            T = _st9.locStart,
            A = _st9.hasSameLoc,
            _Un2 = Un(),
            S = _Un2.hasDecoratorsBeforeExport,
            B = _Un2.printDecoratorsBeforeExport;
          function I(N, x, b) {
            var L = N.getValue(),
              M = x.semi ? ";" : "",
              j = [],
              $ = L.importKind;
            return j.push("import"), $ && $ !== "value" && j.push(" ", $), j.push(g(N, x, b), D(N, x, b), l(N, x, b), M), j;
          }
          function k(N, x, b) {
            var L = N.getValue(),
              M = [];
            S(L) && M.push(B(N, x, b));
            var j = L.type,
              $ = L.exportKind,
              V = L.declaration;
            return M.push("export"), (L.default || j === "ExportDefaultDeclaration") && M.push(" default"), m(L, d.Dangling) && (M.push(" ", v(N, x, !0)), f(L) && M.push(c)), V ? M.push(" ", b("declaration")) : M.push($ === "type" ? " type" : "", g(N, x, b), D(N, x, b), l(N, x, b)), C(L, x) && M.push(";"), M;
          }
          function P(N, x, b) {
            var L = N.getValue(),
              M = x.semi ? ";" : "",
              j = [],
              $ = L.exportKind,
              V = L.exported;
            return j.push("export"), $ === "type" && j.push(" type"), j.push(" *"), V && j.push(" as ", b("exported")), j.push(D(N, x, b), l(N, x, b), M), j;
          }
          function C(N, x) {
            if (!x.semi) return !1;
            var b = N.type,
              L = N.declaration,
              M = N.default || b === "ExportDefaultDeclaration";
            if (!L) return !0;
            var j = L.type;
            return !!(M && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
          }
          function D(N, x, b) {
            var L = N.getValue();
            if (!L.source) return "";
            var M = [];
            return F(L, x) || M.push(" from"), M.push(" ", b("source")), M;
          }
          function g(N, x, b) {
            var L = N.getValue();
            if (F(L, x)) return "";
            var M = [" "];
            if (t(L.specifiers)) {
              var j = [],
                $ = [];
              N.each(function () {
                var V = N.getValue().type;
                if (V === "ExportNamespaceSpecifier" || V === "ExportDefaultSpecifier" || V === "ImportNamespaceSpecifier" || V === "ImportDefaultSpecifier") j.push(b());else if (V === "ExportSpecifier" || V === "ImportSpecifier") $.push(b());else throw new Error("Unknown specifier type ".concat(JSON.stringify(V)));
              }, "specifiers"), M.push(u(", ", j)), $.length > 0 && (j.length > 0 && M.push(", "), $.length > 1 || j.length > 0 || L.specifiers.some(function (q) {
                return m(q);
              }) ? M.push(a(["{", r([x.bracketSpacing ? i : s, u([",", i], $)]), o(p(x) ? "," : ""), x.bracketSpacing ? i : s, "}"])) : M.push(["{", x.bracketSpacing ? " " : ""].concat($, [x.bracketSpacing ? " " : "", "}"])));
            } else M.push("{}");
            return M;
          }
          function F(N, x) {
            var b = N.type,
              L = N.importKind,
              M = N.source,
              j = N.specifiers;
            return b !== "ImportDeclaration" || t(j) || L === "type" ? !1 : !/{\s*}/.test(x.originalText.slice(T(N), T(M)));
          }
          function l(N, x, b) {
            var L = N.getNode();
            return t(L.assertions) ? [" assert {", x.bracketSpacing ? " " : "", u(", ", N.map(b, "assertions")), x.bracketSpacing ? " " : "", "}"] : "";
          }
          function E(N, x, b) {
            var L = N.getNode(),
              M = L.type,
              j = [],
              $ = M === "ImportSpecifier" ? L.importKind : L.exportKind;
            $ && $ !== "value" && j.push($, " ");
            var V = M.startsWith("Import"),
              q = V ? "imported" : "local",
              Y = V ? "local" : "exported",
              H = L[q],
              R = L[Y],
              Q = "",
              ee = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Q = "*" : H && (Q = b(q)), R && !y(L) && (ee = b(Y)), j.push(Q, Q && ee ? " as " : "", ee), j;
          }
          function y(N) {
            if (N.type !== "ImportSpecifier" && N.type !== "ExportSpecifier") return !1;
            var x = N.local,
              b = N[N.type === "ImportSpecifier" ? "imported" : "exported"];
            if (x.type !== b.type || !A(x, b)) return !1;
            if (h(x)) return x.value === b.value && w(x) === w(b);
            switch (x.type) {
              case "Identifier":
                return x.name === b.name;
              default:
                return !1;
            }
          }
          n.exports = {
            printImportDeclaration: I,
            printExportDeclaration: k,
            printExportAllDeclaration: P,
            printModuleSpecifier: E
          };
        }
      }),
      zn = Z({
        "src/language-js/print/object.js": function srcLanguageJsPrintObjectJs(e, n) {
          "use strict";

          re();
          var _et14 = et(),
            t = _et14.printDanglingComments,
            _Oe29 = Oe(),
            _Oe29$builders = _Oe29.builders,
            s = _Oe29$builders.line,
            a = _Oe29$builders.softline,
            r = _Oe29$builders.group,
            u = _Oe29$builders.indent,
            i = _Oe29$builders.ifBreak,
            o = _Oe29$builders.hardline,
            _Ue24 = Ue(),
            c = _Ue24.getLast,
            v = _Ue24.hasNewlineInRange,
            m = _Ue24.hasNewline,
            d = _Ue24.isNonEmptyArray,
            _Ke24 = Ke(),
            p = _Ke24.shouldPrintComma,
            f = _Ke24.hasComment,
            h = _Ke24.getComments,
            w = _Ke24.CommentCheckFlags,
            T = _Ke24.isNextLineEmpty,
            _st10 = st(),
            A = _st10.locStart,
            S = _st10.locEnd,
            _ct9 = ct(),
            B = _ct9.printOptionalToken,
            I = _ct9.printTypeAnnotation,
            _Pr3 = Pr(),
            k = _Pr3.shouldHugFunctionParameters,
            _kr2 = kr(),
            P = _kr2.shouldHugType,
            _Zt = Zt(),
            C = _Zt.printHardlineAfterHeritage;
          function D(g, F, l) {
            var E = F.semi ? ";" : "",
              y = g.getValue(),
              N;
            y.type === "TSTypeLiteral" ? N = "members" : y.type === "TSInterfaceBody" ? N = "body" : N = "properties";
            var x = y.type === "ObjectTypeAnnotation",
              b = [N];
            x && b.push("indexers", "callProperties", "internalSlots");
            var L = b.map(function (W) {
                return y[W][0];
              }).sort(function (W, X) {
                return A(W) - A(X);
              })[0],
              M = g.getParentNode(0),
              j = x && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && g.getName() === "body",
              $ = y.type === "TSInterfaceBody" || j || y.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && y.properties.some(function (W) {
                return W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern");
              }) || y.type !== "ObjectPattern" && L && v(F.originalText, A(y), A(L)),
              V = j ? ";" : y.type === "TSInterfaceBody" || y.type === "TSTypeLiteral" ? i(E, ";") : ",",
              q = y.type === "RecordExpression" ? "#{" : y.exact ? "{|" : "{",
              Y = y.exact ? "|}" : "}",
              H = [];
            for (var _i13 = 0, _b8 = b; _i13 < _b8.length; _i13++) {
              var W = _b8[_i13];
              g.each(function (X) {
                var ue = X.getValue();
                H.push({
                  node: ue,
                  printed: l(),
                  loc: A(ue)
                });
              }, W);
            }
            b.length > 1 && H.sort(function (W, X) {
              return W.loc - X.loc;
            });
            var R = [],
              Q = H.map(function (W) {
                var X = [].concat(_toConsumableArray(R), [r(W.printed)]);
                return R = [V, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, w.PrettierIgnore) && R.shift(), T(W.node, F) && R.push(o), X;
              });
            if (y.inexact) {
              var _W3;
              if (f(y, w.Dangling)) {
                var X = f(y, w.Line);
                _W3 = [t(g, F, !0), X || m(F.originalText, S(c(h(y)))) ? o : s, "..."];
              } else _W3 = ["..."];
              Q.push([].concat(_toConsumableArray(R), _toConsumableArray(_W3)));
            }
            var ee = c(y[N]),
              te = !(y.inexact || ee && ee.type === "RestElement" || ee && (ee.type === "TSPropertySignature" || ee.type === "TSCallSignatureDeclaration" || ee.type === "TSMethodSignature" || ee.type === "TSConstructSignatureDeclaration") && f(ee, w.PrettierIgnore)),
              oe;
            if (Q.length === 0) {
              if (!f(y, w.Dangling)) return [q, Y, I(g, F, l)];
              oe = r([q, t(g, F), a, Y, B(g), I(g, F, l)]);
            } else oe = [j && d(y.properties) ? C(M) : "", q, u([F.bracketSpacing ? s : a].concat(_toConsumableArray(Q))), i(te && (V !== "," || p(F)) ? V : ""), F.bracketSpacing ? s : a, Y, B(g), I(g, F, l)];
            return g.match(function (W) {
              return W.type === "ObjectPattern" && !W.decorators;
            }, function (W, X, ue) {
              return k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0;
            }) || g.match(P, function (W, X) {
              return X === "typeAnnotation";
            }, function (W, X) {
              return X === "typeAnnotation";
            }, function (W, X, ue) {
              return k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0;
            }) || !$ && g.match(function (W) {
              return W.type === "ObjectPattern";
            }, function (W) {
              return W.type === "AssignmentExpression" || W.type === "VariableDeclarator";
            }) ? oe : r(oe, {
              shouldBreak: $
            });
          }
          n.exports = {
            printObject: D
          };
        }
      }),
      Um = Z({
        "src/language-js/print/flow.js": function srcLanguageJsPrintFlowJs(e, n) {
          "use strict";

          re();
          var t = Xt(),
            _et15 = et(),
            s = _et15.printDanglingComments,
            _Ue25 = Ue(),
            a = _Ue25.printString,
            r = _Ue25.printNumber,
            _Oe30 = Oe(),
            _Oe30$builders = _Oe30.builders,
            u = _Oe30$builders.hardline,
            i = _Oe30$builders.softline,
            o = _Oe30$builders.group,
            c = _Oe30$builders.indent,
            _Ke25 = Ke(),
            v = _Ke25.getParentExportDeclaration,
            m = _Ke25.isFunctionNotation,
            d = _Ke25.isGetterOrSetter,
            p = _Ke25.rawText,
            f = _Ke25.shouldPrintComma,
            _st11 = st(),
            h = _st11.locStart,
            w = _st11.locEnd,
            _Zt2 = Zt(),
            T = _Zt2.printClass,
            _kr3 = kr(),
            A = _kr3.printOpaqueType,
            S = _kr3.printTypeAlias,
            B = _kr3.printIntersectionType,
            I = _kr3.printUnionType,
            k = _kr3.printFunctionType,
            P = _kr3.printTupleType,
            C = _kr3.printIndexedAccessType,
            _lo = lo(),
            D = _lo.printInterface,
            _Ir3 = Ir(),
            g = _Ir3.printTypeParameter,
            F = _Ir3.printTypeParameters,
            _co = co(),
            l = _co.printExportDeclaration,
            E = _co.printExportAllDeclaration,
            _Kt3 = Kt(),
            y = _Kt3.printArrayItems,
            _zn = zn(),
            N = _zn.printObject,
            _Qt3 = Qt(),
            x = _Qt3.printPropertyKey,
            _ct10 = ct(),
            b = _ct10.printOptionalToken,
            L = _ct10.printTypeAnnotation,
            M = _ct10.printRestSpread;
          function j(V, q, Y) {
            var H = V.getValue(),
              R = q.semi ? ";" : "",
              Q = [];
            switch (H.type) {
              case "DeclareClass":
                return $(V, T(V, q, Y));
              case "DeclareFunction":
                return $(V, ["function ", Y("id"), H.predicate ? " " : "", Y("predicate"), R]);
              case "DeclareModule":
                return $(V, ["module ", Y("id"), " ", Y("body")]);
              case "DeclareModuleExports":
                return $(V, ["module.exports", ": ", Y("typeAnnotation"), R]);
              case "DeclareVariable":
                return $(V, ["var ", Y("id"), R]);
              case "DeclareOpaqueType":
                return $(V, A(V, q, Y));
              case "DeclareInterface":
                return $(V, D(V, q, Y));
              case "DeclareTypeAlias":
                return $(V, S(V, q, Y));
              case "DeclareExportDeclaration":
                return $(V, l(V, q, Y));
              case "DeclareExportAllDeclaration":
                return $(V, E(V, q, Y));
              case "OpaqueType":
                return A(V, q, Y);
              case "TypeAlias":
                return S(V, q, Y);
              case "IntersectionTypeAnnotation":
                return B(V, q, Y);
              case "UnionTypeAnnotation":
                return I(V, q, Y);
              case "FunctionTypeAnnotation":
                return k(V, q, Y);
              case "TupleTypeAnnotation":
                return P(V, q, Y);
              case "GenericTypeAnnotation":
                return [Y("id"), F(V, q, Y, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return C(V, q, Y);
              case "TypeAnnotation":
                return Y("typeAnnotation");
              case "TypeParameter":
                return g(V, q, Y);
              case "TypeofTypeAnnotation":
                return ["typeof ", Y("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [Y("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(H.value);
              case "EnumDeclaration":
                return ["enum ", Y("id"), " ", Y("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody":
                {
                  if (H.type === "EnumSymbolBody" || H.explicitType) {
                    var ee = null;
                    switch (H.type) {
                      case "EnumBooleanBody":
                        ee = "boolean";
                        break;
                      case "EnumNumberBody":
                        ee = "number";
                        break;
                      case "EnumStringBody":
                        ee = "string";
                        break;
                      case "EnumSymbolBody":
                        ee = "symbol";
                        break;
                    }
                    Q.push("of ", ee, " ");
                  }
                  if (H.members.length === 0 && !H.hasUnknownMembers) Q.push(o(["{", s(V, q), i, "}"]));else {
                    var _ee3 = H.members.length > 0 ? [u, y(V, q, "members", Y), H.hasUnknownMembers || f(q) ? "," : ""] : [];
                    Q.push(o(["{", c([].concat(_ee3, _toConsumableArray(H.hasUnknownMembers ? [u, "..."] : []))), s(V, q, !0), u, "}"]));
                  }
                  return Q;
                }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [Y("id"), " = ", _typeof(H.init) == "object" ? Y("init") : String(H.init)];
              case "EnumDefaultedMember":
                return Y("id");
              case "FunctionTypeParam":
                {
                  var _ee4 = H.name ? Y("name") : V.getParentNode().this === H ? "this" : "";
                  return [_ee4, b(V), _ee4 ? ": " : "", Y("typeAnnotation")];
                }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return D(V, q, Y);
              case "ClassImplements":
              case "InterfaceExtends":
                return [Y("id"), Y("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", Y("typeAnnotation")];
              case "Variance":
                {
                  var _ee5 = H.kind;
                  return t.ok(_ee5 === "plus" || _ee5 === "minus"), _ee5 === "plus" ? "+" : "-";
                }
              case "ObjectTypeCallProperty":
                return H.static && Q.push("static "), Q.push(Y("value")), Q;
              case "ObjectTypeIndexer":
                return [H.static ? "static " : "", H.variance ? Y("variance") : "", "[", Y("id"), H.id ? ": " : "", Y("key"), "]: ", Y("value")];
              case "ObjectTypeProperty":
                {
                  var _ee6 = "";
                  return H.proto ? _ee6 = "proto " : H.static && (_ee6 = "static "), [_ee6, d(H) ? H.kind + " " : "", H.variance ? Y("variance") : "", x(V, q, Y), b(V), m(H) ? "" : ": ", Y("value")];
                }
              case "ObjectTypeAnnotation":
                return N(V, q, Y);
              case "ObjectTypeInternalSlot":
                return [H.static ? "static " : "", "[[", Y("id"), "]]", b(V), H.method ? "" : ": ", Y("value")];
              case "ObjectTypeSpreadProperty":
                return M(V, q, Y);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [Y("qualification"), ".", Y("id")];
              case "StringLiteralTypeAnnotation":
                return a(p(H), q);
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(_typeof(H.value), "number");
              case "BigIntLiteralTypeAnnotation":
                return H.extra ? r(H.extra.raw) : r(H.raw);
              case "TypeCastExpression":
                return ["(", Y("expression"), L(V, q, Y), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation":
                {
                  var _ee7 = F(V, q, Y, "params");
                  if (q.parser === "flow") {
                    var te = h(H),
                      oe = w(H),
                      W = q.originalText.lastIndexOf("/*", te),
                      X = q.originalText.indexOf("*/", oe);
                    if (W !== -1 && X !== -1) {
                      var ue = q.originalText.slice(W + 2, X).trim();
                      if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/")) return ["/*:: ", _ee7, " */"];
                    }
                  }
                  return _ee7;
                }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", Y("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(H.type));
            }
          }
          function $(V, q) {
            var Y = v(V);
            return Y ? (t.strictEqual(Y.type, "DeclareExportDeclaration"), q) : ["declare ", q];
          }
          n.exports = {
            printFlow: j
          };
        }
      }),
      zm = Z({
        "src/language-js/utils/is-ts-keyword-type.js": function srcLanguageJsUtilsIsTsKeywordTypeJs(e, n) {
          "use strict";

          re();
          function t(s) {
            var a = s.type;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          n.exports = t;
        }
      }),
      po = Z({
        "src/language-js/print/ternary.js": function srcLanguageJsPrintTernaryJs(e, n) {
          "use strict";

          re();
          var _Ue26 = Ue(),
            t = _Ue26.hasNewlineInRange,
            _Ke26 = Ke(),
            s = _Ke26.isJsxNode,
            a = _Ke26.getComments,
            r = _Ke26.isCallExpression,
            u = _Ke26.isMemberExpression,
            _st12 = st(),
            i = _st12.locStart,
            o = _st12.locEnd,
            c = It(),
            _Oe31 = Oe(),
            _Oe31$builders = _Oe31.builders,
            v = _Oe31$builders.line,
            m = _Oe31$builders.softline,
            d = _Oe31$builders.group,
            p = _Oe31$builders.indent,
            f = _Oe31$builders.align,
            h = _Oe31$builders.ifBreak,
            w = _Oe31$builders.dedent,
            T = _Oe31$builders.breakParent;
          function A(P) {
            var C = [P];
            for (var D = 0; D < C.length; D++) {
              var g = C[D];
              for (var _i14 = 0, _arr4 = ["test", "consequent", "alternate"]; _i14 < _arr4.length; _i14++) {
                var F = _arr4[_i14];
                var l = g[F];
                if (s(l)) return !0;
                l.type === "ConditionalExpression" && C.push(l);
              }
            }
            return !1;
          }
          function S(P, C, D) {
            var g = P.getValue(),
              F = g.type === "ConditionalExpression",
              l = F ? "alternate" : "falseType",
              E = P.getParentNode(),
              y = F ? D("test") : [D("checkType"), " ", "extends", " ", D("extendsType")];
            return E.type === g.type && E[l] === g ? f(2, y) : y;
          }
          var B = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function I(P) {
            var C = P.getValue();
            if (C.type !== "ConditionalExpression") return !1;
            var D,
              g = C;
            for (var F = 0; !D; F++) {
              var l = P.getParentNode(F);
              if (r(l) && l.callee === g || u(l) && l.object === g || l.type === "TSNonNullExpression" && l.expression === g) {
                g = l;
                continue;
              }
              l.type === "NewExpression" && l.callee === g || l.type === "TSAsExpression" && l.expression === g ? (D = P.getParentNode(F + 1), g = l) : D = l;
            }
            return g === C ? !1 : D[B.get(D.type)] === g;
          }
          function k(P, C, D) {
            var g = P.getValue(),
              F = g.type === "ConditionalExpression",
              l = F ? "consequent" : "trueType",
              E = F ? "alternate" : "falseType",
              y = F ? ["test"] : ["checkType", "extendsType"],
              N = g[l],
              x = g[E],
              b = [],
              L = !1,
              M = P.getParentNode(),
              j = M.type === g.type && y.some(function (ue) {
                return M[ue] === g;
              }),
              $ = M.type === g.type && !j,
              V,
              q,
              Y = 0;
            do {
              q = V || g, V = P.getParentNode(Y), Y++;
            } while (V && V.type === g.type && y.every(function (ue) {
              return V[ue] !== q;
            }));
            var H = V || M,
              R = q;
            if (F && (s(g[y[0]]) || s(N) || s(x) || A(R))) {
              L = !0, $ = !0;
              var ue = function ue(ie) {
                  return [h("("), p([m, ie]), m, h(")")];
                },
                De = function De(ie) {
                  return ie.type === "NullLiteral" || ie.type === "Literal" && ie.value === null || ie.type === "Identifier" && ie.name === "undefined";
                };
              b.push(" ? ", De(N) ? D(l) : ue(D(l)), " : ", x.type === g.type || De(x) ? D(E) : ue(D(E)));
            } else {
              var _ue = [v, "? ", N.type === g.type ? h("", "(") : "", f(2, D(l)), N.type === g.type ? h("", ")") : "", v, ": ", x.type === g.type ? D(E) : f(2, D(E))];
              b.push(M.type !== g.type || M[E] === g || j ? _ue : C.useTabs ? w(p(_ue)) : f(Math.max(0, C.tabWidth - 2), _ue));
            }
            var ee = [].concat(_toConsumableArray(y.map(function (ue) {
                return a(g[ue]);
              })), [a(N), a(x)]).flat().some(function (ue) {
                return c(ue) && t(C.originalText, i(ue), o(ue));
              }),
              te = function te(ue) {
                return M === H ? d(ue, {
                  shouldBreak: ee
                }) : ee ? [ue, T] : ue;
              },
              oe = !L && (u(M) || M.type === "NGPipeExpression" && M.left === g) && !M.computed,
              W = I(P),
              X = te([S(P, C, D), $ ? b : p(b), F && oe && !W ? m : ""]);
            return j || W ? d([p([m, X]), m]) : X;
          }
          n.exports = {
            printTernary: k
          };
        }
      }),
      fo = Z({
        "src/language-js/print/statement.js": function srcLanguageJsPrintStatementJs(e, n) {
          "use strict";

          re();
          var _Oe32 = Oe(),
            t = _Oe32.builders.hardline,
            s = jt(),
            _Ke27 = Ke(),
            a = _Ke27.getLeftSidePathName,
            r = _Ke27.hasNakedLeftSide,
            u = _Ke27.isJsxNode,
            i = _Ke27.isTheOnlyJsxElementInMarkdown,
            o = _Ke27.hasComment,
            c = _Ke27.CommentCheckFlags,
            v = _Ke27.isNextLineEmpty,
            _Lr2 = Lr(),
            m = _Lr2.shouldPrintParamsWithoutParens;
          function d(B, I, k, P) {
            var C = B.getValue(),
              D = [],
              g = C.type === "ClassBody",
              F = p(C[P]);
            return B.each(function (l, E, y) {
              var N = l.getValue();
              if (N.type === "EmptyStatement") return;
              var x = k();
              !I.semi && !g && !i(I, l) && f(l, I) ? o(N, c.Leading) ? D.push(k([], {
                needsSemi: !0
              })) : D.push(";", x) : D.push(x), !I.semi && g && A(N) && S(N, y[E + 1]) && D.push(";"), N !== F && (D.push(t), v(N, I) && D.push(t));
            }, P), D;
          }
          function p(B) {
            for (var I = B.length - 1; I >= 0; I--) {
              var k = B[I];
              if (k.type !== "EmptyStatement") return k;
            }
          }
          function f(B, I) {
            return B.getNode().type !== "ExpressionStatement" ? !1 : B.call(function (P) {
              return h(P, I);
            }, "expression");
          }
          function h(B, I) {
            var k = B.getValue();
            switch (k.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return !0;
              case "ArrowFunctionExpression":
                {
                  if (!m(B, I)) return !0;
                  break;
                }
              case "UnaryExpression":
                {
                  var P = k.prefix,
                    C = k.operator;
                  if (P && (C === "+" || C === "-")) return !0;
                  break;
                }
              case "BindExpression":
                {
                  if (!k.object) return !0;
                  break;
                }
              case "Literal":
                {
                  if (k.regex) return !0;
                  break;
                }
              default:
                if (u(k)) return !0;
            }
            return s(B, I) ? !0 : r(k) ? B.call.apply(B, [function (P) {
              return h(P, I);
            }].concat(_toConsumableArray(a(B, k)))) : !1;
          }
          function w(B, I, k) {
            return d(B, I, k, "body");
          }
          function T(B, I, k) {
            return d(B, I, k, "consequent");
          }
          var A = function A(B) {
            var I = B.type;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty";
          };
          function S(B, I) {
            var k = B.key && B.key.name;
            if ((k === "static" || k === "get" || k === "set") && !B.value && !B.typeAnnotation) return !0;
            if (!I || I.static || I.accessibility) return !1;
            if (!I.computed) {
              var P = I.key && I.key.name;
              if (P === "in" || P === "instanceof") return !0;
            }
            if (A(I) && I.variance && !I.static && !I.declare) return !0;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod":
                {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set") return !1;
                  var C = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || C);
                }
              case "TSIndexSignature":
                return !0;
            }
            return !1;
          }
          n.exports = {
            printBody: w,
            printSwitchCaseConsequent: T
          };
        }
      }),
      Do = Z({
        "src/language-js/print/block.js": function srcLanguageJsPrintBlockJs(e, n) {
          "use strict";

          re();
          var _et16 = et(),
            t = _et16.printDanglingComments,
            _Ue27 = Ue(),
            s = _Ue27.isNonEmptyArray,
            _Oe33 = Oe(),
            _Oe33$builders = _Oe33.builders,
            a = _Oe33$builders.hardline,
            r = _Oe33$builders.indent,
            _Ke28 = Ke(),
            u = _Ke28.hasComment,
            i = _Ke28.CommentCheckFlags,
            o = _Ke28.isNextLineEmpty,
            _Zt3 = Zt(),
            c = _Zt3.printHardlineAfterHeritage,
            _fo = fo(),
            v = _fo.printBody;
          function m(p, f, h) {
            var w = p.getValue(),
              T = [];
            if (w.type === "StaticBlock" && T.push("static "), w.type === "ClassBody" && s(w.body)) {
              var S = p.getParentNode();
              T.push(c(S));
            }
            T.push("{");
            var A = d(p, f, h);
            if (A) T.push(r([a, A]), a);else {
              var _S = p.getParentNode(),
                B = p.getParentNode(1);
              _S.type === "ArrowFunctionExpression" || _S.type === "FunctionExpression" || _S.type === "FunctionDeclaration" || _S.type === "ObjectMethod" || _S.type === "ClassMethod" || _S.type === "ClassPrivateMethod" || _S.type === "ForStatement" || _S.type === "WhileStatement" || _S.type === "DoWhileStatement" || _S.type === "DoExpression" || _S.type === "CatchClause" && !B.finalizer || _S.type === "TSModuleDeclaration" || _S.type === "TSDeclareFunction" || w.type === "StaticBlock" || w.type === "ClassBody" || T.push(a);
            }
            return T.push("}"), T;
          }
          function d(p, f, h) {
            var w = p.getValue(),
              T = s(w.directives),
              A = w.body.some(function (I) {
                return I.type !== "EmptyStatement";
              }),
              S = u(w, i.Dangling);
            if (!T && !A && !S) return "";
            var B = [];
            if (T && p.each(function (I, k, P) {
              B.push(h()), (k < P.length - 1 || A || S) && (B.push(a), o(I.getValue(), f) && B.push(a));
            }, "directives"), A && B.push(v(p, f, h)), S && B.push(t(p, f, !0)), w.type === "Program") {
              var I = p.getParentNode();
              (!I || I.type !== "ModuleExpression") && B.push(a);
            }
            return B;
          }
          n.exports = {
            printBlock: m,
            printBlockBody: d
          };
        }
      }),
      Xm = Z({
        "src/language-js/print/typescript.js": function srcLanguageJsPrintTypescriptJs(e, n) {
          "use strict";

          re();
          var _et17 = et(),
            t = _et17.printDanglingComments,
            _Ue28 = Ue(),
            s = _Ue28.hasNewlineInRange,
            _Oe34 = Oe(),
            _Oe34$builders = _Oe34.builders,
            a = _Oe34$builders.join,
            r = _Oe34$builders.line,
            u = _Oe34$builders.hardline,
            i = _Oe34$builders.softline,
            o = _Oe34$builders.group,
            c = _Oe34$builders.indent,
            v = _Oe34$builders.conditionalGroup,
            m = _Oe34$builders.ifBreak,
            _Ke29 = Ke(),
            d = _Ke29.isLiteral,
            p = _Ke29.getTypeScriptMappedTypeModifier,
            f = _Ke29.shouldPrintComma,
            h = _Ke29.isCallExpression,
            w = _Ke29.isMemberExpression,
            T = zm(),
            _st13 = st(),
            A = _st13.locStart,
            S = _st13.locEnd,
            _ct11 = ct(),
            B = _ct11.printOptionalToken,
            I = _ct11.printTypeScriptModifiers,
            _po = po(),
            k = _po.printTernary,
            _Pr4 = Pr(),
            P = _Pr4.printFunctionParameters,
            C = _Pr4.shouldGroupFunctionParameters,
            _Lt5 = Lt(),
            D = _Lt5.printTemplateLiteral,
            _Kt4 = Kt(),
            g = _Kt4.printArrayItems,
            _zn2 = zn(),
            F = _zn2.printObject,
            _Zt4 = Zt(),
            l = _Zt4.printClassProperty,
            E = _Zt4.printClassMethod,
            _Ir4 = Ir(),
            y = _Ir4.printTypeParameter,
            N = _Ir4.printTypeParameters,
            _Qt4 = Qt(),
            x = _Qt4.printPropertyKey,
            _Lr3 = Lr(),
            b = _Lr3.printFunction,
            L = _Lr3.printMethodInternal,
            _lo2 = lo(),
            M = _lo2.printInterface,
            _Do = Do(),
            j = _Do.printBlock,
            _kr4 = kr(),
            $ = _kr4.printTypeAlias,
            V = _kr4.printIntersectionType,
            q = _kr4.printUnionType,
            Y = _kr4.printFunctionType,
            H = _kr4.printTupleType,
            R = _kr4.printIndexedAccessType,
            Q = _kr4.printJSDocType;
          function ee(te, oe, W) {
            var X = te.getValue();
            if (!X.type.startsWith("TS")) return;
            if (T(X)) return X.type.slice(2, -7).toLowerCase();
            var ue = oe.semi ? ";" : "",
              De = [];
            switch (X.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion":
                {
                  var ie = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"),
                    G = o(["<", c([i, W("typeAnnotation")]), i, ">"]),
                    z = [m("("), c([i, W("expression")]), i, m(")")];
                  return ie ? v([[G, W("expression")], [G, o(z, {
                    shouldBreak: !0
                  })], [G, W("expression")]]) : o([G, W("expression")]);
                }
              case "TSDeclareFunction":
                return b(te, W, oe);
              case "TSExportAssignment":
                return ["export = ", W("expression"), ue];
              case "TSModuleBlock":
                return j(te, oe, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return F(te, oe, W);
              case "TSTypeAliasDeclaration":
                return $(te, oe, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return E(te, oe, W);
              case "TSAbstractPropertyDefinition":
                return l(te, oe, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return De.push(W("expression")), X.typeParameters && De.push(W("typeParameters")), De;
              case "TSTemplateLiteralType":
                return D(te, W, oe);
              case "TSNamedTupleMember":
                return [W("label"), X.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(te, oe, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return N(te, oe, W, "params");
              case "TSTypeParameter":
                return y(te, oe, W);
              case "TSAsExpression":
                {
                  De.push(W("expression"), " as ", W("typeAnnotation"));
                  var _ie = te.getParentNode();
                  return h(_ie) && _ie.callee === X || w(_ie) && _ie.object === X ? o([c([i].concat(De)), i]) : De;
                }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return X.readonly && De.push("readonly "), De.push(x(te, oe, W), B(te)), X.typeAnnotation && De.push(": ", W("typeAnnotation")), X.initializer && De.push(" = ", W("initializer")), De;
              case "TSParameterProperty":
                return X.accessibility && De.push(X.accessibility + " "), X.export && De.push("export "), X.static && De.push("static "), X.override && De.push("override "), X.readonly && De.push("readonly "), De.push(W("parameter")), De;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature":
                {
                  var _ie2 = te.getParentNode(),
                    _G = X.parameters.length > 1 ? m(f(oe) ? "," : "") : "",
                    _z = o([c([i, a([", ", i], te.map(W, "parameters"))]), _G, i]);
                  return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? _z : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W("typeAnnotation") : "", _ie2.type === "ClassBody" ? ue : ""];
                }
              case "TSTypePredicate":
                return [X.asserts ? "asserts " : "", W("parameterName"), X.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [X.isTypeOf ? "typeof " : "", "import(", W(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W("qualifier")] : "", N(te, oe, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return R(te, oe, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType":
                {
                  if (X.type === "TSConstructorType" && X.abstract && De.push("abstract "), X.type !== "TSCallSignatureDeclaration" && De.push("new "), De.push(o(P(te, W, oe, !1, !0))), X.returnType || X.typeAnnotation) {
                    var _ie3 = X.type === "TSConstructorType";
                    De.push(_ie3 ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return De;
                }
              case "TSTypeOperator":
                return [X.operator, " ", W("typeAnnotation")];
              case "TSMappedType":
                {
                  var _ie4 = s(oe.originalText, A(X), S(X));
                  return o(["{", c([oe.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, "readonly"), " "] : "", I(te, oe, W), W("typeParameter"), X.optional ? p(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W("typeAnnotation"), m(ue)]), t(te, oe, !0), oe.bracketSpacing ? r : i, "}"], {
                    shouldBreak: _ie4
                  });
                }
              case "TSMethodSignature":
                {
                  var _ie5 = X.kind && X.kind !== "method" ? "".concat(X.kind, " ") : "";
                  De.push(X.accessibility ? [X.accessibility, " "] : "", _ie5, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W("key"), X.computed ? "]" : "", B(te));
                  var _G2 = P(te, W, oe, !1, !0),
                    _z2 = X.returnType ? "returnType" : "typeAnnotation",
                    U = X[_z2],
                    le = U ? W(_z2) : "",
                    ge = C(X, le);
                  return De.push(ge ? o(_G2) : _G2), U && De.push(": ", o(le)), o(De);
                }
              case "TSNamespaceExportDeclaration":
                return De.push("export as namespace ", W("id")), oe.semi && De.push(";"), o(De);
              case "TSEnumDeclaration":
                return X.declare && De.push("declare "), X.modifiers && De.push(I(te, oe, W)), X.const && De.push("const "), De.push("enum ", W("id"), " "), X.members.length === 0 ? De.push(o(["{", t(te, oe), i, "}"])) : De.push(o(["{", c([u, g(te, oe, "members", W), f(oe, "es5") ? "," : ""]), t(te, oe, !0), u, "}"])), De;
              case "TSEnumMember":
                return X.computed ? De.push("[", W("id"), "]") : De.push(W("id")), X.initializer && De.push(" = ", W("initializer")), De;
              case "TSImportEqualsDeclaration":
                return X.isExport && De.push("export "), De.push("import "), X.importKind && X.importKind !== "value" && De.push(X.importKind, " "), De.push(W("id"), " = ", W("moduleReference")), oe.semi && De.push(";"), o(De);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration":
                {
                  var _ie6 = te.getParentNode(),
                    _G3 = d(X.id),
                    _z3 = _ie6.type === "TSModuleDeclaration",
                    _U = X.body && X.body.type === "TSModuleDeclaration";
                  if (_z3) De.push(".");else {
                    X.declare && De.push("declare "), De.push(I(te, oe, W));
                    var _le = oe.originalText.slice(A(X), A(X.id));
                    X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(_le) || De.push(_G3 || /(?:^|\s)module(?:\s|$)/.test(_le) ? "module " : "namespace ");
                  }
                  return De.push(W("id")), _U ? De.push(W("body")) : X.body ? De.push(" ", o(W("body"))) : De.push(ue), De;
                }
              case "TSConditionalType":
                return k(te, oe, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return V(te, oe, W);
              case "TSUnionType":
                return q(te, oe, W);
              case "TSFunctionType":
                return Y(te, oe, W);
              case "TSTupleType":
                return H(te, oe, W);
              case "TSTypeReference":
                return [W("typeName"), N(te, oe, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return L(te, oe, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Q(te, W, "?");
              case "TSJSDocNonNullableType":
                return Q(te, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X.type), "."));
            }
          }
          n.exports = {
            printTypescript: ee
          };
        }
      }),
      Km = Z({
        "src/language-js/print/comment.js": function srcLanguageJsPrintCommentJs(e, n) {
          "use strict";

          re();
          var _Ue29 = Ue(),
            t = _Ue29.hasNewline,
            _Oe35 = Oe(),
            _Oe35$builders = _Oe35.builders,
            s = _Oe35$builders.join,
            a = _Oe35$builders.hardline,
            r = _Oe35.utils.replaceTextEndOfLine,
            _Ke30 = Ke(),
            u = _Ke30.isLineComment,
            _st14 = st(),
            i = _st14.locStart,
            o = _st14.locEnd,
            c = It();
          function v(p, f) {
            var h = p.getValue();
            if (u(h)) return f.originalText.slice(i(h), o(h)).trimEnd();
            if (c(h)) {
              if (m(h)) {
                var A = d(h);
                return h.trailing && !t(f.originalText, i(h), {
                  backwards: !0
                }) ? [a, A] : A;
              }
              var _w7 = o(h),
                T = f.originalText.slice(_w7 - 3, _w7) === "*-/";
              return ["/*", r(h.value), T ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(h));
          }
          function m(p) {
            var f = "*".concat(p.value, "*").split("\n");
            return f.length > 1 && f.every(function (h) {
              return h.trim()[0] === "*";
            });
          }
          function d(p) {
            var f = p.value.split("\n");
            return ["/*", s(a, f.map(function (h, w) {
              return w === 0 ? h.trimEnd() : " " + (w < f.length - 1 ? h.trim() : h.trimStart());
            })), "*/"];
          }
          n.exports = {
            printComment: v
          };
        }
      }),
      Ym = Z({
        "src/language-js/print/literal.js": function srcLanguageJsPrintLiteralJs(e, n) {
          "use strict";

          re();
          var _Ue30 = Ue(),
            t = _Ue30.printString,
            s = _Ue30.printNumber;
          function a(i, o) {
            var c = i.getNode();
            switch (c.type) {
              case "RegExpLiteral":
                return u(c);
              case "BigIntLiteral":
                return r(c.bigint || c.extra.raw);
              case "NumericLiteral":
                return s(c.extra.raw);
              case "StringLiteral":
                return t(c.extra.raw, o);
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(c.value);
              case "DecimalLiteral":
                return s(c.value) + "m";
              case "Literal":
                {
                  if (c.regex) return u(c.regex);
                  if (c.bigint) return r(c.raw);
                  if (c.decimal) return s(c.decimal) + "m";
                  var v = c.value;
                  return typeof v == "number" ? s(c.raw) : typeof v == "string" ? t(c.raw, o) : String(v);
                }
            }
          }
          function r(i) {
            return i.toLowerCase();
          }
          function u(i) {
            var o = i.pattern,
              c = i.flags;
            return c = _toConsumableArray(c).sort().join(""), "/".concat(o, "/").concat(c);
          }
          n.exports = {
            printLiteral: a
          };
        }
      }),
      Qm = Z({
        "src/language-js/printer-estree.js": function srcLanguageJsPrinterEstreeJs(e, n) {
          "use strict";

          re();
          var _et18 = et(),
            t = _et18.printDanglingComments,
            _Ue31 = Ue(),
            s = _Ue31.hasNewline,
            _Oe36 = Oe(),
            _Oe36$builders = _Oe36.builders,
            a = _Oe36$builders.join,
            r = _Oe36$builders.line,
            u = _Oe36$builders.hardline,
            i = _Oe36$builders.softline,
            o = _Oe36$builders.group,
            c = _Oe36$builders.indent,
            v = _Oe36.utils.replaceTextEndOfLine,
            m = Im(),
            d = Lm(),
            _no = no(),
            p = _no.insertPragma,
            f = uo(),
            h = jt(),
            w = so(),
            _Ke31 = Ke(),
            T = _Ke31.hasFlowShorthandAnnotationComment,
            A = _Ke31.hasComment,
            S = _Ke31.CommentCheckFlags,
            B = _Ke31.isTheOnlyJsxElementInMarkdown,
            I = _Ke31.isLineComment,
            k = _Ke31.isNextLineEmpty,
            P = _Ke31.needsHardlineAfterDanglingComment,
            C = _Ke31.rawText,
            D = _Ke31.hasIgnoreComment,
            g = _Ke31.isCallExpression,
            F = _Ke31.isMemberExpression,
            l = _Ke31.markerForIfWithoutBlockAndSameLineComment,
            _st15 = st(),
            E = _st15.locStart,
            y = _st15.locEnd,
            N = It(),
            _$m = $m(),
            x = _$m.printHtmlBinding,
            b = _$m.isVueEventBindingExpression,
            _Hm = Hm(),
            L = _Hm.printAngular,
            _Gm = Gm(),
            M = _Gm.printJsx,
            j = _Gm.hasJsxIgnoreComment,
            _Um = Um(),
            $ = _Um.printFlow,
            _Xm = Xm(),
            V = _Xm.printTypescript,
            _ct12 = ct(),
            q = _ct12.printOptionalToken,
            Y = _ct12.printBindExpressionCallee,
            H = _ct12.printTypeAnnotation,
            R = _ct12.adjustClause,
            Q = _ct12.printRestSpread,
            ee = _ct12.printDefiniteToken,
            _co2 = co(),
            te = _co2.printImportDeclaration,
            oe = _co2.printExportDeclaration,
            W = _co2.printExportAllDeclaration,
            X = _co2.printModuleSpecifier,
            _po2 = po(),
            ue = _po2.printTernary,
            _Lt6 = Lt(),
            De = _Lt6.printTemplateLiteral,
            _Kt5 = Kt(),
            ie = _Kt5.printArray,
            _zn3 = zn(),
            G = _zn3.printObject,
            _Zt5 = Zt(),
            z = _Zt5.printClass,
            U = _Zt5.printClassMethod,
            le = _Zt5.printClassProperty,
            _Qt5 = Qt(),
            ge = _Qt5.printProperty,
            _Lr4 = Lr(),
            Ae = _Lr4.printFunction,
            Ne = _Lr4.printArrowFunction,
            ke = _Lr4.printMethod,
            ce = _Lr4.printReturnStatement,
            pe = _Lr4.printThrowStatement,
            _oo2 = oo(),
            de = _oo2.printCallExpression,
            _Yt5 = Yt(),
            ae = _Yt5.printVariableDeclarator,
            ve = _Yt5.printAssignmentExpression,
            _Jn3 = Jn(),
            K = _Jn3.printBinaryishExpression,
            _fo2 = fo(),
            he = _fo2.printSwitchCaseConsequent,
            _ao2 = ao(),
            ye = _ao2.printMemberExpression,
            _Do2 = Do(),
            Ce = _Do2.printBlock,
            Ie = _Do2.printBlockBody,
            _Km = Km(),
            Fe = _Km.printComment,
            _Ym = Ym(),
            me = _Ym.printLiteral,
            _Un3 = Un(),
            _ = _Un3.printDecorators;
          function J(Be, Pe, Se, Qe) {
            var xe = ne(Be, Pe, Se, Qe);
            if (!xe) return "";
            var Xe = Be.getValue(),
              _e = Xe.type;
            if (_e === "ClassMethod" || _e === "ClassPrivateMethod" || _e === "ClassProperty" || _e === "ClassAccessorProperty" || _e === "PropertyDefinition" || _e === "TSAbstractPropertyDefinition" || _e === "ClassPrivateProperty" || _e === "MethodDefinition" || _e === "TSAbstractMethodDefinition" || _e === "TSDeclareMethod") return xe;
            var je = [xe],
              Re = _(Be, Pe, Se),
              be = Xe.type === "ClassExpression" && Re;
            if (Re && (je = [].concat(_toConsumableArray(Re), [xe]), !be)) return o(je);
            if (!h(Be, Pe)) return Qe && Qe.needsSemi && je.unshift(";"), je.length === 1 && je[0] === xe ? xe : je;
            if (be && (je = [c([r].concat(_toConsumableArray(je)))]), je.unshift("("), Qe && Qe.needsSemi && je.unshift(";"), T(Xe)) {
              var _Xe$trailingComments = _slicedToArray(Xe.trailingComments, 1),
                qe = _Xe$trailingComments[0];
              je.push(" /*", qe.value.trimStart(), "*/"), qe.printed = !0;
            }
            return be && je.push(r), je.push(")"), je;
          }
          function ne(Be, Pe, Se, Qe) {
            var xe = Be.getValue(),
              Xe = Pe.semi ? ";" : "";
            if (!xe) return "";
            if (typeof xe == "string") return xe;
            for (var _i15 = 0, _arr5 = [me, x, L, M, $, V]; _i15 < _arr5.length; _i15++) {
              var je = _arr5[_i15];
              var Re = je(Be, Pe, Se);
              if (_typeof(Re) < "u") return Re;
            }
            var _e = [];
            switch (xe.type) {
              case "JsExpressionRoot":
                return Se("node");
              case "JsonRoot":
                return [Se("node"), u];
              case "File":
                return xe.program && xe.program.interpreter && _e.push(Se(["program", "interpreter"])), _e.push(Se("program")), _e;
              case "Program":
                return Ie(Be, Pe, Se);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement":
                {
                  if (xe.directive) return [Ee(xe.expression, Pe), Xe];
                  if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                    var _Re = Be.getParentNode();
                    if (_Re.type === "Program" && _Re.body.length === 1 && _Re.body[0] === xe) return [Se("expression"), b(xe.expression) ? ";" : ""];
                  }
                  var _je = t(Be, Pe, !0, function (Re) {
                    var be = Re.marker;
                    return be === l;
                  });
                  return [Se("expression"), B(Pe, Be) ? "" : Xe, _je ? [" ", _je] : ""];
                }
              case "ParenthesizedExpression":
                return !A(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Se("expression"), ")"] : o(["(", c([i, Se("expression")]), i, ")"]);
              case "AssignmentExpression":
                return ve(Be, Pe, Se);
              case "VariableDeclarator":
                return ae(Be, Pe, Se);
              case "BinaryExpression":
              case "LogicalExpression":
                return K(Be, Pe, Se);
              case "AssignmentPattern":
                return [Se("left"), " = ", Se("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return ye(Be, Pe, Se);
              case "MetaProperty":
                return [Se("meta"), ".", Se("property")];
              case "BindExpression":
                return xe.object && _e.push(Se("object")), _e.push(o(c([i, Y(Be, Pe, Se)]))), _e;
              case "Identifier":
                return [xe.name, q(Be), ee(Be), H(Be, Pe, Se)];
              case "V8IntrinsicIdentifier":
                return ["%", xe.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return Q(Be, Pe, Se);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return Ae(Be, Se, Pe, Qe);
              case "ArrowFunctionExpression":
                return Ne(Be, Pe, Se, Qe);
              case "YieldExpression":
                return _e.push("yield"), xe.delegate && _e.push("*"), xe.argument && _e.push(" ", Se("argument")), _e;
              case "AwaitExpression":
                {
                  if (_e.push("await"), xe.argument) {
                    _e.push(" ", Se("argument"));
                    var _je2 = Be.getParentNode();
                    if (g(_je2) && _je2.callee === xe || F(_je2) && _je2.object === xe) {
                      _e = [c([i].concat(_toConsumableArray(_e))), i];
                      var _Re2 = Be.findAncestor(function (be) {
                        return be.type === "AwaitExpression" || be.type === "BlockStatement";
                      });
                      if (!_Re2 || _Re2.type !== "AwaitExpression") return o(_e);
                    }
                  }
                  return _e;
                }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return oe(Be, Pe, Se);
              case "ExportAllDeclaration":
                return W(Be, Pe, Se);
              case "ImportDeclaration":
                return te(Be, Pe, Se);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return X(Be, Pe, Se);
              case "ImportAttribute":
                return [Se("key"), ": ", Se("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return Ce(Be, Pe, Se);
              case "ThrowStatement":
                return pe(Be, Pe, Se);
              case "ReturnStatement":
                return ce(Be, Pe, Se);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return de(Be, Pe, Se);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return G(Be, Pe, Se);
              case "ObjectProperty":
              case "Property":
                return xe.method || xe.kind === "get" || xe.kind === "set" ? ke(Be, Pe, Se) : ge(Be, Pe, Se);
              case "ObjectMethod":
                return ke(Be, Pe, Se);
              case "Decorator":
                return ["@", Se("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return ie(Be, Pe, Se);
              case "SequenceExpression":
                {
                  var _je3 = Be.getParentNode(0);
                  if (_je3.type === "ExpressionStatement" || _je3.type === "ForStatement") {
                    var _Re3 = [];
                    return Be.each(function (be, Le) {
                      Le === 0 ? _Re3.push(Se()) : _Re3.push(",", c([r, Se()]));
                    }, "expressions"), o(_Re3);
                  }
                  return o(a([",", r], Be.map(Se, "expressions")));
                }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Se("value"), Xe];
              case "DirectiveLiteral":
                return Ee(xe, Pe);
              case "UnaryExpression":
                return _e.push(xe.operator), /[a-z]$/.test(xe.operator) && _e.push(" "), A(xe.argument) ? _e.push(o(["(", c([i, Se("argument")]), i, ")"])) : _e.push(Se("argument")), _e;
              case "UpdateExpression":
                return _e.push(Se("argument"), xe.operator), xe.prefix && _e.reverse(), _e;
              case "ConditionalExpression":
                return ue(Be, Pe, Se);
              case "VariableDeclaration":
                {
                  var _je4 = Be.map(Se, "declarations"),
                    _Re4 = Be.getParentNode(),
                    be = _Re4.type === "ForStatement" || _Re4.type === "ForInStatement" || _Re4.type === "ForOfStatement",
                    Le = xe.declarations.some(function (se) {
                      return se.init;
                    }),
                    qe;
                  return _je4.length === 1 && !A(xe.declarations[0]) ? qe = _je4[0] : _je4.length > 0 && (qe = c(_je4[0])), _e = [xe.declare ? "declare " : "", xe.kind, qe ? [" ", qe] : "", c(_je4.slice(1).map(function (se) {
                    return [",", Le && !be ? u : r, se];
                  }))], be && _Re4.body !== xe || _e.push(Xe), o(_e);
                }
              case "WithStatement":
                return o(["with (", Se("object"), ")", R(xe.body, Se("body"))]);
              case "IfStatement":
                {
                  var _je5 = R(xe.consequent, Se("consequent")),
                    _Re5 = o(["if (", o([c([i, Se("test")]), i]), ")", _je5]);
                  if (_e.push(_Re5), xe.alternate) {
                    var _be = A(xe.consequent, S.Trailing | S.Line) || P(xe),
                      _Le = xe.consequent.type === "BlockStatement" && !_be;
                    _e.push(_Le ? " " : u), A(xe, S.Dangling) && _e.push(t(Be, Pe, !0), _be ? u : " "), _e.push("else", o(R(xe.alternate, Se("alternate"), xe.alternate.type === "IfStatement")));
                  }
                  return _e;
                }
              case "ForStatement":
                {
                  var _je6 = R(xe.body, Se("body")),
                    _Re6 = t(Be, Pe, !0),
                    _be2 = _Re6 ? [_Re6, i] : "";
                  return !xe.init && !xe.test && !xe.update ? [_be2, o(["for (;;)", _je6])] : [_be2, o(["for (", o([c([i, Se("init"), ";", r, Se("test"), ";", r, Se("update")]), i]), ")", _je6])];
                }
              case "WhileStatement":
                return o(["while (", o([c([i, Se("test")]), i]), ")", R(xe.body, Se("body"))]);
              case "ForInStatement":
                return o(["for (", Se("left"), " in ", Se("right"), ")", R(xe.body, Se("body"))]);
              case "ForOfStatement":
                return o(["for", xe.await ? " await" : "", " (", Se("left"), " of ", Se("right"), ")", R(xe.body, Se("body"))]);
              case "DoWhileStatement":
                {
                  var _je7 = R(xe.body, Se("body"));
                  return _e = [o(["do", _je7])], xe.body.type === "BlockStatement" ? _e.push(" ") : _e.push(u), _e.push("while (", o([c([i, Se("test")]), i]), ")", Xe), _e;
                }
              case "DoExpression":
                return [xe.async ? "async " : "", "do ", Se("body")];
              case "BreakStatement":
                return _e.push("break"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
              case "ContinueStatement":
                return _e.push("continue"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
              case "LabeledStatement":
                return xe.body.type === "EmptyStatement" ? [Se("label"), ":;"] : [Se("label"), ": ", Se("body")];
              case "TryStatement":
                return ["try ", Se("block"), xe.handler ? [" ", Se("handler")] : "", xe.finalizer ? [" finally ", Se("finalizer")] : ""];
              case "CatchClause":
                if (xe.param) {
                  var _je8 = A(xe.param, function (be) {
                      return !N(be) || be.leading && s(Pe.originalText, y(be)) || be.trailing && s(Pe.originalText, E(be), {
                        backwards: !0
                      });
                    }),
                    _Re7 = Se("param");
                  return ["catch ", _je8 ? ["(", c([i, _Re7]), i, ") "] : ["(", _Re7, ") "], Se("body")];
                }
                return ["catch ", Se("body")];
              case "SwitchStatement":
                return [o(["switch (", c([i, Se("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? c([u, a(u, Be.map(function (je, Re, be) {
                  var Le = je.getValue();
                  return [Se(), Re !== be.length - 1 && k(Le, Pe) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase":
                {
                  xe.test ? _e.push("case ", Se("test"), ":") : _e.push("default:"), A(xe, S.Dangling) && _e.push(" ", t(Be, Pe, !0));
                  var _je9 = xe.consequent.filter(function (Re) {
                    return Re.type !== "EmptyStatement";
                  });
                  if (_je9.length > 0) {
                    var _Re8 = he(Be, Pe, Se);
                    _e.push(_je9.length === 1 && _je9[0].type === "BlockStatement" ? [" ", _Re8] : c([u, _Re8]));
                  }
                  return _e;
                }
              case "DebuggerStatement":
                return ["debugger", Xe];
              case "ClassDeclaration":
              case "ClassExpression":
                return z(Be, Pe, Se);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return U(Be, Pe, Se);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
                return le(Be, Pe, Se);
              case "TemplateElement":
                return v(xe.value.raw);
              case "TemplateLiteral":
                return De(Be, Se, Pe);
              case "TaggedTemplateExpression":
                return [Se("tag"), Se("typeParameters"), Se("quasi")];
              case "PrivateIdentifier":
                return ["#", Se("name")];
              case "PrivateName":
                return ["#", Se("id")];
              case "InterpreterDirective":
                return _e.push("#!", xe.value, u), k(xe, Pe) && _e.push(u), _e;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression":
                {
                  _e.push("module {");
                  var _je10 = Se("body");
                  return _je10 && _e.push(c([u, _je10]), u), _e.push("}"), _e;
                }
              default:
                throw new Error("unknown type: " + JSON.stringify(xe.type));
            }
          }
          function Ee(Be, Pe) {
            var Se = C(Be),
              Qe = Se.slice(1, -1);
            if (Qe.includes('"') || Qe.includes("'")) return Se;
            var xe = Pe.singleQuote ? "'" : '"';
            return xe + Qe + xe;
          }
          function We(Be) {
            return Be.type && !N(Be) && !I(Be) && Be.type !== "EmptyStatement" && Be.type !== "TemplateElement" && Be.type !== "Import" && Be.type !== "TSEmptyBodyFunctionExpression";
          }
          n.exports = {
            preprocess: w,
            print: J,
            embed: m,
            insertPragma: p,
            massageAstNode: d,
            hasPrettierIgnore: function hasPrettierIgnore(Be) {
              return D(Be) || j(Be);
            },
            willPrintOwnComments: f.willPrintOwnComments,
            canAttachComment: We,
            printComment: Fe,
            isBlockComment: N,
            handleComments: {
              avoidAstMutation: !0,
              ownLine: f.handleOwnLineComment,
              endOfLine: f.handleEndOfLineComment,
              remaining: f.handleRemainingComment
            },
            getCommentChildNodes: f.getCommentChildNodes
          };
        }
      }),
      Zm = Z({
        "src/language-js/printer-estree-json.js": function srcLanguageJsPrinterEstreeJsonJs(e, n) {
          "use strict";

          re();
          var _Oe37 = Oe(),
            _Oe37$builders = _Oe37.builders,
            t = _Oe37$builders.hardline,
            s = _Oe37$builders.indent,
            a = _Oe37$builders.join,
            r = so();
          function u(c, v, m) {
            var d = c.getValue();
            switch (d.type) {
              case "JsonRoot":
                return [m("node"), t];
              case "ArrayExpression":
                {
                  if (d.elements.length === 0) return "[]";
                  var p = c.map(function () {
                    return c.getValue() === null ? "null" : m();
                  }, "elements");
                  return ["[", s([t, a([",", t], p)]), t, "]"];
                }
              case "ObjectExpression":
                return d.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], c.map(m, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [m("key"), ": ", m("value")];
              case "UnaryExpression":
                return [d.operator === "+" ? "" : d.operator, m("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return d.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(d.value);
              case "Identifier":
                {
                  var _p4 = c.getParentNode();
                  return _p4 && _p4.type === "ObjectProperty" && _p4.key === d ? JSON.stringify(d.name) : d.name;
                }
              case "TemplateLiteral":
                return m(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(d.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(d.type));
            }
          }
          var i = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function o(c, v) {
            var m = c.type;
            if (m === "ObjectProperty" && c.key.type === "Identifier") {
              v.key = {
                type: "StringLiteral",
                value: c.key.name
              };
              return;
            }
            if (m === "UnaryExpression" && c.operator === "+") return v.argument;
            if (m === "ArrayExpression") {
              var _iterator43 = _createForOfIteratorHelper(c.elements.entries()),
                _step43;
              try {
                for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                  var _step43$value = _slicedToArray(_step43.value, 2),
                    d = _step43$value[0],
                    p = _step43$value[1];
                  p === null && v.elements.splice(d, 0, {
                    type: "NullLiteral"
                  });
                }
              } catch (err) {
                _iterator43.e(err);
              } finally {
                _iterator43.f();
              }
              return;
            }
            if (m === "TemplateLiteral") return {
              type: "StringLiteral",
              value: c.quasis[0].value.cooked
            };
          }
          o.ignoredProperties = i, n.exports = {
            preprocess: r,
            print: u,
            massageAstNode: o
          };
        }
      }),
      Ot = Z({
        "src/common/common-options.js": function srcCommonCommonOptionsJs(e, n) {
          "use strict";

          re();
          var t = "Common";
          n.exports = {
            bracketSpacing: {
              since: "0.0.0",
              category: t,
              type: "boolean",
              default: !0,
              description: "Print spaces between brackets.",
              oppositeDescription: "Do not print spaces between brackets."
            },
            singleQuote: {
              since: "0.0.0",
              category: t,
              type: "boolean",
              default: !1,
              description: "Use single quotes instead of double quotes."
            },
            proseWrap: {
              since: "1.8.2",
              category: t,
              type: "choice",
              default: [{
                since: "1.8.2",
                value: !0
              }, {
                since: "1.9.0",
                value: "preserve"
              }],
              description: "How to wrap prose.",
              choices: [{
                since: "1.9.0",
                value: "always",
                description: "Wrap prose if it exceeds the print width."
              }, {
                since: "1.9.0",
                value: "never",
                description: "Do not wrap prose."
              }, {
                since: "1.9.0",
                value: "preserve",
                description: "Wrap prose as-is."
              }]
            },
            bracketSameLine: {
              since: "2.4.0",
              category: t,
              type: "boolean",
              default: !1,
              description: "Put > of opening tags on the last line instead of on a new line."
            },
            singleAttributePerLine: {
              since: "2.6.0",
              category: t,
              type: "boolean",
              default: !1,
              description: "Enforce single attribute per line in HTML, Vue and JSX."
            }
          };
        }
      }),
      ed = Z({
        "src/language-js/options.js": function srcLanguageJsOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot(),
            s = "JavaScript";
          n.exports = {
            arrowParens: {
              since: "1.9.0",
              category: s,
              type: "choice",
              default: [{
                since: "1.9.0",
                value: "avoid"
              }, {
                since: "2.0.0",
                value: "always"
              }],
              description: "Include parentheses around a sole arrow function parameter.",
              choices: [{
                value: "always",
                description: "Always include parens. Example: `(x) => x`"
              }, {
                value: "avoid",
                description: "Omit parens when possible. Example: `x => x`"
              }]
            },
            bracketSameLine: t.bracketSameLine,
            bracketSpacing: t.bracketSpacing,
            jsxBracketSameLine: {
              since: "0.17.0",
              category: s,
              type: "boolean",
              description: "Put > on the last line instead of at a new line.",
              deprecated: "2.4.0"
            },
            semi: {
              since: "1.0.0",
              category: s,
              type: "boolean",
              default: !0,
              description: "Print semicolons.",
              oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
            },
            singleQuote: t.singleQuote,
            jsxSingleQuote: {
              since: "1.15.0",
              category: s,
              type: "boolean",
              default: !1,
              description: "Use single quotes in JSX."
            },
            quoteProps: {
              since: "1.17.0",
              category: s,
              type: "choice",
              default: "as-needed",
              description: "Change when properties in objects are quoted.",
              choices: [{
                value: "as-needed",
                description: "Only add quotes around object properties where required."
              }, {
                value: "consistent",
                description: "If at least one property in an object requires quotes, quote all properties."
              }, {
                value: "preserve",
                description: "Respect the input use of quotes in object properties."
              }]
            },
            trailingComma: {
              since: "0.0.0",
              category: s,
              type: "choice",
              default: [{
                since: "0.0.0",
                value: !1
              }, {
                since: "0.19.0",
                value: "none"
              }, {
                since: "2.0.0",
                value: "es5"
              }],
              description: "Print trailing commas wherever possible when multi-line.",
              choices: [{
                value: "es5",
                description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
              }, {
                value: "none",
                description: "No trailing commas."
              }, {
                value: "all",
                description: "Trailing commas wherever possible (including function arguments)."
              }]
            },
            singleAttributePerLine: t.singleAttributePerLine
          };
        }
      }),
      td = Z({
        "src/language-js/parse/parsers.js": function srcLanguageJsParseParsersJs() {
          re();
        }
      }),
      Sn = Z({
        "node_modules/linguist-languages/data/JavaScript.json": function node_modulesLinguistLanguagesDataJavaScriptJson(e, n) {
          n.exports = {
            name: "JavaScript",
            type: "programming",
            tmScope: "source.js",
            aceMode: "javascript",
            codemirrorMode: "javascript",
            codemirrorMimeType: "text/javascript",
            color: "#f1e05a",
            aliases: ["js", "node"],
            extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"],
            filenames: ["Jakefile"],
            interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"],
            languageId: 183
          };
        }
      }),
      rd = Z({
        "node_modules/linguist-languages/data/TypeScript.json": function node_modulesLinguistLanguagesDataTypeScriptJson(e, n) {
          n.exports = {
            name: "TypeScript",
            type: "programming",
            color: "#3178c6",
            aliases: ["ts"],
            interpreters: ["deno", "ts-node"],
            extensions: [".ts", ".cts", ".mts"],
            tmScope: "source.ts",
            aceMode: "typescript",
            codemirrorMode: "javascript",
            codemirrorMimeType: "application/typescript",
            languageId: 378
          };
        }
      }),
      nd = Z({
        "node_modules/linguist-languages/data/TSX.json": function node_modulesLinguistLanguagesDataTSXJson(e, n) {
          n.exports = {
            name: "TSX",
            type: "programming",
            color: "#3178c6",
            group: "TypeScript",
            extensions: [".tsx"],
            tmScope: "source.tsx",
            aceMode: "javascript",
            codemirrorMode: "jsx",
            codemirrorMimeType: "text/jsx",
            languageId: 94901924
          };
        }
      }),
      ma = Z({
        "node_modules/linguist-languages/data/JSON.json": function node_modulesLinguistLanguagesDataJSONJson(e, n) {
          n.exports = {
            name: "JSON",
            type: "data",
            color: "#292929",
            tmScope: "source.json",
            aceMode: "json",
            codemirrorMode: "javascript",
            codemirrorMimeType: "application/json",
            aliases: ["geojson", "jsonl", "topojson"],
            extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"],
            filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"],
            languageId: 174
          };
        }
      }),
      ud = Z({
        "node_modules/linguist-languages/data/JSON with Comments.json": function node_modulesLinguistLanguagesDataJSONWithCommentsJson(e, n) {
          n.exports = {
            name: "JSON with Comments",
            type: "data",
            color: "#292929",
            group: "JSON",
            tmScope: "source.js",
            aceMode: "javascript",
            codemirrorMode: "javascript",
            codemirrorMimeType: "text/javascript",
            aliases: ["jsonc"],
            extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"],
            filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"],
            languageId: 423
          };
        }
      }),
      sd = Z({
        "node_modules/linguist-languages/data/JSON5.json": function node_modulesLinguistLanguagesDataJSON5Json(e, n) {
          n.exports = {
            name: "JSON5",
            type: "data",
            color: "#267CB9",
            extensions: [".json5"],
            tmScope: "source.js",
            aceMode: "javascript",
            codemirrorMode: "javascript",
            codemirrorMimeType: "application/json",
            languageId: 175
          };
        }
      }),
      id = Z({
        "src/language-js/index.js": function srcLanguageJsIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = Qm(),
            a = Zm(),
            r = ed(),
            u = td(),
            i = [t(Sn(), function (c) {
              return {
                since: "0.0.0",
                parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"],
                vscodeLanguageIds: ["javascript", "mongo"],
                interpreters: [].concat(_toConsumableArray(c.interpreters), ["zx"]),
                extensions: [].concat(_toConsumableArray(c.extensions.filter(function (v) {
                  return v !== ".jsx";
                })), [".wxs"])
              };
            }), t(Sn(), function () {
              return {
                name: "Flow",
                since: "0.0.0",
                parsers: ["flow", "babel-flow"],
                vscodeLanguageIds: ["javascript"],
                aliases: [],
                filenames: [],
                extensions: [".js.flow"]
              };
            }), t(Sn(), function () {
              return {
                name: "JSX",
                since: "0.0.0",
                parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"],
                vscodeLanguageIds: ["javascriptreact"],
                aliases: void 0,
                filenames: void 0,
                extensions: [".jsx"],
                group: "JavaScript",
                interpreters: void 0,
                tmScope: "source.js.jsx",
                aceMode: "javascript",
                codemirrorMode: "jsx",
                codemirrorMimeType: "text/jsx",
                color: void 0
              };
            }), t(rd(), function () {
              return {
                since: "1.4.0",
                parsers: ["typescript", "babel-ts"],
                vscodeLanguageIds: ["typescript"]
              };
            }), t(nd(), function () {
              return {
                since: "1.4.0",
                parsers: ["typescript", "babel-ts"],
                vscodeLanguageIds: ["typescriptreact"]
              };
            }), t(ma(), function () {
              return {
                name: "JSON.stringify",
                since: "1.13.0",
                parsers: ["json-stringify"],
                vscodeLanguageIds: ["json"],
                extensions: [".importmap"],
                filenames: ["package.json", "package-lock.json", "composer.json"]
              };
            }), t(ma(), function (c) {
              return {
                since: "1.5.0",
                parsers: ["json"],
                vscodeLanguageIds: ["json"],
                extensions: c.extensions.filter(function (v) {
                  return v !== ".jsonl";
                })
              };
            }), t(ud(), function (c) {
              return {
                since: "1.5.0",
                parsers: ["json"],
                vscodeLanguageIds: ["jsonc"],
                filenames: [].concat(_toConsumableArray(c.filenames), [".eslintrc", ".swcrc"])
              };
            }), t(sd(), function () {
              return {
                since: "1.13.0",
                parsers: ["json5"],
                vscodeLanguageIds: ["json5"]
              };
            })],
            o = {
              estree: s,
              "estree-json": a
            };
          n.exports = {
            languages: i,
            options: r,
            printers: o,
            parsers: u
          };
        }
      }),
      ad = Z({
        "src/language-css/clean.js": function srcLanguageCssCleanJs(e, n) {
          "use strict";

          re();
          var _Ue32 = Ue(),
            t = _Ue32.isFrontMatterNode,
            s = it(),
            a = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function r(i, o, c) {
            if (t(i) && i.lang === "yaml" && delete o.value, i.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || c.type === "css-root" && s(c.nodes) === i)) return null;
            if (i.type === "value-root" && delete o.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete o.value, i.type === "css-rule" && delete o.params, i.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), i.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), i.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (o.name = o.name.toLowerCase()), i.type === "value-number" && (o.unit = o.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && o.value && (o.value = u(o.value)), i.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = !0)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, function (v, m, d) {
              var p = Number(m);
              return Number.isNaN(p) ? v : p + d.toLowerCase();
            })), i.type === "selector-tag") {
              var v = i.value.toLowerCase();
              ["from", "to"].includes(v) && (o.value = v);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete o.value, i.type === "selector-unknown" && delete o.value, i.type === "value-comma_group") {
              var _v2 = i.groups.findIndex(function (m) {
                return m.type === "value-number" && m.unit === "...";
              });
              _v2 !== -1 && (o.groups[_v2].unit = "", o.groups.splice(_v2 + 1, 0, {
                type: "value-word",
                value: "...",
                isColor: !1,
                isHex: !1
              }));
            }
          }
          r.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          n.exports = r;
        }
      }),
      Xn = Z({
        "src/utils/front-matter/print.js": function srcUtilsFrontMatterPrintJs(e, n) {
          "use strict";

          re();
          var _Oe38 = Oe(),
            _Oe38$builders = _Oe38.builders,
            t = _Oe38$builders.hardline,
            s = _Oe38$builders.markAsRoot;
          function a(r, u) {
            if (r.lang === "yaml") {
              var i = r.value.trim(),
                o = i ? u(i, {
                  parser: "yaml"
                }, {
                  stripTrailingHardline: !0
                }) : "";
              return s([r.startDelimiter, t, o, o ? t : "", r.endDelimiter]);
            }
          }
          n.exports = a;
        }
      }),
      od = Z({
        "src/language-css/embed.js": function srcLanguageCssEmbedJs(e, n) {
          "use strict";

          re();
          var _Oe39 = Oe(),
            t = _Oe39.builders.hardline,
            s = Xn();
          function a(r, u, i) {
            var o = r.getValue();
            if (o.type === "front-matter") {
              var c = s(o, i);
              return c ? [c, t] : "";
            }
          }
          n.exports = a;
        }
      }),
      mo = Z({
        "src/utils/front-matter/parse.js": function srcUtilsFrontMatterParseJs(e, n) {
          "use strict";

          re();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            var r = a.match(t);
            if (!r) return {
              content: a
            };
            var _r$groups = r.groups,
              u = _r$groups.startDelimiter,
              i = _r$groups.language,
              _r$groups$value = _r$groups.value,
              o = _r$groups$value === void 0 ? "" : _r$groups$value,
              c = _r$groups.endDelimiter,
              v = i.trim() || "yaml";
            if (u === "+++" && (v = "toml"), v !== "yaml" && u !== c) return {
              content: a
            };
            var _r3 = _slicedToArray(r, 1),
              m = _r3[0];
            return {
              frontMatter: {
                type: "front-matter",
                lang: v,
                value: o,
                startDelimiter: u,
                endDelimiter: c,
                raw: m.replace(/\n$/, "")
              },
              content: m.replace(/[^\n]/g, " ") + a.slice(m.length)
            };
          }
          n.exports = s;
        }
      }),
      ld = Z({
        "src/language-css/pragma.js": function srcLanguageCssPragmaJs(e, n) {
          "use strict";

          re();
          var t = no(),
            s = mo();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          function r(u) {
            var _s2 = s(u),
              i = _s2.frontMatter,
              o = _s2.content;
            return (i ? i.raw + "\n\n" : "") + t.insertPragma(o);
          }
          n.exports = {
            hasPragma: a,
            insertPragma: r
          };
        }
      }),
      cd = Z({
        "src/language-css/utils/index.js": function srcLanguageCssUtilsIndexJs(e, n) {
          "use strict";

          re();
          var t = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(G, z) {
            var U = Array.isArray(z) ? z : [z],
              le = -1,
              ge;
            for (; ge = G.getParentNode(++le);) {
              if (U.includes(ge.type)) return le;
            }
            return -1;
          }
          function a(G, z) {
            var U = s(G, z);
            return U === -1 ? null : G.getParentNode(U);
          }
          function r(G) {
            var z;
            var U = a(G, "css-decl");
            return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();
          }
          var u = new Set(["initial", "inherit", "unset", "revert"]);
          function i(G) {
            return u.has(G.toLowerCase());
          }
          function o(G, z) {
            var U = a(G, "css-atrule");
            return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(z.toLowerCase());
          }
          function c(G) {
            return G.includes("$") || G.includes("@") || G.includes("#") || G.startsWith("%") || G.startsWith("--") || G.startsWith(":--") || G.includes("(") && G.includes(")") ? G : G.toLowerCase();
          }
          function v(G, z) {
            var U;
            var le = a(G, "value-func");
            return (le == null || (U = le.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;
          }
          function m(G) {
            var z;
            var U = a(G, "css-rule"),
              le = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;
            return le && (le.startsWith(":import") || le.startsWith(":export"));
          }
          function d(G, z) {
            var U = Array.isArray(z) ? z : [z],
              le = a(G, "css-atrule");
            return le && U.includes(le.name.toLowerCase());
          }
          function p(G) {
            var z = G.getValue(),
              U = a(G, "css-atrule");
            return (U == null ? void 0 : U.name) === "import" && z.groups[0].value === "url" && z.groups.length === 2;
          }
          function f(G) {
            return G.type === "value-func" && G.value.toLowerCase() === "url";
          }
          function h(G, z) {
            var U;
            var le = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;
            return le && le.indexOf(z) === le.length - 1;
          }
          function w(G) {
            var z = G.selector;
            return z ? typeof z == "string" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : !1;
          }
          function T(G) {
            return G.type === "value-word" && ["from", "through", "end"].includes(G.value);
          }
          function A(G) {
            return G.type === "value-word" && ["and", "or", "not"].includes(G.value);
          }
          function S(G) {
            return G.type === "value-word" && G.value === "in";
          }
          function B(G) {
            return G.type === "value-operator" && G.value === "*";
          }
          function I(G) {
            return G.type === "value-operator" && G.value === "/";
          }
          function k(G) {
            return G.type === "value-operator" && G.value === "+";
          }
          function P(G) {
            return G.type === "value-operator" && G.value === "-";
          }
          function C(G) {
            return G.type === "value-operator" && G.value === "%";
          }
          function D(G) {
            return B(G) || I(G) || k(G) || P(G) || C(G);
          }
          function g(G) {
            return G.type === "value-word" && ["==", "!="].includes(G.value);
          }
          function F(G) {
            return G.type === "value-word" && ["<", ">", "<=", ">="].includes(G.value);
          }
          function l(G) {
            return G.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(G.name);
          }
          function E(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\(\s*\)$/.test(G.raws.params);
          }
          function y(G) {
            return G.name.startsWith("prettier-placeholder");
          }
          function N(G) {
            return G.prop.startsWith("@prettier-placeholder");
          }
          function x(G, z) {
            return G.value === "$$" && G.type === "value-func" && (z == null ? void 0 : z.type) === "value-word" && !z.raws.before;
          }
          function b(G) {
            var z, U;
            return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === "value-root" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === "value-value" && G.prop.toLowerCase() === "composes";
          }
          function L(G) {
            var z, U, le;
            return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le = U.group) === null || le === void 0 ? void 0 : le.type) === "value-paren_group" && G.value.group.group.open !== null && G.value.group.group.close !== null;
          }
          function M(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === "";
          }
          function j(G) {
            var z, U;
            return G.type === "value-comma_group" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === "value-colon";
          }
          function $(G) {
            var z;
            return G.type === "value-paren_group" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);
          }
          function V(G) {
            var z;
            var U = G.getValue();
            if (U.groups.length === 0) return !1;
            var le = G.getParentNode(1);
            if (!$(U) && !(le && $(le))) return !1;
            var ge = a(G, "css-decl");
            return !!(ge != null && (z = ge.prop) !== null && z !== void 0 && z.startsWith("$") || $(le) || le.type === "value-func");
          }
          function q(G) {
            return G.type === "value-comment" && G.inline;
          }
          function Y(G) {
            return G.type === "value-word" && G.value === "#";
          }
          function H(G) {
            return G.type === "value-word" && G.value === "{";
          }
          function R(G) {
            return G.type === "value-word" && G.value === "}";
          }
          function Q(G) {
            return ["value-word", "value-atword"].includes(G.type);
          }
          function ee(G) {
            return (G == null ? void 0 : G.type) === "value-colon";
          }
          function te(G, z) {
            if (!j(z)) return !1;
            var U = z.groups,
              le = U.indexOf(G);
            return le === -1 ? !1 : ee(U[le + 1]);
          }
          function oe(G) {
            return G.value && ["not", "and", "or"].includes(G.value.toLowerCase());
          }
          function W(G) {
            return G.type !== "value-func" ? !1 : t.has(G.value.toLowerCase());
          }
          function X(G) {
            return /\/\//.test(G.split(/[\n\r]/).pop());
          }
          function ue(G) {
            return (G == null ? void 0 : G.type) === "value-atword" && G.value.startsWith("prettier-placeholder-");
          }
          function De(G, z) {
            var U, le;
            if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== "(" || ((le = G.close) === null || le === void 0 ? void 0 : le.value) !== ")" || G.groups.some(function (ge) {
              return ge.type !== "value-comma_group";
            })) return !1;
            if (z.type === "value-comma_group") {
              var ge = z.groups.indexOf(G) - 1,
                Ae = z.groups[ge];
              if ((Ae == null ? void 0 : Ae.type) === "value-word" && Ae.value === "with") return !0;
            }
            return !1;
          }
          function ie(G) {
            var z, U;
            return G.type === "value-paren_group" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === "(" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === ")";
          }
          n.exports = {
            getAncestorCounter: s,
            getAncestorNode: a,
            getPropOfDeclNode: r,
            maybeToLowerCase: c,
            insideValueFunctionNode: v,
            insideICSSRuleNode: m,
            insideAtRuleNode: d,
            insideURLFunctionInImportAtRuleNode: p,
            isKeyframeAtRuleKeywords: o,
            isWideKeywords: i,
            isLastNode: h,
            isSCSSControlDirectiveNode: l,
            isDetachedRulesetDeclarationNode: w,
            isRelationalOperatorNode: F,
            isEqualityOperatorNode: g,
            isMultiplicationNode: B,
            isDivisionNode: I,
            isAdditionNode: k,
            isSubtractionNode: P,
            isModuloNode: C,
            isMathOperatorNode: D,
            isEachKeywordNode: S,
            isForKeywordNode: T,
            isURLFunctionNode: f,
            isIfElseKeywordNode: A,
            hasComposesNode: b,
            hasParensAroundNode: L,
            hasEmptyRawBefore: M,
            isDetachedRulesetCallNode: E,
            isTemplatePlaceholderNode: y,
            isTemplatePropNode: N,
            isPostcssSimpleVarNode: x,
            isKeyValuePairNode: j,
            isKeyValuePairInParenGroupNode: $,
            isKeyInValuePairNode: te,
            isSCSSMapItemNode: V,
            isInlineValueCommentNode: q,
            isHashNode: Y,
            isLeftCurlyBraceNode: H,
            isRightCurlyBraceNode: R,
            isWordNode: Q,
            isColonNode: ee,
            isMediaAndSupportsKeywords: oe,
            isColorAdjusterFuncNode: W,
            lastLineHasInlineComment: X,
            isAtWordPlaceholderNode: ue,
            isConfigurationNode: De,
            isParenGroupNode: ie
          };
        }
      }),
      pd = Z({
        "src/utils/line-column-to-index.js": function srcUtilsLineColumnToIndexJs(e, n) {
          "use strict";

          re(), n.exports = function (t, s) {
            var a = 0;
            for (var r = 0; r < t.line - 1; ++r) {
              a = s.indexOf("\n", a) + 1;
            }
            return a + t.column;
          };
        }
      }),
      fd = Z({
        "src/language-css/loc.js": function srcLanguageCssLocJs(e, n) {
          "use strict";

          re();
          var _Nr4 = Nr(),
            t = _Nr4.skipEverythingButNewLine,
            s = it(),
            a = pd();
          function r(p, f) {
            return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a(p.source.start, f) - 1 : null;
          }
          function u(p, f) {
            if (p.type === "css-comment" && p.inline) return t(f, p.source.startOffset);
            var h = p.nodes && s(p.nodes);
            return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? a(p.source.end, f) : null;
          }
          function i(p, f) {
            p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
            for (var _h4 in p) {
              var _w8 = p[_h4];
              _h4 === "source" || !_w8 || _typeof(_w8) != "object" || (_w8.type === "value-root" || _w8.type === "value-unknown" ? o(_w8, c(p), _w8.text || _w8.value) : i(_w8, f));
            }
          }
          function o(p, f, h) {
            p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);
            for (var _w9 in p) {
              var T = p[_w9];
              _w9 === "source" || !T || _typeof(T) != "object" || o(T, f, h);
            }
          }
          function c(p) {
            var f = p.source.startOffset;
            return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
          }
          function v(p) {
            var f = "initial",
              h = "initial",
              w,
              T = !1,
              A = [];
            for (var S = 0; S < p.length; S++) {
              var B = p[S];
              switch (f) {
                case "initial":
                  if (B === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((B === "u" || B === "U") && p.slice(S, S + 4).toLowerCase() === "url(") {
                    f = "url", S += 3;
                    continue;
                  }
                  if (B === "*" && p[S - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (B === "/" && p[S - 1] === "/") {
                    f = "comment-inline", w = S - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (B === "'" && p[S - 1] !== "\\" && (f = h, h = "initial"), B === "\n" || B === "\r") return p;
                  continue;
                case "double-quotes":
                  if (B === '"' && p[S - 1] !== "\\" && (f = h, h = "initial"), B === "\n" || B === "\r") return p;
                  continue;
                case "url":
                  if (B === ")" && (f = "initial"), B === "\n" || B === "\r") return p;
                  if (B === "'") {
                    f = "single-quotes", h = "url";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes", h = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  B === "/" && p[S - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (B === '"' || B === "'" || B === "*") && (T = !0), (B === "\n" || B === "\r") && (T && A.push([w, S]), f = "initial", T = !1);
                  continue;
              }
            }
            for (var _i16 = 0, _A2 = A; _i16 < _A2.length; _i16++) {
              var _A2$_i = _slicedToArray(_A2[_i16], 2),
                _S2 = _A2$_i[0],
                _B2 = _A2$_i[1];
              p = p.slice(0, _S2) + p.slice(_S2, _B2).replace(/["'*]/g, " ") + p.slice(_B2);
            }
            return p;
          }
          function m(p) {
            return p.source.startOffset;
          }
          function d(p) {
            return p.source.endOffset;
          }
          n.exports = {
            locStart: m,
            locEnd: d,
            calculateLoc: i,
            replaceQuotesInInlineComments: v
          };
        }
      }),
      Dd = Z({
        "src/language-css/utils/is-less-parser.js": function srcLanguageCssUtilsIsLessParserJs(e, n) {
          "use strict";

          re();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          n.exports = t;
        }
      }),
      md = Z({
        "src/language-css/utils/is-scss.js": function srcLanguageCssUtilsIsScssJs(e, n) {
          "use strict";

          re();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          n.exports = t;
        }
      }),
      dd = Z({
        "src/language-css/utils/css-units.evaluate.js": function srcLanguageCssUtilsCssUnitsEvaluateJs(e, n) {
          n.exports = {
            em: "em",
            rem: "rem",
            ex: "ex",
            rex: "rex",
            cap: "cap",
            rcap: "rcap",
            ch: "ch",
            rch: "rch",
            ic: "ic",
            ric: "ric",
            lh: "lh",
            rlh: "rlh",
            vw: "vw",
            svw: "svw",
            lvw: "lvw",
            dvw: "dvw",
            vh: "vh",
            svh: "svh",
            lvh: "lvh",
            dvh: "dvh",
            vi: "vi",
            svi: "svi",
            lvi: "lvi",
            dvi: "dvi",
            vb: "vb",
            svb: "svb",
            lvb: "lvb",
            dvb: "dvb",
            vmin: "vmin",
            svmin: "svmin",
            lvmin: "lvmin",
            dvmin: "dvmin",
            vmax: "vmax",
            svmax: "svmax",
            lvmax: "lvmax",
            dvmax: "dvmax",
            cm: "cm",
            mm: "mm",
            q: "Q",
            in: "in",
            pt: "pt",
            pc: "pc",
            px: "px",
            deg: "deg",
            grad: "grad",
            rad: "rad",
            turn: "turn",
            s: "s",
            ms: "ms",
            hz: "Hz",
            khz: "kHz",
            dpi: "dpi",
            dpcm: "dpcm",
            dppx: "dppx",
            x: "x"
          };
        }
      }),
      gd = Z({
        "src/language-css/utils/print-unit.js": function srcLanguageCssUtilsPrintUnitJs(e, n) {
          "use strict";

          re();
          var t = dd();
          function s(a) {
            var r = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;
          }
          n.exports = s;
        }
      }),
      yd = Z({
        "src/language-css/printer-postcss.js": function srcLanguageCssPrinterPostcssJs(e, n) {
          "use strict";

          re();
          var t = it(),
            _Ue33 = Ue(),
            s = _Ue33.printNumber,
            a = _Ue33.printString,
            r = _Ue33.hasNewline,
            u = _Ue33.isFrontMatterNode,
            i = _Ue33.isNextLineEmpty,
            o = _Ue33.isNonEmptyArray,
            _Oe40 = Oe(),
            _Oe40$builders = _Oe40.builders,
            c = _Oe40$builders.join,
            v = _Oe40$builders.line,
            m = _Oe40$builders.hardline,
            d = _Oe40$builders.softline,
            p = _Oe40$builders.group,
            f = _Oe40$builders.fill,
            h = _Oe40$builders.indent,
            w = _Oe40$builders.dedent,
            T = _Oe40$builders.ifBreak,
            A = _Oe40$builders.breakParent,
            _Oe40$utils = _Oe40.utils,
            S = _Oe40$utils.removeLines,
            B = _Oe40$utils.getDocParts,
            I = ad(),
            k = od(),
            _ld = ld(),
            P = _ld.insertPragma,
            _cd = cd(),
            C = _cd.getAncestorNode,
            D = _cd.getPropOfDeclNode,
            g = _cd.maybeToLowerCase,
            F = _cd.insideValueFunctionNode,
            l = _cd.insideICSSRuleNode,
            E = _cd.insideAtRuleNode,
            y = _cd.insideURLFunctionInImportAtRuleNode,
            N = _cd.isKeyframeAtRuleKeywords,
            x = _cd.isWideKeywords,
            b = _cd.isLastNode,
            L = _cd.isSCSSControlDirectiveNode,
            M = _cd.isDetachedRulesetDeclarationNode,
            j = _cd.isRelationalOperatorNode,
            $ = _cd.isEqualityOperatorNode,
            V = _cd.isMultiplicationNode,
            q = _cd.isDivisionNode,
            Y = _cd.isAdditionNode,
            H = _cd.isSubtractionNode,
            R = _cd.isMathOperatorNode,
            Q = _cd.isEachKeywordNode,
            ee = _cd.isForKeywordNode,
            te = _cd.isURLFunctionNode,
            oe = _cd.isIfElseKeywordNode,
            W = _cd.hasComposesNode,
            X = _cd.hasParensAroundNode,
            ue = _cd.hasEmptyRawBefore,
            De = _cd.isKeyValuePairNode,
            ie = _cd.isKeyInValuePairNode,
            G = _cd.isDetachedRulesetCallNode,
            z = _cd.isTemplatePlaceholderNode,
            U = _cd.isTemplatePropNode,
            le = _cd.isPostcssSimpleVarNode,
            ge = _cd.isSCSSMapItemNode,
            Ae = _cd.isInlineValueCommentNode,
            Ne = _cd.isHashNode,
            ke = _cd.isLeftCurlyBraceNode,
            ce = _cd.isRightCurlyBraceNode,
            pe = _cd.isWordNode,
            de = _cd.isColonNode,
            ae = _cd.isMediaAndSupportsKeywords,
            ve = _cd.isColorAdjusterFuncNode,
            K = _cd.lastLineHasInlineComment,
            he = _cd.isAtWordPlaceholderNode,
            ye = _cd.isConfigurationNode,
            Ce = _cd.isParenGroupNode,
            _fd = fd(),
            Ie = _fd.locStart,
            Fe = _fd.locEnd,
            me = Dd(),
            _ = md(),
            J = gd();
          function ne(be) {
            return be.trailingComma === "es5" || be.trailingComma === "all";
          }
          function Ee(be, Le, qe) {
            var se = be.getValue();
            if (!se) return "";
            if (typeof se == "string") return se;
            switch (se.type) {
              case "front-matter":
                return [se.raw, m];
              case "css-root":
                {
                  var He = We(be, Le, qe),
                    Me = se.raws.after.trim();
                  return [He, Me ? " ".concat(Me) : "", B(He).length > 0 ? m : ""];
                }
              case "css-comment":
                {
                  var _He = se.inline || se.raws.inline,
                    _Me = Le.originalText.slice(Ie(se), Fe(se));
                  return _He ? _Me.trimEnd() : _Me;
                }
              case "css-rule":
                return [qe("selector"), se.important ? " !important" : "", se.nodes ? [se.selector && se.selector.type === "selector-unknown" && K(se.selector.value) ? v : " ", "{", se.nodes.length > 0 ? h([m, We(be, Le, qe)]) : "", m, "}", M(se) ? ";" : ""] : ";"];
              case "css-decl":
                {
                  var _He2 = be.getParentNode(),
                    _Me2 = se.raws.between,
                    ze = _Me2.trim(),
                    nt = ze === ":",
                    tt = W(se) ? S(qe("value")) : qe("value");
                  return !nt && K(ze) && (tt = h([m, w(tt)])), [se.raws.before.replace(/[\s;]/g, ""), l(be) ? se.prop : g(se.prop), ze.startsWith("//") ? " " : "", ze, se.extend ? "" : " ", me(Le) && se.extend && se.selector ? ["extend(", qe("selector"), ")"] : "", tt, se.raws.important ? se.raws.important.replace(/\s*!\s*important/i, " !important") : se.important ? " !important" : "", se.raws.scssDefault ? se.raws.scssDefault.replace(/\s*!default/i, " !default") : se.scssDefault ? " !default" : "", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\s*!global/i, " !global") : se.scssGlobal ? " !global" : "", se.nodes ? [" {", h([d, We(be, Le, qe)]), d, "}"] : U(se) && !_He2.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";" ? "" : Le.__isHTMLStyleAttribute && b(be, se) ? T(";") : ";"];
                }
              case "css-atrule":
                {
                  var _He3 = be.getParentNode(),
                    _Me3 = z(se) && !_He3.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";";
                  if (me(Le)) {
                    if (se.mixin) return [qe("selector"), se.important ? " !important" : "", _Me3 ? "" : ";"];
                    if (se.function) return [se.name, qe("params"), _Me3 ? "" : ";"];
                    if (se.variable) return ["@", se.name, ": ", se.value ? qe("value") : "", se.raws.between.trim() ? se.raws.between.trim() + " " : "", se.nodes ? ["{", h([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : "", _Me3 ? "" : ";"];
                  }
                  return ["@", G(se) || se.name.endsWith(":") ? se.name : g(se.name), se.params ? [G(se) ? "" : z(se) ? se.raws.afterName === "" ? "" : se.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(se.raws.afterName) ? [m, m] : /^\s*\n/.test(se.raws.afterName) ? m : " " : " ", qe("params")] : "", se.selector ? h([" ", qe("selector")]) : "", se.value ? p([" ", qe("value"), L(se) ? X(se) ? " " : v : ""]) : se.name === "else" ? " " : "", se.nodes ? [L(se) ? "" : se.selector && !se.selector.nodes && typeof se.selector.value == "string" && K(se.selector.value) || !se.selector && typeof se.params == "string" && K(se.params) ? v : " ", "{", h([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : _Me3 ? "" : ";"];
                }
              case "media-query-list":
                {
                  var _He4 = [];
                  return be.each(function (Me) {
                    var ze = Me.getValue();
                    ze.type === "media-query" && ze.value === "" || _He4.push(qe());
                  }, "nodes"), p(h(c(v, _He4)));
                }
              case "media-query":
                return [c(" ", be.map(qe, "nodes")), b(be, se) ? "" : ","];
              case "media-type":
                return je(Xe(se.value, Le));
              case "media-feature-expression":
                return se.nodes ? ["("].concat(_toConsumableArray(be.map(qe, "nodes")), [")"]) : se.value;
              case "media-feature":
                return g(Xe(se.value.replace(/ +/g, " "), Le));
              case "media-colon":
                return [se.value, " "];
              case "media-value":
                return je(Xe(se.value, Le));
              case "media-keyword":
                return Xe(se.value, Le);
              case "media-url":
                return Xe(se.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Le);
              case "media-unknown":
                return se.value;
              case "selector-root":
                return p([E(be, "custom-selector") ? [C(be, "css-atrule").customSelector, v] : "", c([",", E(be, ["extend", "custom-selector", "nest"]) ? v : m], be.map(qe, "nodes"))]);
              case "selector-selector":
                return p(h(be.map(qe, "nodes")));
              case "selector-comment":
                return se.value;
              case "selector-string":
                return Xe(se.value, Le);
              case "selector-tag":
                {
                  var _He5 = be.getParentNode(),
                    _Me4 = _He5 && _He5.nodes.indexOf(se),
                    _ze = _Me4 && _He5.nodes[_Me4 - 1];
                  return [se.namespace ? [se.namespace === !0 ? "" : se.namespace.trim(), "|"] : "", _ze.type === "selector-nesting" ? se.value : je(N(be, se.value) ? se.value.toLowerCase() : se.value)];
                }
              case "selector-id":
                return ["#", se.value];
              case "selector-class":
                return [".", je(Xe(se.value, Le))];
              case "selector-attribute":
                return ["[", se.namespace ? [se.namespace === !0 ? "" : se.namespace.trim(), "|"] : "", se.attribute.trim(), se.operator ? se.operator : "", se.value ? _e(Xe(se.value.trim(), Le), Le) : "", se.insensitive ? " i" : "", "]"];
              case "selector-combinator":
                {
                  if (se.value === "+" || se.value === ">" || se.value === "~" || se.value === ">>>") {
                    var _ze2 = be.getParentNode();
                    return [_ze2.type === "selector-selector" && _ze2.nodes[0] === se ? "" : v, se.value, b(be, se) ? "" : " "];
                  }
                  var _He6 = se.value.trim().startsWith("(") ? v : "",
                    _Me5 = je(Xe(se.value.trim(), Le)) || v;
                  return [_He6, _Me5];
                }
              case "selector-universal":
                return [se.namespace ? [se.namespace === !0 ? "" : se.namespace.trim(), "|"] : "", se.value];
              case "selector-pseudo":
                return [g(se.value), o(se.nodes) ? ["(", c(", ", be.map(qe, "nodes")), ")"] : ""];
              case "selector-nesting":
                return se.value;
              case "selector-unknown":
                {
                  var _He7 = C(be, "css-rule");
                  if (_He7 && _He7.isSCSSNesterProperty) return je(Xe(g(se.value), Le));
                  var _Me6 = be.getParentNode();
                  if (_Me6.raws && _Me6.raws.selector) {
                    var _nt = Ie(_Me6),
                      _tt = _nt + _Me6.raws.selector.length;
                    return Le.originalText.slice(_nt, _tt).trim();
                  }
                  var _ze3 = be.getParentNode(1);
                  if (_Me6.type === "value-paren_group" && _ze3 && _ze3.type === "value-func" && _ze3.value === "selector") {
                    var _nt2 = Fe(_Me6.open) + 1,
                      _tt2 = Ie(_Me6.close),
                      pt = Le.originalText.slice(_nt2, _tt2).trim();
                    return K(pt) ? [A, pt] : pt;
                  }
                  return se.value;
                }
              case "value-value":
              case "value-root":
                return qe("group");
              case "value-comment":
                return Le.originalText.slice(Ie(se), Fe(se));
              case "value-comma_group":
                {
                  var _He8 = be.getParentNode(),
                    _Me7 = be.getParentNode(1),
                    _ze4 = D(be),
                    _nt3 = _ze4 && _He8.type === "value-value" && (_ze4 === "grid" || _ze4.startsWith("grid-template")),
                    _tt3 = C(be, "css-atrule"),
                    _pt = _tt3 && L(_tt3),
                    O = se.groups.some(function (ut) {
                      return Ae(ut);
                    }),
                    fe = be.map(qe, "groups"),
                    Te = [],
                    $e = F(be, "url"),
                    Je = !1,
                    Ze = !1;
                  for (var ut = 0; ut < se.groups.length; ++ut) {
                    Te.push(fe[ut]);
                    var rt = se.groups[ut - 1],
                      Ve = se.groups[ut],
                      Ge = se.groups[ut + 1],
                      tr = se.groups[ut + 2];
                    if ($e) {
                      (Ge && Y(Ge) || Y(Ve)) && Te.push(" ");
                      continue;
                    }
                    if (E(be, "forward") && Ve.type === "value-word" && Ve.value && rt !== void 0 && rt.type === "value-word" && rt.value === "as" && Ge.type === "value-operator" && Ge.value === "*" || !Ge || Ve.type === "value-word" && Ve.value.endsWith("-") && he(Ge)) continue;
                    var Eo = Ve.type === "value-string" && Ve.value.startsWith("#{"),
                      Fo = Je && Ge.type === "value-string" && Ge.value.endsWith("}");
                    if (Eo || Fo) {
                      Je = !Je;
                      continue;
                    }
                    if (Je || de(Ve) || de(Ge) || Ve.type === "value-atword" && Ve.value === "" || Ve.value === "~" || Ve.value && Ve.value.includes("\\") && Ge && Ge.type !== "value-comment" || rt && rt.value && rt.value.indexOf("\\") === rt.value.length - 1 && Ve.type === "value-operator" && Ve.value === "/" || Ve.value === "\\" || le(Ve, Ge) || Ne(Ve) || ke(Ve) || ce(Ge) || ke(Ge) && ue(Ge) || ce(Ve) && ue(Ge) || Ve.value === "--" && Ne(Ge)) continue;
                    var Qn = R(Ve),
                      Zn = R(Ge);
                    if ((Qn && Ne(Ge) || Zn && ce(Ve)) && ue(Ge) || !rt && q(Ve) || F(be, "calc") && (Y(Ve) || Y(Ge) || H(Ve) || H(Ge)) && ue(Ge)) continue;
                    var Ao = (Y(Ve) || H(Ve)) && ut === 0 && (Ge.type === "value-number" || Ge.isHex) && _Me7 && ve(_Me7) && !ue(Ge),
                      eu = tr && tr.type === "value-func" || tr && pe(tr) || Ve.type === "value-func" || pe(Ve),
                      tu = Ge.type === "value-func" || pe(Ge) || rt && rt.type === "value-func" || rt && pe(rt);
                    if (!(!(V(Ge) || V(Ve)) && !F(be, "calc") && !Ao && (q(Ge) && !eu || q(Ve) && !tu || Y(Ge) && !eu || Y(Ve) && !tu || H(Ge) || H(Ve)) && (ue(Ge) || Qn && (!rt || rt && R(rt))))) {
                      if (Ae(Ve)) {
                        if (_He8.type === "value-paren_group") {
                          Te.push(w(m));
                          continue;
                        }
                        Te.push(m);
                        continue;
                      }
                      if (_pt && ($(Ge) || j(Ge) || oe(Ge) || Q(Ve) || ee(Ve))) {
                        Te.push(" ");
                        continue;
                      }
                      if (_tt3 && _tt3.name.toLowerCase() === "namespace") {
                        Te.push(" ");
                        continue;
                      }
                      if (_nt3) {
                        Ve.source && Ge.source && Ve.source.start.line !== Ge.source.start.line ? (Te.push(m), Ze = !0) : Te.push(" ");
                        continue;
                      }
                      if (Zn) {
                        Te.push(" ");
                        continue;
                      }
                      if (!(Ge && Ge.value === "...") && !(he(Ve) && he(Ge) && Fe(Ve) === Ie(Ge))) {
                        if (he(Ve) && Ce(Ge) && Fe(Ve) === Ie(Ge.open)) {
                          Te.push(d);
                          continue;
                        }
                        if (Ve.value === "with" && Ce(Ge)) {
                          Te.push(" ");
                          continue;
                        }
                        Te.push(v);
                      }
                    }
                  }
                  return O && Te.push(A), Ze && Te.unshift(m), _pt ? p(h(Te)) : y(be) ? p(f(Te)) : p(h(f(Te)));
                }
              case "value-paren_group":
                {
                  var _He9 = be.getParentNode();
                  if (_He9 && te(_He9) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === "value-comma_group" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === "value-word" && se.groups[0].groups[0].value.startsWith("data:"))) return [se.open ? qe("open") : "", c(",", be.map(qe, "groups")), se.close ? qe("close") : ""];
                  if (!se.open) {
                    var _$e = be.map(qe, "groups"),
                      _Je = [];
                    for (var _Ze = 0; _Ze < _$e.length; _Ze++) {
                      _Ze !== 0 && _Je.push([",", v]), _Je.push(_$e[_Ze]);
                    }
                    return p(h(f(_Je)));
                  }
                  var _Me8 = ge(be),
                    _ze5 = t(se.groups),
                    _nt4 = _ze5 && _ze5.type === "value-comment",
                    _tt4 = ie(se, _He9),
                    _pt2 = ye(se, _He9),
                    _O = _pt2 || _Me8 && !_tt4,
                    _fe = _pt2 || _tt4,
                    _Te = p([se.open ? qe("open") : "", h([d, c([v], be.map(function ($e, Je) {
                      var Ze = $e.getValue(),
                        ut = Je === se.groups.length - 1,
                        rt = [qe(), ut ? "" : ","];
                      if (De(Ze) && Ze.type === "value-comma_group" && Ze.groups && Ze.groups[0].type !== "value-paren_group" && Ze.groups[2] && Ze.groups[2].type === "value-paren_group") {
                        var _Ve = B(rt[0].contents.contents);
                        return _Ve[1] = p(_Ve[1]), p(w(rt));
                      }
                      if (!ut && Ze.type === "value-comma_group" && o(Ze.groups)) {
                        var _Ve2 = t(Ze.groups);
                        _Ve2.source && i(Le.originalText, _Ve2, Fe) && rt.push(m);
                      }
                      return rt;
                    }, "groups"))]), T(!_nt4 && _(Le.parser, Le.originalText) && _Me8 && ne(Le) ? "," : ""), d, se.close ? qe("close") : ""], {
                      shouldBreak: _O
                    });
                  return _fe ? w(_Te) : _Te;
                }
              case "value-func":
                return [se.value, E(be, "supports") && ae(se) ? " " : "", qe("group")];
              case "value-paren":
                return se.value;
              case "value-number":
                return [Re(se.value), J(se.unit)];
              case "value-operator":
                return se.value;
              case "value-word":
                return se.isColor && se.isHex || x(se.value) ? se.value.toLowerCase() : se.value;
              case "value-colon":
                {
                  var _He10 = be.getParentNode(),
                    _Me9 = _He10 && _He10.groups.indexOf(se),
                    _ze6 = _Me9 && _He10.groups[_Me9 - 1];
                  return [se.value, _ze6 && typeof _ze6.value == "string" && t(_ze6.value) === "\\" || F(be, "url") ? "" : v];
                }
              case "value-comma":
                return [se.value, " "];
              case "value-string":
                return a(se.raws.quote + se.value + se.raws.quote, Le);
              case "value-atword":
                return ["@", se.value];
              case "value-unicode-range":
                return se.value;
              case "value-unknown":
                return se.value;
              default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)));
            }
          }
          function We(be, Le, qe) {
            var se = [];
            return be.each(function (He, Me, ze) {
              var nt = ze[Me - 1];
              if (nt && nt.type === "css-comment" && nt.text.trim() === "prettier-ignore") {
                var tt = He.getValue();
                se.push(Le.originalText.slice(Ie(tt), Fe(tt)));
              } else se.push(qe());
              Me !== ze.length - 1 && (ze[Me + 1].type === "css-comment" && !r(Le.originalText, Ie(ze[Me + 1]), {
                backwards: !0
              }) && !u(ze[Me]) || ze[Me + 1].type === "css-atrule" && ze[Me + 1].name === "else" && ze[Me].type !== "css-comment" ? se.push(" ") : (se.push(Le.__isHTMLStyleAttribute ? v : m), i(Le.originalText, He.getValue(), Fe) && !u(ze[Me]) && se.push(m)));
            }, "nodes"), se;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\[\s\S])*\1/g,
            Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g,
            Se = /[A-Za-z]+/g,
            Qe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g,
            xe = new RegExp(Be.source + "|(".concat(Qe.source, ")?(").concat(Pe.source, ")(").concat(Se.source, ")?"), "g");
          function Xe(be, Le) {
            return be.replace(Be, function (qe) {
              return a(qe, Le);
            });
          }
          function _e(be, Le) {
            var qe = Le.singleQuote ? "'" : '"';
            return be.includes('"') || be.includes("'") ? be : qe + be + qe;
          }
          function je(be) {
            return be.replace(xe, function (Le, qe, se, He, Me) {
              return !se && He ? Re(He) + g(Me || "") : Le;
            });
          }
          function Re(be) {
            return s(be).replace(/\.0(?=$|e)/, "");
          }
          n.exports = {
            print: Ee,
            embed: k,
            insertPragma: P,
            massageAstNode: I
          };
        }
      }),
      hd = Z({
        "src/language-css/options.js": function srcLanguageCssOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot();
          n.exports = {
            singleQuote: t.singleQuote
          };
        }
      }),
      vd = Z({
        "src/language-css/parsers.js": function srcLanguageCssParsersJs() {
          re();
        }
      }),
      Cd = Z({
        "node_modules/linguist-languages/data/CSS.json": function node_modulesLinguistLanguagesDataCSSJson(e, n) {
          n.exports = {
            name: "CSS",
            type: "markup",
            tmScope: "source.css",
            aceMode: "css",
            codemirrorMode: "css",
            codemirrorMimeType: "text/css",
            color: "#563d7c",
            extensions: [".css"],
            languageId: 50
          };
        }
      }),
      Ed = Z({
        "node_modules/linguist-languages/data/PostCSS.json": function node_modulesLinguistLanguagesDataPostCSSJson(e, n) {
          n.exports = {
            name: "PostCSS",
            type: "markup",
            color: "#dc3a0c",
            tmScope: "source.postcss",
            group: "CSS",
            extensions: [".pcss", ".postcss"],
            aceMode: "text",
            languageId: 262764437
          };
        }
      }),
      Fd = Z({
        "node_modules/linguist-languages/data/Less.json": function node_modulesLinguistLanguagesDataLessJson(e, n) {
          n.exports = {
            name: "Less",
            type: "markup",
            color: "#1d365d",
            aliases: ["less-css"],
            extensions: [".less"],
            tmScope: "source.css.less",
            aceMode: "less",
            codemirrorMode: "css",
            codemirrorMimeType: "text/css",
            languageId: 198
          };
        }
      }),
      Ad = Z({
        "node_modules/linguist-languages/data/SCSS.json": function node_modulesLinguistLanguagesDataSCSSJson(e, n) {
          n.exports = {
            name: "SCSS",
            type: "markup",
            color: "#c6538c",
            tmScope: "source.css.scss",
            aceMode: "scss",
            codemirrorMode: "css",
            codemirrorMimeType: "text/x-scss",
            extensions: [".scss"],
            languageId: 329
          };
        }
      }),
      Sd = Z({
        "src/language-css/index.js": function srcLanguageCssIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = yd(),
            a = hd(),
            r = vd(),
            u = [t(Cd(), function (o) {
              return {
                since: "1.4.0",
                parsers: ["css"],
                vscodeLanguageIds: ["css"],
                extensions: [].concat(_toConsumableArray(o.extensions), [".wxss"])
              };
            }), t(Ed(), function () {
              return {
                since: "1.4.0",
                parsers: ["css"],
                vscodeLanguageIds: ["postcss"]
              };
            }), t(Fd(), function () {
              return {
                since: "1.4.0",
                parsers: ["less"],
                vscodeLanguageIds: ["less"]
              };
            }), t(Ad(), function () {
              return {
                since: "1.4.0",
                parsers: ["scss"],
                vscodeLanguageIds: ["scss"]
              };
            })],
            i = {
              postcss: s
            };
          n.exports = {
            languages: u,
            options: a,
            printers: i,
            parsers: r
          };
        }
      }),
      xd = Z({
        "src/language-handlebars/loc.js": function srcLanguageHandlebarsLocJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          n.exports = {
            locStart: t,
            locEnd: s
          };
        }
      }),
      bd = Z({
        "src/language-handlebars/clean.js": function srcLanguageHandlebarsCleanJs(e, n) {
          "use strict";

          re();
          function t(s, a) {
            if (s.type === "TextNode") {
              var r = s.chars.trim();
              if (!r) return null;
              a.chars = r.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t.ignoredProperties = new Set(["loc", "selfClosing"]), n.exports = t;
        }
      }),
      Td = Z({
        "vendors/html-void-elements.json": function vendorsHtmlVoidElementsJson(e, n) {
          n.exports = {
            htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]
          };
        }
      }),
      Bd = Z({
        "src/language-handlebars/utils.js": function srcLanguageHandlebarsUtilsJs(e, n) {
          "use strict";

          re();
          var _Td = Td(),
            t = _Td.htmlVoidElements,
            s = it();
          function a(S) {
            var B = S.getValue(),
              I = S.getParentNode(0);
            return !!(m(S, ["ElementNode"]) && s(I.children) === B || m(S, ["Block"]) && s(I.body) === B);
          }
          function r(S) {
            return S.toUpperCase() === S;
          }
          function u(S) {
            return v(S, ["ElementNode"]) && typeof S.tag == "string" && !S.tag.startsWith(":") && (r(S.tag[0]) || S.tag.includes("."));
          }
          var i = new Set(t);
          function o(S) {
            return i.has(S.tag) || u(S) && S.children.every(function (B) {
              return c(B);
            });
          }
          function c(S) {
            return v(S, ["TextNode"]) && !/\S/.test(S.chars);
          }
          function v(S, B) {
            return S && B.includes(S.type);
          }
          function m(S, B) {
            var I = S.getParentNode(0);
            return v(I, B);
          }
          function d(S, B) {
            var I = h(S);
            return v(I, B);
          }
          function p(S, B) {
            var I = w(S);
            return v(I, B);
          }
          function f(S, B) {
            var I, k, P, C;
            var D = S.getValue(),
              g = (I = S.getParentNode(0)) !== null && I !== void 0 ? I : {},
              F = (k = (P = (C = g.children) !== null && C !== void 0 ? C : g.body) !== null && P !== void 0 ? P : g.parts) !== null && k !== void 0 ? k : [],
              l = F.indexOf(D);
            return l !== -1 && F[l + B];
          }
          function h(S) {
            var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return f(S, -B);
          }
          function w(S) {
            return f(S, 1);
          }
          function T(S) {
            return v(S, ["MustacheCommentStatement"]) && typeof S.value == "string" && S.value.trim() === "prettier-ignore";
          }
          function A(S) {
            var B = S.getValue(),
              I = h(S, 2);
            return T(B) || T(I);
          }
          n.exports = {
            getNextNode: w,
            getPreviousNode: h,
            hasPrettierIgnore: A,
            isLastNodeOfSiblings: a,
            isNextNodeOfSomeType: p,
            isNodeOfSomeType: v,
            isParentOfSomeType: m,
            isPreviousNodeOfSomeType: d,
            isVoid: o,
            isWhitespaceNode: c
          };
        }
      }),
      Nd = Z({
        "src/language-handlebars/printer-glimmer.js": function srcLanguageHandlebarsPrinterGlimmerJs(e, n) {
          "use strict";

          re();
          var _Oe41 = Oe(),
            _Oe41$builders = _Oe41.builders,
            t = _Oe41$builders.dedent,
            s = _Oe41$builders.fill,
            a = _Oe41$builders.group,
            r = _Oe41$builders.hardline,
            u = _Oe41$builders.ifBreak,
            i = _Oe41$builders.indent,
            o = _Oe41$builders.join,
            c = _Oe41$builders.line,
            v = _Oe41$builders.softline,
            _Oe41$utils = _Oe41.utils,
            m = _Oe41$utils.getDocParts,
            d = _Oe41$utils.replaceTextEndOfLine,
            _Ue34 = Ue(),
            p = _Ue34.getPreferredQuote,
            f = _Ue34.isNonEmptyArray,
            _xd = xd(),
            h = _xd.locStart,
            w = _xd.locEnd,
            T = bd(),
            _Bd = Bd(),
            A = _Bd.getNextNode,
            S = _Bd.getPreviousNode,
            B = _Bd.hasPrettierIgnore,
            I = _Bd.isLastNodeOfSiblings,
            k = _Bd.isNextNodeOfSomeType,
            P = _Bd.isNodeOfSomeType,
            C = _Bd.isParentOfSomeType,
            D = _Bd.isPreviousNodeOfSomeType,
            g = _Bd.isVoid,
            F = _Bd.isWhitespaceNode,
            l = 2;
          function E(K, he, ye) {
            var Ce = K.getValue();
            if (!Ce) return "";
            if (B(K)) return he.originalText.slice(h(Ce), w(Ce));
            var Ie = he.singleQuote ? "'" : '"';
            switch (Ce.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(K.map(ye, "body"));
              case "ElementNode":
                {
                  var Fe = a(N(K, ye)),
                    me = he.htmlWhitespaceSensitivity === "ignore" && k(K, ["ElementNode"]) ? v : "";
                  if (g(Ce)) return [Fe, me];
                  var _ = ["</", Ce.tag, ">"];
                  return Ce.children.length === 0 ? [Fe, i(_), me] : he.htmlWhitespaceSensitivity === "ignore" ? [Fe, i(x(K, he, ye)), r, i(_), me] : [Fe, i(a(x(K, he, ye))), i(_), me];
                }
              case "BlockStatement":
                {
                  var _Fe2 = K.getParentNode(1);
                  return _Fe2 && _Fe2.inverse && _Fe2.inverse.body.length === 1 && _Fe2.inverse.body[0] === Ce && _Fe2.inverse.body[0].path.parts[0] === "if" ? [ee(K, ye), ue(K, ye, he), De(K, ye, he)] : [R(K, ye), a([ue(K, ye, he), De(K, ye, he), te(K, ye, he)])];
                }
              case "ElementModifierStatement":
                return a(["{{", pe(K, ye), "}}"]);
              case "MustacheStatement":
                return a([L(Ce), pe(K, ye), M(Ce)]);
              case "SubExpression":
                return a(["(", ce(K, ye), v, ")"]);
              case "AttrNode":
                {
                  var _Fe3 = Ce.value.type === "TextNode";
                  if (_Fe3 && Ce.value.chars === "" && h(Ce.value) === w(Ce.value)) return Ce.name;
                  var _2 = _Fe3 ? p(Ce.value.chars, Ie).quote : Ce.value.type === "ConcatStatement" ? p(Ce.value.parts.filter(function (ne) {
                      return ne.type === "TextNode";
                    }).map(function (ne) {
                      return ne.chars;
                    }).join(""), Ie).quote : "",
                    J = ye("value");
                  return [Ce.name, "=", _2, Ce.name === "class" && _2 ? a(i(J)) : J, _2];
                }
              case "ConcatStatement":
                return K.map(ye, "parts");
              case "Hash":
                return o(c, K.map(ye, "pairs"));
              case "HashPair":
                return [Ce.key, "=", ye("value")];
              case "TextNode":
                {
                  var _Fe4 = Ce.chars.replace(/{{/g, "\\{{"),
                    _me2 = z(K);
                  if (_me2) {
                    if (_me2 === "class") {
                      var xe = _Fe4.trim().split(/\s+/).join(" "),
                        Xe = !1,
                        _e = !1;
                      return C(K, ["ConcatStatement"]) && (D(K, ["MustacheStatement"]) && /^\s/.test(_Fe4) && (Xe = !0), k(K, ["MustacheStatement"]) && /\s$/.test(_Fe4) && xe !== "" && (_e = !0)), [Xe ? c : "", xe, _e ? c : ""];
                    }
                    return d(_Fe4);
                  }
                  var _J = /^[\t\n\f\r ]*$/.test(_Fe4),
                    ne = !S(K),
                    Ee = !A(K);
                  if (he.htmlWhitespaceSensitivity !== "ignore") {
                    var _xe = /^[\t\n\f\r ]*/,
                      _Xe = /[\t\n\f\r ]*$/,
                      _e2 = Ee && C(K, ["Template"]),
                      je = ne && C(K, ["Template"]);
                    if (_J) {
                      if (je || _e2) return "";
                      var se = [c],
                        He = U(_Fe4);
                      return He && (se = Ae(He)), I(K) && (se = se.map(function (Me) {
                        return t(Me);
                      })), se;
                    }
                    var _Fe4$match = _Fe4.match(_xe),
                      _Fe4$match2 = _slicedToArray(_Fe4$match, 1),
                      Re = _Fe4$match2[0],
                      _Fe4$match3 = _Fe4.match(_Xe),
                      _Fe4$match4 = _slicedToArray(_Fe4$match3, 1),
                      be = _Fe4$match4[0],
                      Le = [];
                    if (Re) {
                      Le = [c];
                      var _se = U(Re);
                      _se && (Le = Ae(_se)), _Fe4 = _Fe4.replace(_xe, "");
                    }
                    var qe = [];
                    if (be) {
                      if (!_e2) {
                        qe = [c];
                        var _se2 = U(be);
                        _se2 && (qe = Ae(_se2)), I(K) && (qe = qe.map(function (He) {
                          return t(He);
                        }));
                      }
                      _Fe4 = _Fe4.replace(_Xe, "");
                    }
                    return [].concat(_toConsumableArray(Le), [s(ie(_Fe4))], _toConsumableArray(qe));
                  }
                  var We = U(_Fe4),
                    Be = le(_Fe4),
                    Pe = ge(_Fe4);
                  if ((ne || Ee) && _J && C(K, ["Block", "ElementNode", "Template"])) return "";
                  _J && We ? (Be = Math.min(We, l), Pe = 0) : (k(K, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), D(K, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                  var Se = "",
                    Qe = "";
                  return Pe === 0 && k(K, ["MustacheStatement"]) && (Qe = " "), Be === 0 && D(K, ["MustacheStatement"]) && (Se = " "), ne && (Be = 0, Se = ""), Ee && (Pe = 0, Qe = ""), _Fe4 = _Fe4.replace(/^[\t\n\f\r ]+/g, Se).replace(/[\t\n\f\r ]+$/, Qe), [].concat(_toConsumableArray(Ae(Be)), [s(ie(_Fe4))], _toConsumableArray(Ae(Pe)));
                }
              case "MustacheCommentStatement":
                {
                  var _Fe5 = h(Ce),
                    _me3 = w(Ce),
                    _3 = he.originalText.charAt(_Fe5 + 2) === "~",
                    _J2 = he.originalText.charAt(_me3 - 3) === "~",
                    _ne = Ce.value.includes("}}") ? "--" : "";
                  return ["{{", _3 ? "~" : "", "!", _ne, Ce.value, _ne, _J2 ? "~" : "", "}}"];
                }
              case "PathExpression":
                return Ce.original;
              case "BooleanLiteral":
                return String(Ce.value);
              case "CommentStatement":
                return ["<!--", Ce.value, "-->"];
              case "StringLiteral":
                {
                  if (ke(K)) {
                    var _Fe6 = he.singleQuote ? '"' : "'";
                    return Ne(Ce.value, _Fe6);
                  }
                  return Ne(Ce.value, Ie);
                }
              case "NumberLiteral":
                return String(Ce.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(Ce.type));
            }
          }
          function y(K, he) {
            return h(K) - h(he);
          }
          function N(K, he) {
            var ye = K.getValue(),
              Ce = ["attributes", "modifiers", "comments"].filter(function (Fe) {
                return f(ye[Fe]);
              }),
              Ie = Ce.flatMap(function (Fe) {
                return ye[Fe];
              }).sort(y);
            var _iterator44 = _createForOfIteratorHelper(Ce),
              _step44;
            try {
              for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                var Fe = _step44.value;
                K.each(function (me) {
                  var _ = Ie.indexOf(me.getValue());
                  Ie.splice(_, 1, [c, he()]);
                }, Fe);
              }
            } catch (err) {
              _iterator44.e(err);
            } finally {
              _iterator44.f();
            }
            return f(ye.blockParams) && Ie.push(c, ve(ye)), ["<", ye.tag, i(Ie), b(ye)];
          }
          function x(K, he, ye) {
            var Ie = K.getValue().children.every(function (Fe) {
              return F(Fe);
            });
            return he.htmlWhitespaceSensitivity === "ignore" && Ie ? "" : K.map(function (Fe, me) {
              var _ = ye();
              return me === 0 && he.htmlWhitespaceSensitivity === "ignore" ? [v, _] : _;
            }, "children");
          }
          function b(K) {
            return g(K) ? u([v, "/>"], [" />", v]) : u([v, ">"], ">");
          }
          function L(K) {
            var he = K.escaped === !1 ? "{{{" : "{{",
              ye = K.strip && K.strip.open ? "~" : "";
            return [he, ye];
          }
          function M(K) {
            var he = K.escaped === !1 ? "}}}" : "}}";
            return [K.strip && K.strip.close ? "~" : "", he];
          }
          function j(K) {
            var he = L(K),
              ye = K.openStrip.open ? "~" : "";
            return [he, ye, "#"];
          }
          function $(K) {
            var he = M(K);
            return [K.openStrip.close ? "~" : "", he];
          }
          function V(K) {
            var he = L(K),
              ye = K.closeStrip.open ? "~" : "";
            return [he, ye, "/"];
          }
          function q(K) {
            var he = M(K);
            return [K.closeStrip.close ? "~" : "", he];
          }
          function Y(K) {
            var he = L(K),
              ye = K.inverseStrip.open ? "~" : "";
            return [he, ye];
          }
          function H(K) {
            var he = M(K);
            return [K.inverseStrip.close ? "~" : "", he];
          }
          function R(K, he) {
            var ye = K.getValue(),
              Ce = j(ye),
              Ie = $(ye),
              Fe = [de(K, he)],
              me = ae(K, he);
            if (me && Fe.push(c, me), f(ye.program.blockParams)) {
              var _ = ve(ye.program);
              Fe.push(c, _);
            }
            return a([Ce, i(Fe), v, Ie]);
          }
          function Q(K, he) {
            return [he.htmlWhitespaceSensitivity === "ignore" ? r : "", Y(K), "else", H(K)];
          }
          function ee(K, he) {
            var ye = K.getParentNode(1);
            return [Y(ye), "else if ", ae(K, he), H(ye)];
          }
          function te(K, he, ye) {
            var Ce = K.getValue();
            return ye.htmlWhitespaceSensitivity === "ignore" ? [oe(Ce) ? v : r, V(Ce), he("path"), q(Ce)] : [V(Ce), he("path"), q(Ce)];
          }
          function oe(K) {
            return P(K, ["BlockStatement"]) && K.program.body.every(function (he) {
              return F(he);
            });
          }
          function W(K) {
            return X(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], ["BlockStatement"]) && K.inverse.body[0].path.parts[0] === "if";
          }
          function X(K) {
            return P(K, ["BlockStatement"]) && K.inverse;
          }
          function ue(K, he, ye) {
            var Ce = K.getValue();
            if (oe(Ce)) return "";
            var Ie = he("program");
            return ye.htmlWhitespaceSensitivity === "ignore" ? i([r, Ie]) : i(Ie);
          }
          function De(K, he, ye) {
            var Ce = K.getValue(),
              Ie = he("inverse"),
              Fe = ye.htmlWhitespaceSensitivity === "ignore" ? [r, Ie] : Ie;
            return W(Ce) ? Fe : X(Ce) ? [Q(Ce, ye), i(Fe)] : "";
          }
          function ie(K) {
            return m(o(c, G(K)));
          }
          function G(K) {
            return K.split(/[\t\n\f\r ]+/);
          }
          function z(K) {
            for (var he = 0; he < 2; he++) {
              var ye = K.getParentNode(he);
              if (ye && ye.type === "AttrNode") return ye.name.toLowerCase();
            }
          }
          function U(K) {
            return K = typeof K == "string" ? K : "", K.split("\n").length - 1;
          }
          function le(K) {
            K = typeof K == "string" ? K : "";
            var he = (K.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return U(he);
          }
          function ge(K) {
            K = typeof K == "string" ? K : "";
            var he = (K.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return U(he);
          }
          function Ae() {
            var K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({
              length: Math.min(K, l)
            }).fill(r);
          }
          function Ne(K, he) {
            var _p5 = p(K, he),
              ye = _p5.quote,
              Ce = _p5.regex;
            return [ye, K.replace(Ce, "\\".concat(ye)), ye];
          }
          function ke(K) {
            var he = 0,
              ye = K.getParentNode(he);
            for (; ye && P(ye, ["SubExpression"]);) {
              he++, ye = K.getParentNode(he);
            }
            return !!(ye && P(K.getParentNode(he + 1), ["ConcatStatement"]) && P(K.getParentNode(he + 2), ["AttrNode"]));
          }
          function ce(K, he) {
            var ye = de(K, he),
              Ce = ae(K, he);
            return Ce ? i([ye, c, a(Ce)]) : ye;
          }
          function pe(K, he) {
            var ye = de(K, he),
              Ce = ae(K, he);
            return Ce ? [i([ye, c, Ce]), v] : ye;
          }
          function de(K, he) {
            return he("path");
          }
          function ae(K, he) {
            var ye = K.getValue(),
              Ce = [];
            if (ye.params.length > 0) {
              var Ie = K.map(he, "params");
              Ce.push.apply(Ce, _toConsumableArray(Ie));
            }
            if (ye.hash && ye.hash.pairs.length > 0) {
              var _Ie = he("hash");
              Ce.push(_Ie);
            }
            return Ce.length === 0 ? "" : o(c, Ce);
          }
          function ve(K) {
            return ["as |", K.blockParams.join(" "), "|"];
          }
          n.exports = {
            print: E,
            massageAstNode: T
          };
        }
      }),
      wd = Z({
        "src/language-handlebars/parsers.js": function srcLanguageHandlebarsParsersJs() {
          re();
        }
      }),
      _d = Z({
        "node_modules/linguist-languages/data/Handlebars.json": function node_modulesLinguistLanguagesDataHandlebarsJson(e, n) {
          n.exports = {
            name: "Handlebars",
            type: "markup",
            color: "#f7931e",
            aliases: ["hbs", "htmlbars"],
            extensions: [".handlebars", ".hbs"],
            tmScope: "text.html.handlebars",
            aceMode: "handlebars",
            languageId: 155
          };
        }
      }),
      Pd = Z({
        "src/language-handlebars/index.js": function srcLanguageHandlebarsIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = Nd(),
            a = wd(),
            r = [t(_d(), function () {
              return {
                since: "2.3.0",
                parsers: ["glimmer"],
                vscodeLanguageIds: ["handlebars"]
              };
            })],
            u = {
              glimmer: s
            };
          n.exports = {
            languages: r,
            printers: u,
            parsers: a
          };
        }
      }),
      kd = Z({
        "src/language-graphql/pragma.js": function srcLanguageGraphqlPragmaJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return "# @format\n\n" + a;
          }
          n.exports = {
            hasPragma: t,
            insertPragma: s
          };
        }
      }),
      Id = Z({
        "src/language-graphql/loc.js": function srcLanguageGraphqlLocJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          n.exports = {
            locStart: t,
            locEnd: s
          };
        }
      }),
      Ld = Z({
        "src/language-graphql/printer-graphql.js": function srcLanguageGraphqlPrinterGraphqlJs(e, n) {
          "use strict";

          re();
          var _Oe42 = Oe(),
            _Oe42$builders = _Oe42.builders,
            t = _Oe42$builders.join,
            s = _Oe42$builders.hardline,
            a = _Oe42$builders.line,
            r = _Oe42$builders.softline,
            u = _Oe42$builders.group,
            i = _Oe42$builders.indent,
            o = _Oe42$builders.ifBreak,
            _Ue35 = Ue(),
            c = _Ue35.isNextLineEmpty,
            v = _Ue35.isNonEmptyArray,
            _kd = kd(),
            m = _kd.insertPragma,
            _Id = Id(),
            d = _Id.locStart,
            p = _Id.locEnd;
          function f(k, P, C) {
            var D = k.getValue();
            if (!D) return "";
            if (typeof D == "string") return D;
            switch (D.kind) {
              case "Document":
                {
                  var g = [];
                  return k.each(function (F, l, E) {
                    g.push(C()), l !== E.length - 1 && (g.push(s), c(P.originalText, F.getValue(), p) && g.push(s));
                  }, "definitions"), [].concat(g, [s]);
                }
              case "OperationDefinition":
                {
                  var _g2 = P.originalText[d(D)] !== "{",
                    F = Boolean(D.name);
                  return [_g2 ? D.operation : "", _g2 && F ? [" ", C("name")] : "", _g2 && !F && v(D.variableDefinitions) ? " " : "", v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", h(k, C, D), D.selectionSet ? !_g2 && !F ? "" : " " : "", C("selectionSet")];
                }
              case "FragmentDefinition":
                return ["fragment ", C("name"), v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", " on ", C("typeCondition"), h(k, C, D), " ", C("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, w(k, P, C, "selections"))]), s, "}"];
              case "Field":
                return u([D.alias ? [C("alias"), ": "] : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", h(k, C, D), D.selectionSet ? " " : "", C("selectionSet")]);
              case "Name":
                return D.value;
              case "StringValue":
                {
                  if (D.block) {
                    var _g3 = D.value.replace(/"""/g, "\\$&").split("\n");
                    return _g3.length === 1 && (_g3[0] = _g3[0].trim()), _g3.every(function (F) {
                      return F === "";
                    }) && (_g3.length = 0), t(s, ['"""'].concat(_toConsumableArray(_g3), ['"""']));
                  }
                  return ['"', D.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return D.value;
              case "BooleanValue":
                return D.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", C("name")];
              case "ListValue":
                return u(["[", i([r, t([o("", ", "), r], k.map(C, "values"))]), r, "]"]);
              case "ObjectValue":
                return u(["{", P.bracketSpacing && D.fields.length > 0 ? " " : "", i([r, t([o("", ", "), r], k.map(C, "fields"))]), r, o("", P.bracketSpacing && D.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [C("name"), ": ", C("value")];
              case "Directive":
                return ["@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : ""];
              case "NamedType":
                return C("name");
              case "VariableDefinition":
                return [C("variable"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h(k, C, D)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "ObjectTypeExtension" ? "extend " : "", "type ", C("name"), D.interfaces.length > 0 ? [" implements "].concat(_toConsumableArray(S(k, P, C))) : "", h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [C("description"), D.description ? s : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", ": ", C("type"), h(k, C, D)];
              case "DirectiveDefinition":
                return [C("description"), D.description ? s : "", "directive ", "@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", D.repeatable ? " repeatable" : "", " on ", t(" | ", k.map(C, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "EnumTypeExtension" ? "extend " : "", "enum ", C("name"), h(k, C, D), D.values.length > 0 ? [" {", i([s, t(s, w(k, P, C, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [C("description"), D.description ? s : "", C("name"), h(k, C, D)];
              case "InputValueDefinition":
                return [C("description"), D.description ? D.description.block ? s : a : "", C("name"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h(k, C, D)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", C("name"), h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", h(k, C, D)].concat(_toConsumableArray(D.operationTypes.length > 0 ? [" {", i([s, t(s, w(k, P, C, "operationTypes"))]), s, "}"] : []));
              case "SchemaDefinition":
                return [C("description"), D.description ? s : "", "schema", h(k, C, D), " {", D.operationTypes.length > 0 ? i([s, t(s, w(k, P, C, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [C("operation"), ": ", C("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", C("name"), D.interfaces.length > 0 ? [" implements "].concat(_toConsumableArray(S(k, P, C))) : "", h(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", C("name"), h(k, C, D)];
              case "InlineFragment":
                return ["...", D.typeCondition ? [" on ", C("typeCondition")] : "", h(k, C, D), " ", C("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([C("description"), D.description ? s : "", u([D.kind === "UnionTypeExtension" ? "extend " : "", "union ", C("name"), h(k, C, D), D.types.length > 0 ? [" =", o("", " "), i([o([a, "  "]), t([a, "| "], k.map(C, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", C("name"), h(k, C, D)];
              case "NonNullType":
                return [C("type"), "!"];
              case "ListType":
                return ["[", C("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(D.kind));
            }
          }
          function h(k, P, C) {
            if (C.directives.length === 0) return "";
            var D = t(a, k.map(P, "directives"));
            return C.kind === "FragmentDefinition" || C.kind === "OperationDefinition" ? u([a, D]) : [" ", u(i([r, D]))];
          }
          function w(k, P, C, D) {
            return k.map(function (g, F, l) {
              var E = C();
              return F < l.length - 1 && c(P.originalText, g.getValue(), p) ? [E, s] : E;
            }, D);
          }
          function T(k) {
            return k.kind && k.kind !== "Comment";
          }
          function A(k) {
            var P = k.getValue();
            if (P.kind === "Comment") return "#" + P.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(P));
          }
          function S(k, P, C) {
            var D = k.getNode(),
              g = [],
              F = D.interfaces,
              l = k.map(function (E) {
                return C(E);
              }, "interfaces");
            for (var E = 0; E < F.length; E++) {
              var y = F[E];
              g.push(l[E]);
              var N = F[E + 1];
              if (N) {
                var x = P.originalText.slice(y.loc.end, N.loc.start),
                  b = x.includes("#"),
                  L = x.replace(/#.*/g, "").trim();
                g.push(L === "," ? "," : " &", b ? a : " ");
              }
            }
            return g;
          }
          function B(k, P) {
            k.kind === "StringValue" && k.block && !k.value.includes("\n") && (P.value = P.value.trim());
          }
          B.ignoredProperties = new Set(["loc", "comments"]);
          function I(k) {
            var P;
            var C = k.getValue();
            return C == null || (P = C.comments) === null || P === void 0 ? void 0 : P.some(function (D) {
              return D.value.trim() === "prettier-ignore";
            });
          }
          n.exports = {
            print: f,
            massageAstNode: B,
            hasPrettierIgnore: I,
            insertPragma: m,
            printComment: A,
            canAttachComment: T
          };
        }
      }),
      jd = Z({
        "src/language-graphql/options.js": function srcLanguageGraphqlOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot();
          n.exports = {
            bracketSpacing: t.bracketSpacing
          };
        }
      }),
      Od = Z({
        "src/language-graphql/parsers.js": function srcLanguageGraphqlParsersJs() {
          re();
        }
      }),
      qd = Z({
        "node_modules/linguist-languages/data/GraphQL.json": function node_modulesLinguistLanguagesDataGraphQLJson(e, n) {
          n.exports = {
            name: "GraphQL",
            type: "data",
            color: "#e10098",
            extensions: [".graphql", ".gql", ".graphqls"],
            tmScope: "source.graphql",
            aceMode: "text",
            languageId: 139
          };
        }
      }),
      Md = Z({
        "src/language-graphql/index.js": function srcLanguageGraphqlIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = Ld(),
            a = jd(),
            r = Od(),
            u = [t(qd(), function () {
              return {
                since: "1.5.0",
                parsers: ["graphql"],
                vscodeLanguageIds: ["graphql"]
              };
            })],
            i = {
              graphql: s
            };
          n.exports = {
            languages: u,
            options: a,
            printers: i,
            parsers: r
          };
        }
      }),
      go = Z({
        "src/language-markdown/loc.js": function srcLanguageMarkdownLocJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          n.exports = {
            locStart: t,
            locEnd: s
          };
        }
      }),
      Rd = Z({
        "src/language-markdown/constants.evaluate.js": function srcLanguageMarkdownConstantsEvaluateJs(e, n) {
          n.exports = {
            cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
            kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
            punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
          };
        }
      }),
      Kn = Z({
        "src/language-markdown/utils.js": function srcLanguageMarkdownUtilsJs(e, n) {
          "use strict";

          re();
          var _Ue36 = Ue(),
            t = _Ue36.getLast,
            _go = go(),
            s = _go.locStart,
            a = _go.locEnd,
            _Rd = Rd(),
            r = _Rd.cjkPattern,
            u = _Rd.kPattern,
            i = _Rd.punctuationPattern,
            o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"],
            c = [].concat(o, ["tableCell", "paragraph", "heading"]),
            v = new RegExp(u),
            m = new RegExp(i);
          function d(A, S) {
            var B = "non-cjk",
              I = "cj-letter",
              k = "k-letter",
              P = "cjk-punctuation",
              C = [],
              D = (S.proseWrap === "preserve" ? A : A.replace(new RegExp("(".concat(r, ")\n(").concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
            var _iterator45 = _createForOfIteratorHelper(D.entries()),
              _step45;
            try {
              for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
                var _step45$value = _slicedToArray(_step45.value, 2),
                  F = _step45$value[0],
                  l = _step45$value[1];
                if (F % 2 === 1) {
                  C.push({
                    type: "whitespace",
                    value: /\n/.test(l) ? "\n" : " "
                  });
                  continue;
                }
                if ((F === 0 || F === D.length - 1) && l === "") continue;
                var E = l.split(new RegExp("(".concat(r, ")")));
                var _iterator46 = _createForOfIteratorHelper(E.entries()),
                  _step46;
                try {
                  for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
                    var _step46$value = _slicedToArray(_step46.value, 2),
                      y = _step46$value[0],
                      N = _step46$value[1];
                    if (!((y === 0 || y === E.length - 1) && N === "")) {
                      if (y % 2 === 0) {
                        N !== "" && g({
                          type: "word",
                          value: N,
                          kind: B,
                          hasLeadingPunctuation: m.test(N[0]),
                          hasTrailingPunctuation: m.test(t(N))
                        });
                        continue;
                      }
                      g(m.test(N) ? {
                        type: "word",
                        value: N,
                        kind: P,
                        hasLeadingPunctuation: !0,
                        hasTrailingPunctuation: !0
                      } : {
                        type: "word",
                        value: N,
                        kind: v.test(N) ? k : I,
                        hasLeadingPunctuation: !1,
                        hasTrailingPunctuation: !1
                      });
                    }
                  }
                } catch (err) {
                  _iterator46.e(err);
                } finally {
                  _iterator46.f();
                }
              }
            } catch (err) {
              _iterator45.e(err);
            } finally {
              _iterator45.f();
            }
            return C;
            function g(F) {
              var l = t(C);
              l && l.type === "word" && (l.kind === B && F.kind === I && !l.hasTrailingPunctuation || l.kind === I && F.kind === B && !F.hasLeadingPunctuation ? C.push({
                type: "whitespace",
                value: " "
              }) : !E(B, P) && ![l.value, F.value].some(function (y) {
                return /\u3000/.test(y);
              }) && C.push({
                type: "whitespace",
                value: ""
              })), C.push(F);
              function E(y, N) {
                return l.kind === y && F.kind === N || l.kind === N && F.kind === y;
              }
            }
          }
          function p(A, S) {
            var _S$slice$match = S.slice(A.position.start.offset, A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/),
              _S$slice$match2 = _slicedToArray(_S$slice$match, 4),
              B = _S$slice$match2[1],
              I = _S$slice$match2[2],
              k = _S$slice$match2[3];
            return {
              numberText: B,
              marker: I,
              leadingSpaces: k
            };
          }
          function f(A, S) {
            if (!A.ordered || A.children.length < 2) return !1;
            var B = Number(p(A.children[0], S.originalText).numberText),
              I = Number(p(A.children[1], S.originalText).numberText);
            if (B === 0 && A.children.length > 2) {
              var k = Number(p(A.children[2], S.originalText).numberText);
              return I === 1 && k === 1;
            }
            return I === 1;
          }
          function h(A, S) {
            var B = A.value;
            return A.position.end.offset === S.length && B.endsWith("\n") && S.endsWith("\n") ? B.slice(0, -1) : B;
          }
          function w(A, S) {
            return function B(I, k, P) {
              var C = Object.assign({}, S(I, k, P));
              return C.children && (C.children = C.children.map(function (D, g) {
                return B(D, g, [C].concat(_toConsumableArray(P)));
              })), C;
            }(A, null, []);
          }
          function T(A) {
            if ((A == null ? void 0 : A.type) !== "link" || A.children.length !== 1) return !1;
            var _A$children = _slicedToArray(A.children, 1),
              S = _A$children[0];
            return s(A) === s(S) && a(A) === a(S);
          }
          n.exports = {
            mapAst: w,
            splitText: d,
            punctuationPattern: i,
            getFencedCodeBlockValue: h,
            getOrderedListItemInfo: p,
            hasGitDiffFriendlyOrderedList: f,
            INLINE_NODE_TYPES: o,
            INLINE_NODE_WRAPPER_TYPES: c,
            isAutolink: T
          };
        }
      }),
      Vd = Z({
        "src/language-markdown/embed.js": function srcLanguageMarkdownEmbedJs(e, n) {
          "use strict";

          re();
          var _Ue37 = Ue(),
            t = _Ue37.inferParserByLanguage,
            s = _Ue37.getMaxContinuousCount,
            _Oe43 = Oe(),
            _Oe43$builders = _Oe43.builders,
            a = _Oe43$builders.hardline,
            r = _Oe43$builders.markAsRoot,
            u = _Oe43.utils.replaceEndOfLine,
            i = Xn(),
            _Kn = Kn(),
            o = _Kn.getFencedCodeBlockValue;
          function c(v, m, d, p) {
            var f = v.getValue();
            if (f.type === "code" && f.lang !== null) {
              var _h5 = t(f.lang, p);
              if (_h5) {
                var _w10 = p.__inJsTemplate ? "~" : "`",
                  T = _w10.repeat(Math.max(3, s(f.value, _w10) + 1)),
                  A = {
                    parser: _h5
                  };
                f.lang === "tsx" && (A.filepath = "dummy.tsx");
                var S = d(o(f, p.originalText), A, {
                  stripTrailingHardline: !0
                });
                return r([T, f.lang, f.meta ? " " + f.meta : "", a, u(S), a, T]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, d);
              case "importExport":
                return [d(f.value, {
                  parser: "babel"
                }, {
                  stripTrailingHardline: !0
                }), a];
              case "jsx":
                return d("<$>".concat(f.value, "</$>"), {
                  parser: "__js_expression",
                  rootMarker: "mdx"
                }, {
                  stripTrailingHardline: !0
                });
            }
            return null;
          }
          n.exports = c;
        }
      }),
      yo = Z({
        "src/language-markdown/pragma.js": function srcLanguageMarkdownPragmaJs(e, n) {
          "use strict";

          re();
          var t = mo(),
            s = ["format", "prettier"];
          function a(r) {
            var u = "@(".concat(s.join("|"), ")"),
              i = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(u, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m"),
              o = r.match(i);
            return (o == null ? void 0 : o.index) === 0;
          }
          n.exports = {
            startWithPragma: a,
            hasPragma: function hasPragma(r) {
              return a(t(r).content.trimStart());
            },
            insertPragma: function insertPragma(r) {
              var u = t(r),
                i = "<!-- @".concat(s[0], " -->");
              return u.frontMatter ? "".concat(u.frontMatter.raw, "\n\n").concat(i, "\n\n").concat(u.content) : "".concat(i, "\n\n").concat(u.content);
            }
          };
        }
      }),
      Wd = Z({
        "src/language-markdown/print-preprocess.js": function srcLanguageMarkdownPrintPreprocessJs(e, n) {
          "use strict";

          re();
          var t = it(),
            _Kn2 = Kn(),
            s = _Kn2.getOrderedListItemInfo,
            a = _Kn2.mapAst,
            r = _Kn2.splitText,
            u = /^(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])$/;
          function i(T, A) {
            return T = v(T, A), T = p(T), T = c(T), T = h(T, A), T = w(T, A), T = f(T, A), T = o(T), T = m(T), T;
          }
          function o(T) {
            return a(T, function (A) {
              return A.type !== "import" && A.type !== "export" ? A : Object.assign(Object.assign({}, A), {}, {
                type: "importExport"
              });
            });
          }
          function c(T) {
            return a(T, function (A) {
              return A.type !== "inlineCode" ? A : Object.assign(Object.assign({}, A), {}, {
                value: A.value.replace(/\s+/g, " ")
              });
            });
          }
          function v(T, A) {
            return a(T, function (S) {
              return S.type !== "text" || S.value === "*" || S.value === "_" || !u.test(S.value) || S.position.end.offset - S.position.start.offset === S.value.length ? S : Object.assign(Object.assign({}, S), {}, {
                value: A.originalText.slice(S.position.start.offset, S.position.end.offset)
              });
            });
          }
          function m(T) {
            return d(T, function (A, S) {
              return A.type === "importExport" && S.type === "importExport";
            }, function (A, S) {
              return {
                type: "importExport",
                value: A.value + "\n\n" + S.value,
                position: {
                  start: A.position.start,
                  end: S.position.end
                }
              };
            });
          }
          function d(T, A, S) {
            return a(T, function (B) {
              if (!B.children) return B;
              var I = B.children.reduce(function (k, P) {
                var C = t(k);
                return C && A(C, P) ? k.splice(-1, 1, S(C, P)) : k.push(P), k;
              }, []);
              return Object.assign(Object.assign({}, B), {}, {
                children: I
              });
            });
          }
          function p(T) {
            return d(T, function (A, S) {
              return A.type === "text" && S.type === "text";
            }, function (A, S) {
              return {
                type: "text",
                value: A.value + S.value,
                position: {
                  start: A.position.start,
                  end: S.position.end
                }
              };
            });
          }
          function f(T, A) {
            return a(T, function (S, B, I) {
              var _I = _slicedToArray(I, 1),
                k = _I[0];
              if (S.type !== "text") return S;
              var P = S.value;
              return k.type === "paragraph" && (B === 0 && (P = P.trimStart()), B === k.children.length - 1 && (P = P.trimEnd())), {
                type: "sentence",
                position: S.position,
                children: r(P, A)
              };
            });
          }
          function h(T, A) {
            return a(T, function (S, B, I) {
              if (S.type === "code") {
                var k = /^\n?(?: {4,}|\t)/.test(A.originalText.slice(S.position.start.offset, S.position.end.offset));
                if (S.isIndented = k, k) for (var P = 0; P < I.length; P++) {
                  var C = I[P];
                  if (C.hasIndentedCodeblock) break;
                  C.type === "list" && (C.hasIndentedCodeblock = !0);
                }
              }
              return S;
            });
          }
          function w(T, A) {
            return a(T, function (I, k, P) {
              if (I.type === "list" && I.children.length > 0) {
                for (var C = 0; C < P.length; C++) {
                  var D = P[C];
                  if (D.type === "list" && !D.isAligned) return I.isAligned = !1, I;
                }
                I.isAligned = B(I);
              }
              return I;
            });
            function S(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function B(I) {
              if (!I.ordered) return !0;
              var _I$children = _slicedToArray(I.children, 2),
                k = _I$children[0],
                P = _I$children[1];
              if (s(k, A.originalText).leadingSpaces.length > 1) return !0;
              var D = S(k);
              if (D === -1) return !1;
              if (I.children.length === 1) return D % A.tabWidth === 0;
              var g = S(P);
              return D !== g ? !1 : D % A.tabWidth === 0 ? !0 : s(P, A.originalText).leadingSpaces.length > 1;
            }
          }
          n.exports = i;
        }
      }),
      $d = Z({
        "src/language-markdown/clean.js": function srcLanguageMarkdownCleanJs(e, n) {
          "use strict";

          re();
          var _Ue38 = Ue(),
            t = _Ue38.isFrontMatterNode,
            _yo = yo(),
            s = _yo.startWithPragma,
            a = new Set(["position", "raw"]);
          function r(u, i, o) {
            if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i.value, u.type === "list" && delete i.isAligned, (u.type === "list" || u.type === "listItem") && (delete i.spread, delete i.loose), u.type === "text" || (u.type === "inlineCode" && (i.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i.title = u.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === "html" && s(u.value))) return null;
          }
          r.ignoredProperties = a, n.exports = r;
        }
      }),
      Hd = Z({
        "src/language-markdown/printer-markdown.js": function srcLanguageMarkdownPrinterMarkdownJs(e, n) {
          "use strict";

          re();
          var _Ue39 = Ue(),
            t = _Ue39.getLast,
            s = _Ue39.getMinNotPresentContinuousCount,
            a = _Ue39.getMaxContinuousCount,
            r = _Ue39.getStringWidth,
            u = _Ue39.isNonEmptyArray,
            _Oe44 = Oe(),
            _Oe44$builders = _Oe44.builders,
            i = _Oe44$builders.breakParent,
            o = _Oe44$builders.join,
            c = _Oe44$builders.line,
            v = _Oe44$builders.literalline,
            m = _Oe44$builders.markAsRoot,
            d = _Oe44$builders.hardline,
            p = _Oe44$builders.softline,
            f = _Oe44$builders.ifBreak,
            h = _Oe44$builders.fill,
            w = _Oe44$builders.align,
            T = _Oe44$builders.indent,
            A = _Oe44$builders.group,
            S = _Oe44$builders.hardlineWithoutBreakParent,
            _Oe44$utils = _Oe44.utils,
            B = _Oe44$utils.normalizeDoc,
            I = _Oe44$utils.replaceTextEndOfLine,
            k = _Oe44.printer.printDocToString,
            P = Vd(),
            _yo2 = yo(),
            C = _yo2.insertPragma,
            _go2 = go(),
            D = _go2.locStart,
            g = _go2.locEnd,
            F = Wd(),
            l = $d(),
            _Kn3 = Kn(),
            E = _Kn3.getFencedCodeBlockValue,
            y = _Kn3.hasGitDiffFriendlyOrderedList,
            N = _Kn3.splitText,
            x = _Kn3.punctuationPattern,
            b = _Kn3.INLINE_NODE_TYPES,
            L = _Kn3.INLINE_NODE_WRAPPER_TYPES,
            M = _Kn3.isAutolink,
            j = new Set(["importExport"]),
            $ = ["heading", "tableCell", "link", "wikiLink"],
            V = new Set(["listItem", "definition", "footnoteDefinition"]);
          function q(ce, pe, de) {
            var ae = ce.getValue();
            if (le(ce)) return N(pe.originalText.slice(ae.position.start.offset, ae.position.end.offset), pe).map(function (ve) {
              return ve.type === "word" ? ve.value : ve.value === "" ? "" : oe(ce, ve.value, pe);
            });
            switch (ae.type) {
              case "front-matter":
                return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
              case "root":
                return ae.children.length === 0 ? "" : [B(X(ce, pe, de)), j.has(De(ae).type) ? "" : d];
              case "paragraph":
                return ue(ce, pe, de, {
                  postprocessor: h
                });
              case "sentence":
                return ue(ce, pe, de);
              case "word":
                {
                  var ve = ae.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x, ")(_+)"), "(_+)(".concat(x, "|$)")].join("|"), "g"), function (ye, Ce, Ie, Fe, me) {
                      return (Ie ? "".concat(Ce).concat(Ie) : "".concat(Fe).concat(me)).replace(/_/g, "\\_");
                    }),
                    K = function K(ye, Ce, Ie) {
                      return ye.type === "sentence" && Ie === 0;
                    },
                    he = function he(ye, Ce, Ie) {
                      return M(ye.children[Ie - 1]);
                    };
                  return ve !== ae.value && (ce.match(void 0, K, he) || ce.match(void 0, K, function (ye, Ce, Ie) {
                    return ye.type === "emphasis" && Ie === 0;
                  }, he)) && (ve = ve.replace(/^(\\?[*_])+/, function (ye) {
                    return ye.replace(/\\/g, "");
                  })), ve;
                }
              case "whitespace":
                {
                  var _ve5 = ce.getParentNode(),
                    _K = _ve5.children.indexOf(ae),
                    _he = _ve5.children[_K + 1],
                    ye = _he && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(_he.value) ? "never" : pe.proseWrap;
                  return oe(ce, ae.value, {
                    proseWrap: ye
                  });
                }
              case "emphasis":
                {
                  var _ve6;
                  if (M(ae.children[0])) _ve6 = pe.originalText[ae.position.start.offset];else {
                    var _K2 = ce.getParentNode(),
                      _he2 = _K2.children.indexOf(ae),
                      _ye = _K2.children[_he2 - 1],
                      Ce = _K2.children[_he2 + 1];
                    _ve6 = _ye && _ye.type === "sentence" && _ye.children.length > 0 && t(_ye.children).type === "word" && !t(_ye.children).hasTrailingPunctuation || Ce && Ce.type === "sentence" && Ce.children.length > 0 && Ce.children[0].type === "word" && !Ce.children[0].hasLeadingPunctuation || te(ce, "emphasis") ? "*" : "_";
                  }
                  return [_ve6, ue(ce, pe, de), _ve6];
                }
              case "strong":
                return ["**", ue(ce, pe, de), "**"];
              case "delete":
                return ["~~", ue(ce, pe, de), "~~"];
              case "inlineCode":
                {
                  var _ve7 = s(ae.value, "`"),
                    _K3 = "`".repeat(_ve7 || 1),
                    _he3 = _ve7 && !/^\s/.test(ae.value) ? " " : "";
                  return [_K3, _he3, ae.value, _he3, _K3];
                }
              case "wikiLink":
                {
                  var _ve8 = "";
                  return pe.proseWrap === "preserve" ? _ve8 = ae.value : _ve8 = ae.value.replace(/[\t\n]+/g, " "), ["[[", _ve8, "]]"];
                }
              case "link":
                switch (pe.originalText[ae.position.start.offset]) {
                  case "<":
                    {
                      var _ve9 = "mailto:",
                        _K4 = ae.url.startsWith(_ve9) && pe.originalText.slice(ae.position.start.offset + 1, ae.position.start.offset + 1 + _ve9.length) !== _ve9 ? ae.url.slice(_ve9.length) : ae.url;
                      return ["<", _K4, ">"];
                    }
                  case "[":
                    return ["[", ue(ce, pe, de), "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
                  default:
                    return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
                }
              case "image":
                return ["![", ae.alt || "", "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
              case "blockquote":
                return ["> ", w("> ", ue(ce, pe, de))];
              case "heading":
                return ["#".repeat(ae.depth) + " ", ue(ce, pe, de)];
              case "code":
                {
                  if (ae.isIndented) {
                    var _he4 = " ".repeat(4);
                    return w(_he4, [_he4].concat(_toConsumableArray(I(ae.value, d))));
                  }
                  var _ve10 = pe.__inJsTemplate ? "~" : "`",
                    _K5 = _ve10.repeat(Math.max(3, a(ae.value, _ve10) + 1));
                  return [_K5, ae.lang || "", ae.meta ? " " + ae.meta : "", d].concat(_toConsumableArray(I(E(ae, pe.originalText), d)), [d, _K5]);
                }
              case "html":
                {
                  var _ve11 = ce.getParentNode(),
                    _K6 = _ve11.type === "root" && t(_ve11.children) === ae ? ae.value.trimEnd() : ae.value,
                    _he5 = /^<!\x2D\x2D[\s\S]*\x2D\x2D>$/.test(_K6);
                  return I(_K6, _he5 ? d : m(v));
                }
              case "list":
                {
                  var _ve12 = R(ae, ce.getParentNode()),
                    _K7 = y(ae, pe);
                  return ue(ce, pe, de, {
                    processor: function processor(he, ye) {
                      var Ce = Fe(),
                        Ie = he.getValue();
                      if (Ie.children.length === 2 && Ie.children[1].type === "html" && Ie.children[0].position.start.column !== Ie.children[1].position.start.column) return [Ce, Y(he, pe, de, Ce)];
                      return [Ce, w(" ".repeat(Ce.length), Y(he, pe, de, Ce))];
                      function Fe() {
                        var me = ae.ordered ? (ye === 0 ? ae.start : _K7 ? 1 : ae.start + ye) + (_ve12 % 2 === 0 ? ". " : ") ") : _ve12 % 2 === 0 ? "- " : "* ";
                        return ae.isAligned || ae.hasIndentedCodeblock ? H(me, pe) : me;
                      }
                    }
                  });
                }
              case "thematicBreak":
                {
                  var _ve13 = ee(ce, "list");
                  return _ve13 === -1 ? "---" : R(ce.getParentNode(_ve13), ce.getParentNode(_ve13 + 1)) % 2 === 0 ? "***" : "---";
                }
              case "linkReference":
                return ["[", ue(ce, pe, de), "]", ae.referenceType === "full" ? ["[", ae.identifier, "]"] : ae.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ae.referenceType) {
                  case "full":
                    return ["![", ae.alt || "", "][", ae.identifier, "]"];
                  default:
                    return ["![", ae.alt, "]", ae.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition":
                {
                  var _ve14 = pe.proseWrap === "always" ? c : " ";
                  return A(["[", ae.identifier, "]:", T([_ve14, ge(ae.url), ae.title === null ? "" : [_ve14, Ae(ae.title, pe, !1)]])]);
                }
              case "footnote":
                return ["[^", ue(ce, pe, de), "]"];
              case "footnoteReference":
                return ["[^", ae.identifier, "]"];
              case "footnoteDefinition":
                {
                  var _ve15 = ce.getParentNode().children[ce.getName() + 1],
                    _K8 = ae.children.length === 1 && ae.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ae.children[0].position.start.line === ae.children[0].position.end.line);
                  return ["[^", ae.identifier, "]: ", _K8 ? ue(ce, pe, de) : A([w(" ".repeat(4), ue(ce, pe, de, {
                    processor: function processor(he, ye) {
                      return ye === 0 ? A([p, de()]) : de();
                    }
                  })), _ve15 && _ve15.type === "footnoteDefinition" ? p : ""])];
                }
              case "table":
                return W(ce, pe, de);
              case "tableCell":
                return ue(ce, pe, de);
              case "break":
                return /\s/.test(pe.originalText[ae.position.start.offset]) ? ["  ", m(v)] : ["\\", d];
              case "liquidNode":
                return I(ae.value, d);
              case "importExport":
                return [ae.value, d];
              case "esComment":
                return ["{/* ", ae.value, " */}"];
              case "jsx":
                return ae.value;
              case "math":
                return ["$$", d, ae.value ? [].concat(_toConsumableArray(I(ae.value, d)), [d]) : "", "$$"];
              case "inlineMath":
                return pe.originalText.slice(D(ae), g(ae));
              case "tableRow":
              case "listItem":
              default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(ae.type)));
            }
          }
          function Y(ce, pe, de, ae) {
            var ve = ce.getValue(),
              K = ve.checked === null ? "" : ve.checked ? "[x] " : "[ ] ";
            return [K, ue(ce, pe, de, {
              processor: function processor(he, ye) {
                if (ye === 0 && he.getValue().type !== "list") return w(" ".repeat(K.length), de());
                var Ce = " ".repeat(Ne(pe.tabWidth - ae.length, 0, 3));
                return [Ce, w(Ce, de())];
              }
            })];
          }
          function H(ce, pe) {
            var de = ae();
            return ce + " ".repeat(de >= 4 ? 0 : de);
            function ae() {
              var ve = ce.length % pe.tabWidth;
              return ve === 0 ? 0 : pe.tabWidth - ve;
            }
          }
          function R(ce, pe) {
            return Q(ce, pe, function (de) {
              return de.ordered === ce.ordered;
            });
          }
          function Q(ce, pe, de) {
            var ae = -1;
            var _iterator47 = _createForOfIteratorHelper(pe.children),
              _step47;
            try {
              for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
                var ve = _step47.value;
                if (ve.type === ce.type && de(ve) ? ae++ : ae = -1, ve === ce) return ae;
              }
            } catch (err) {
              _iterator47.e(err);
            } finally {
              _iterator47.f();
            }
          }
          function ee(ce, pe) {
            var de = Array.isArray(pe) ? pe : [pe],
              ae = -1,
              ve;
            for (; ve = ce.getParentNode(++ae);) {
              if (de.includes(ve.type)) return ae;
            }
            return -1;
          }
          function te(ce, pe) {
            var de = ee(ce, pe);
            return de === -1 ? null : ce.getParentNode(de);
          }
          function oe(ce, pe, de) {
            if (de.proseWrap === "preserve" && pe === "\n") return d;
            var ae = de.proseWrap === "always" && !te(ce, $);
            return pe !== "" ? ae ? c : " " : ae ? p : "";
          }
          function W(ce, pe, de) {
            var ae = ce.getValue(),
              ve = [],
              K = ce.map(function (me) {
                return me.map(function (_, J) {
                  var ne = k(de(), pe).formatted,
                    Ee = r(ne);
                  return ve[J] = Math.max(ve[J] || 3, Ee), {
                    text: ne,
                    width: Ee
                  };
                }, "children");
              }, "children"),
              he = Ce(!1);
            if (pe.proseWrap !== "never") return [i, he];
            var ye = Ce(!0);
            return [i, A(f(ye, he))];
            function Ce(me) {
              var _ = [Fe(K[0], me), Ie(me)];
              return K.length > 1 && _.push(o(S, K.slice(1).map(function (J) {
                return Fe(J, me);
              }))), o(S, _);
            }
            function Ie(me) {
              var _ = ve.map(function (J, ne) {
                var Ee = ae.align[ne],
                  We = Ee === "center" || Ee === "left" ? ":" : "-",
                  Be = Ee === "center" || Ee === "right" ? ":" : "-",
                  Pe = me ? "-" : "-".repeat(J - 2);
                return "".concat(We).concat(Pe).concat(Be);
              });
              return "| ".concat(_.join(" | "), " |");
            }
            function Fe(me, _) {
              var J = me.map(function (ne, Ee) {
                var We = ne.text,
                  Be = ne.width;
                if (_) return We;
                var Pe = ve[Ee] - Be,
                  Se = ae.align[Ee],
                  Qe = 0;
                Se === "right" ? Qe = Pe : Se === "center" && (Qe = Math.floor(Pe / 2));
                var xe = Pe - Qe;
                return "".concat(" ".repeat(Qe)).concat(We).concat(" ".repeat(xe));
              });
              return "| ".concat(J.join(" | "), " |");
            }
          }
          function X(ce, pe, de) {
            var ae = [],
              ve = null,
              _ce$getValue = ce.getValue(),
              K = _ce$getValue.children;
            var _iterator48 = _createForOfIteratorHelper(K.entries()),
              _step48;
            try {
              for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
                var _step48$value = _slicedToArray(_step48.value, 2),
                  he = _step48$value[0],
                  ye = _step48$value[1];
                switch (ie(ye)) {
                  case "start":
                    ve === null && (ve = {
                      index: he,
                      offset: ye.position.end.offset
                    });
                    break;
                  case "end":
                    ve !== null && (ae.push({
                      start: ve,
                      end: {
                        index: he,
                        offset: ye.position.start.offset
                      }
                    }), ve = null);
                    break;
                  default:
                    break;
                }
              }
            } catch (err) {
              _iterator48.e(err);
            } finally {
              _iterator48.f();
            }
            return ue(ce, pe, de, {
              processor: function processor(he, ye) {
                if (ae.length > 0) {
                  var Ce = ae[0];
                  if (ye === Ce.start.index) return [K[Ce.start.index].value, pe.originalText.slice(Ce.start.offset, Ce.end.offset), K[Ce.end.index].value];
                  if (Ce.start.index < ye && ye < Ce.end.index) return !1;
                  if (ye === Ce.end.index) return ae.shift(), !1;
                }
                return de();
              }
            });
          }
          function ue(ce, pe, de) {
            var ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
              ve = ae.postprocessor,
              K = ae.processor || function () {
                return de();
              },
              he = ce.getValue(),
              ye = [],
              Ce;
            return ce.each(function (Ie, Fe) {
              var me = Ie.getValue(),
                _ = K(Ie, Fe);
              if (_ !== !1) {
                var J = {
                  parts: ye,
                  prevNode: Ce,
                  parentNode: he,
                  options: pe
                };
                G(me, J) && (ye.push(d), Ce && j.has(Ce.type) || (z(me, J) || U(me, J)) && ye.push(d), U(me, J) && ye.push(d)), ye.push(_), Ce = me;
              }
            }, "children"), ve ? ve(ye) : ye;
          }
          function De(ce) {
            var pe = ce;
            for (; u(pe.children);) {
              pe = t(pe.children);
            }
            return pe;
          }
          function ie(ce) {
            var pe;
            if (ce.type === "html") pe = ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);else {
              var de;
              ce.type === "esComment" ? de = ce : ce.type === "paragraph" && ce.children.length === 1 && ce.children[0].type === "esComment" && (de = ce.children[0]), de && (pe = de.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return pe ? pe[1] || "next" : !1;
          }
          function G(ce, pe) {
            var de = pe.parts.length === 0,
              ae = b.includes(ce.type),
              ve = ce.type === "html" && L.includes(pe.parentNode.type);
            return !de && !ae && !ve;
          }
          function z(ce, pe) {
            var de, ae, ve;
            var he = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type),
              ye = pe.parentNode.type === "listItem" && !pe.parentNode.loose,
              Ce = ((de = pe.prevNode) === null || de === void 0 ? void 0 : de.type) === "listItem" && pe.prevNode.loose,
              Ie = ie(pe.prevNode) === "next",
              Fe = ce.type === "html" && ((ae = pe.prevNode) === null || ae === void 0 ? void 0 : ae.type) === "html" && pe.prevNode.position.end.line + 1 === ce.position.start.line,
              me = ce.type === "html" && pe.parentNode.type === "listItem" && ((ve = pe.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "paragraph" && pe.prevNode.position.end.line + 1 === ce.position.start.line;
            return Ce || !(he || ye || Ie || Fe || me);
          }
          function U(ce, pe) {
            var de = pe.prevNode && pe.prevNode.type === "list",
              ae = ce.type === "code" && ce.isIndented;
            return de && ae;
          }
          function le(ce) {
            var pe = te(ce, ["linkReference", "imageReference"]);
            return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
          }
          function ge(ce) {
            var pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
              de = [" "].concat(_toConsumableArray(Array.isArray(pe) ? pe : [pe]));
            return new RegExp(de.map(function (ae) {
              return "\\".concat(ae);
            }).join("|")).test(ce) ? "<".concat(ce, ">") : ce;
          }
          function Ae(ce, pe) {
            var de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            if (!ce) return "";
            if (de) return " " + Ae(ce, pe, !1);
            if (ce = ce.replace(/\\(["')])/g, "$1"), ce.includes('"') && ce.includes("'") && !ce.includes(")")) return "(".concat(ce, ")");
            var ae = ce.split("'").length - 1,
              ve = ce.split('"').length - 1,
              K = ae > ve ? '"' : ve > ae || pe.singleQuote ? "'" : '"';
            return ce = ce.replace(/\\/, "\\\\"), ce = ce.replace(new RegExp("(".concat(K, ")"), "g"), "\\$1"), "".concat(K).concat(ce).concat(K);
          }
          function Ne(ce, pe, de) {
            return ce < pe ? pe : ce > de ? de : ce;
          }
          function ke(ce) {
            var pe = Number(ce.getName());
            if (pe === 0) return !1;
            var de = ce.getParentNode().children[pe - 1];
            return ie(de) === "next";
          }
          n.exports = {
            preprocess: F,
            print: q,
            embed: P,
            massageAstNode: l,
            hasPrettierIgnore: ke,
            insertPragma: C
          };
        }
      }),
      Gd = Z({
        "src/language-markdown/options.js": function srcLanguageMarkdownOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot();
          n.exports = {
            proseWrap: t.proseWrap,
            singleQuote: t.singleQuote
          };
        }
      }),
      Jd = Z({
        "src/language-markdown/parsers.js": function srcLanguageMarkdownParsersJs() {
          re();
        }
      }),
      da = Z({
        "node_modules/linguist-languages/data/Markdown.json": function node_modulesLinguistLanguagesDataMarkdownJson(e, n) {
          n.exports = {
            name: "Markdown",
            type: "prose",
            color: "#083fa1",
            aliases: ["pandoc"],
            aceMode: "markdown",
            codemirrorMode: "gfm",
            codemirrorMimeType: "text/x-gfm",
            wrap: !0,
            extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"],
            filenames: ["contents.lr"],
            tmScope: "source.gfm",
            languageId: 222
          };
        }
      }),
      Ud = Z({
        "src/language-markdown/index.js": function srcLanguageMarkdownIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = Hd(),
            a = Gd(),
            r = Jd(),
            u = [t(da(), function (o) {
              return {
                since: "1.8.0",
                parsers: ["markdown"],
                vscodeLanguageIds: ["markdown"],
                filenames: [].concat(_toConsumableArray(o.filenames), ["README"]),
                extensions: o.extensions.filter(function (c) {
                  return c !== ".mdx";
                })
              };
            }), t(da(), function () {
              return {
                name: "MDX",
                since: "1.15.0",
                parsers: ["mdx"],
                vscodeLanguageIds: ["mdx"],
                filenames: [],
                extensions: [".mdx"]
              };
            })],
            i = {
              mdast: s
            };
          n.exports = {
            languages: u,
            options: a,
            printers: i,
            parsers: r
          };
        }
      }),
      zd = Z({
        "src/language-html/clean.js": function srcLanguageHtmlCleanJs(e, n) {
          "use strict";

          re();
          var _Ue40 = Ue(),
            t = _Ue40.isFrontMatterNode,
            s = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(r, u) {
            if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml") return null;
            r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, n.exports = a;
        }
      }),
      Xd = Z({
        "src/language-html/constants.evaluate.js": function srcLanguageHtmlConstantsEvaluateJs(e, n) {
          n.exports = {
            CSS_DISPLAY_TAGS: {
              area: "none",
              base: "none",
              basefont: "none",
              datalist: "none",
              head: "none",
              link: "none",
              meta: "none",
              noembed: "none",
              noframes: "none",
              param: "block",
              rp: "none",
              script: "block",
              source: "block",
              style: "none",
              template: "inline",
              track: "block",
              title: "none",
              html: "block",
              body: "block",
              address: "block",
              blockquote: "block",
              center: "block",
              div: "block",
              figure: "block",
              figcaption: "block",
              footer: "block",
              form: "block",
              header: "block",
              hr: "block",
              legend: "block",
              listing: "block",
              main: "block",
              p: "block",
              plaintext: "block",
              pre: "block",
              xmp: "block",
              slot: "contents",
              ruby: "ruby",
              rt: "ruby-text",
              article: "block",
              aside: "block",
              h1: "block",
              h2: "block",
              h3: "block",
              h4: "block",
              h5: "block",
              h6: "block",
              hgroup: "block",
              nav: "block",
              section: "block",
              dir: "block",
              dd: "block",
              dl: "block",
              dt: "block",
              ol: "block",
              ul: "block",
              li: "list-item",
              table: "table",
              caption: "table-caption",
              colgroup: "table-column-group",
              col: "table-column",
              thead: "table-header-group",
              tbody: "table-row-group",
              tfoot: "table-footer-group",
              tr: "table-row",
              td: "table-cell",
              th: "table-cell",
              fieldset: "block",
              button: "inline-block",
              details: "block",
              summary: "block",
              dialog: "block",
              meter: "inline-block",
              progress: "inline-block",
              object: "inline-block",
              video: "inline-block",
              audio: "inline-block",
              select: "inline-block",
              option: "block",
              optgroup: "block"
            },
            CSS_DISPLAY_DEFAULT: "inline",
            CSS_WHITE_SPACE_TAGS: {
              listing: "pre",
              plaintext: "pre",
              pre: "pre",
              xmp: "pre",
              nobr: "nowrap",
              table: "initial",
              textarea: "pre-wrap"
            },
            CSS_WHITE_SPACE_DEFAULT: "normal"
          };
        }
      }),
      Kd = Z({
        "src/language-html/utils/is-unknown-namespace.js": function srcLanguageHtmlUtilsIsUnknownNamespaceJs(e, n) {
          "use strict";

          re();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          n.exports = t;
        }
      }),
      qt = Z({
        "src/language-html/utils/index.js": function srcLanguageHtmlUtilsIndexJs(e, n) {
          "use strict";

          re();
          var _Ue41 = Ue(),
            t = _Ue41.inferParserByLanguage,
            s = _Ue41.isFrontMatterNode,
            _Oe45 = Oe(),
            _Oe45$builders = _Oe45.builders,
            a = _Oe45$builders.line,
            r = _Oe45$builders.hardline,
            u = _Oe45$builders.join,
            _Oe45$utils = _Oe45.utils,
            i = _Oe45$utils.getDocParts,
            o = _Oe45$utils.replaceTextEndOfLine,
            _Xd = Xd(),
            c = _Xd.CSS_DISPLAY_TAGS,
            v = _Xd.CSS_DISPLAY_DEFAULT,
            m = _Xd.CSS_WHITE_SPACE_TAGS,
            d = _Xd.CSS_WHITE_SPACE_DEFAULT,
            p = Kd(),
            f = new Set(["	", "\n", "\f", "\r", " "]),
            h = function h(_) {
              return _.replace(/^[\t\n\f\r ]+/, "");
            },
            w = function w(_) {
              return _.replace(/[\t\n\f\r ]+$/, "");
            },
            T = function T(_) {
              return h(w(_));
            },
            A = function A(_) {
              return _.replace(/^[\t\f\r ]*\n/g, "");
            },
            S = function S(_) {
              return A(w(_));
            },
            B = function B(_) {
              return _.split(/[\t\n\f\r ]+/);
            },
            I = function I(_) {
              return _.match(/^[\t\n\f\r ]*/)[0];
            },
            k = function k(_) {
              var _$match = _.match(/^([\t\n\f\r ]*)([\s\S]*?)([\t\n\f\r ]*)$/),
                _$match2 = _slicedToArray(_$match, 4),
                J = _$match2[1],
                ne = _$match2[2],
                Ee = _$match2[3];
              return {
                leadingWhitespace: J,
                trailingWhitespace: Ee,
                text: ne
              };
            },
            P = function P(_) {
              return /[\t\n\f\r ]/.test(_);
            };
          function C(_, J) {
            return !!(_.type === "ieConditionalComment" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === "ieConditionalComment" && !_.complete || le(_) && _.children.some(function (ne) {
              return ne.type !== "text" && ne.type !== "interpolation";
            }) || ye(_, J) && !l(_) && _.type !== "interpolation");
          }
          function D(_) {
            return _.type === "attribute" || !_.parent || !_.prev ? !1 : g(_.prev);
          }
          function g(_) {
            return _.type === "comment" && _.value.trim() === "prettier-ignore";
          }
          function F(_) {
            return _.type === "text" || _.type === "comment";
          }
          function l(_) {
            return _.type === "element" && (_.fullName === "script" || _.fullName === "style" || _.fullName === "svg:style" || p(_) && (_.name === "script" || _.name === "style"));
          }
          function E(_) {
            return _.children && !l(_);
          }
          function y(_) {
            return l(_) || _.type === "interpolation" || N(_);
          }
          function N(_) {
            return ke(_).startsWith("pre");
          }
          function x(_, J) {
            var ne = Ee();
            if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf) return _.type === "interpolation";
            return ne;
            function Ee() {
              return s(_) ? !1 : (_.type === "text" || _.type === "interpolation") && _.prev && (_.prev.type === "text" || _.prev.type === "interpolation") ? !0 : !_.parent || _.parent.cssDisplay === "none" ? !1 : le(_.parent) ? !0 : !(!_.prev && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !De(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));
            }
          }
          function b(_, J) {
            return s(_) ? !1 : (_.type === "text" || _.type === "interpolation") && _.next && (_.next.type === "text" || _.next.type === "interpolation") ? !0 : !_.parent || _.parent.cssDisplay === "none" ? !1 : le(_.parent) ? !0 : !(!_.next && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));
          }
          function L(_) {
            return U(_.cssDisplay) && !l(_);
          }
          function M(_) {
            return s(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;
          }
          function j(_) {
            return $(_) || _.type === "element" && _.children.length > 0 && (["body", "script", "style"].includes(_.name) || _.children.some(function (J) {
              return te(J);
            })) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== "text" && H(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));
          }
          function $(_) {
            return _.type === "element" && _.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(_.name) || _.cssDisplay.startsWith("table") && _.cssDisplay !== "table-cell");
          }
          function V(_) {
            return Q(_) || _.prev && q(_.prev) || Y(_);
          }
          function q(_) {
            return Q(_) || _.type === "element" && _.fullName === "br" || Y(_);
          }
          function Y(_) {
            return H(_) && R(_);
          }
          function H(_) {
            return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === "root" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);
          }
          function R(_) {
            return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === "root" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);
          }
          function Q(_) {
            switch (_.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return !0;
              case "element":
                return ["script", "select"].includes(_.name);
            }
            return !1;
          }
          function ee(_) {
            return _.lastChild ? ee(_.lastChild) : _;
          }
          function te(_) {
            return _.children && _.children.some(function (J) {
              return J.type !== "text";
            });
          }
          function oe(_) {
            var _$attrMap = _.attrMap,
              J = _$attrMap.type,
              ne = _$attrMap.lang;
            if (J === "module" || J === "text/javascript" || J === "text/babel" || J === "application/javascript" || ne === "jsx") return "babel";
            if (J === "application/x-typescript" || ne === "ts" || ne === "tsx") return "typescript";
            if (J === "text/markdown") return "markdown";
            if (J === "text/html") return "html";
            if (J && (J.endsWith("json") || J.endsWith("importmap")) || J === "speculationrules") return "json";
            if (J === "text/x-handlebars-template") return "glimmer";
          }
          function W(_, J) {
            var ne = _.attrMap.lang;
            if (!ne || ne === "postcss" || ne === "css") return "css";
            if (ne === "scss") return "scss";
            if (ne === "less") return "less";
            if (ne === "stylus") return t("stylus", J);
          }
          function X(_, J) {
            if (_.name === "script" && !_.attrMap.src) return !_.attrMap.lang && !_.attrMap.type ? "babel" : oe(_);
            if (_.name === "style") return W(_, J);
            if (J && ye(_, J)) return oe(_) || !("src" in _.attrMap) && t(_.attrMap.lang, J);
          }
          function ue(_) {
            return _ === "block" || _ === "list-item" || _.startsWith("table");
          }
          function De(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function ie(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function G(_) {
            return !ue(_);
          }
          function z(_) {
            return !ue(_);
          }
          function U(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function le(_) {
            return ke(_).startsWith("pre");
          }
          function ge(_, J) {
            var ne = 0;
            for (var Ee = _.stack.length - 1; Ee >= 0; Ee--) {
              var We = _.stack[Ee];
              We && _typeof(We) == "object" && !Array.isArray(We) && J(We) && ne++;
            }
            return ne;
          }
          function Ae(_, J) {
            var ne = _;
            for (; ne;) {
              if (J(ne)) return !0;
              ne = ne.parent;
            }
            return !1;
          }
          function Ne(_, J) {
            if (_.prev && _.prev.type === "comment") {
              var Ee = _.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (Ee) return Ee[1];
            }
            var ne = !1;
            if (_.type === "element" && _.namespace === "svg") if (Ae(_, function (Ee) {
              return Ee.fullName === "svg:foreignObject";
            })) ne = !0;else return _.name === "svg" ? "inline-block" : "block";
            switch (J.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return J.parser === "vue" && _.parent && _.parent.type === "root" ? "block" : _.type === "element" && (!_.namespace || ne || p(_)) && c[_.name] || v;
            }
          }
          function ke(_) {
            return _.type === "element" && (!_.namespace || p(_)) && m[_.name] || d;
          }
          function ce(_) {
            var J = Number.POSITIVE_INFINITY;
            var _iterator49 = _createForOfIteratorHelper(_.split("\n")),
              _step49;
            try {
              for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
                var ne = _step49.value;
                if (ne.length === 0) continue;
                if (!f.has(ne[0])) return 0;
                var Ee = I(ne).length;
                ne.length !== Ee && Ee < J && (J = Ee);
              }
            } catch (err) {
              _iterator49.e(err);
            } finally {
              _iterator49.f();
            }
            return J === Number.POSITIVE_INFINITY ? 0 : J;
          }
          function pe(_) {
            var J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);
            return J === 0 ? _ : _.split("\n").map(function (ne) {
              return ne.slice(J);
            }).join("\n");
          }
          function de(_, J) {
            var ne = 0;
            for (var Ee = 0; Ee < _.length; Ee++) {
              _[Ee] === J && ne++;
            }
            return ne;
          }
          function ae(_) {
            return _.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var ve = new Set(["template", "style", "script"]);
          function K(_, J) {
            return he(_, J) && !ve.has(_.fullName);
          }
          function he(_, J) {
            return J.parser === "vue" && _.type === "element" && _.parent.type === "root" && _.fullName.toLowerCase() !== "html";
          }
          function ye(_, J) {
            return he(_, J) && (K(_, J) || _.attrMap.lang && _.attrMap.lang !== "html");
          }
          function Ce(_) {
            var J = _.fullName;
            return J.charAt(0) === "#" || J === "slot-scope" || J === "v-slot" || J.startsWith("v-slot:");
          }
          function Ie(_, J) {
            var ne = _.parent;
            if (!he(ne, J)) return !1;
            var Ee = ne.fullName,
              We = _.fullName;
            return Ee === "script" && We === "setup" || Ee === "style" && We === "vars";
          }
          function Fe(_) {
            var J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;
            return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J) : o(pe(S(J)), r) : i(u(a, B(J)));
          }
          function me(_, J) {
            return he(_, J) && _.name === "script";
          }
          n.exports = {
            htmlTrim: T,
            htmlTrimPreserveIndentation: S,
            hasHtmlWhitespace: P,
            getLeadingAndTrailingHtmlWhitespace: k,
            canHaveInterpolation: E,
            countChars: de,
            countParents: ge,
            dedentString: pe,
            forceBreakChildren: $,
            forceBreakContent: j,
            forceNextEmptyLine: M,
            getLastDescendant: ee,
            getNodeCssStyleDisplay: Ne,
            getNodeCssStyleWhiteSpace: ke,
            hasPrettierIgnore: D,
            inferScriptParser: X,
            isVueCustomBlock: K,
            isVueNonHtmlBlock: ye,
            isVueScriptTag: me,
            isVueSlotAttribute: Ce,
            isVueSfcBindingsAttribute: Ie,
            isVueSfcBlock: he,
            isDanglingSpaceSensitiveNode: L,
            isIndentationSensitiveNode: N,
            isLeadingSpaceSensitiveNode: x,
            isPreLikeNode: le,
            isScriptLikeTag: l,
            isTextLikeNode: F,
            isTrailingSpaceSensitiveNode: b,
            isWhitespaceSensitiveNode: y,
            isUnknownNamespace: p,
            preferHardlineAsLeadingSpaces: V,
            preferHardlineAsTrailingSpaces: q,
            shouldPreserveContent: C,
            unescapeQuoteEntities: ae,
            getTextValueParts: Fe
          };
        }
      }),
      Yd = Z({
        "node_modules/angular-html-parser/lib/compiler/src/chars.js": function node_modulesAngularHtmlParserLibCompilerSrcCharsJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function n(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          e.isWhitespace = n;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          e.isDigit = t;
          function s(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          e.isAsciiLetter = s;
          function a(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          e.isAsciiHexDigit = a;
          function r(i) {
            return i === e.$LF || i === e.$CR;
          }
          e.isNewLine = r;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          e.isOctalDigit = u;
        }
      }),
      Qd = Z({
        "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js": function node_modulesAngularHtmlParserLibCompilerSrcAotStatic_symbolJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = /*#__PURE__*/function () {
            function n(s, a, r) {
              _classCallCheck(this, n);
              this.filePath = s, this.name = a, this.members = r;
            }
            _createClass(n, [{
              key: "assertNoMembers",
              value: function assertNoMembers() {
                if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
              }
            }]);
            return n;
          }();
          e.StaticSymbol = n;
          var t = /*#__PURE__*/function () {
            function t() {
              _classCallCheck(this, t);
              this.cache = new Map();
            }
            _createClass(t, [{
              key: "get",
              value: function get(s, a, r) {
                r = r || [];
                var u = r.length ? ".".concat(r.join(".")) : "",
                  i = '"'.concat(s, '".').concat(a).concat(u),
                  o = this.cache.get(i);
                return o || (o = new n(s, a, r), this.cache.set(i, o)), o;
              }
            }]);
            return t;
          }();
          e.StaticSymbolCache = t;
        }
      }),
      Zd = Z({
        "node_modules/angular-html-parser/lib/compiler/src/util.js": function node_modulesAngularHtmlParserLibCompilerSrcUtilJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = /-+([a-z0-9])/g;
          function t(l) {
            return l.replace(n, function () {
              for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++) {
                y[N] = arguments[N];
              }
              return y[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s(l, E) {
            return r(l, ":", E);
          }
          e.splitAtColon = s;
          function a(l, E) {
            return r(l, ".", E);
          }
          e.splitAtPeriod = a;
          function r(l, E, y) {
            var N = l.indexOf(E);
            return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];
          }
          function u(l, E, y) {
            return Array.isArray(l) ? E.visitArray(l, y) : A(l) ? E.visitStringMap(l, y) : l == null || typeof l == "string" || typeof l == "number" || typeof l == "boolean" ? E.visitPrimitive(l, y) : E.visitOther(l, y);
          }
          e.visitValue = u;
          function i(l) {
            return l != null;
          }
          e.isDefined = i;
          function o(l) {
            return l === void 0 ? null : l;
          }
          e.noUndefined = o;
          var c = /*#__PURE__*/function () {
            function c() {
              _classCallCheck(this, c);
            }
            _createClass(c, [{
              key: "visitArray",
              value: function visitArray(l, E) {
                var _this8 = this;
                return l.map(function (y) {
                  return u(y, _this8, E);
                });
              }
            }, {
              key: "visitStringMap",
              value: function visitStringMap(l, E) {
                var _this9 = this;
                var y = {};
                return Object.keys(l).forEach(function (N) {
                  y[N] = u(l[N], _this9, E);
                }), y;
              }
            }, {
              key: "visitPrimitive",
              value: function visitPrimitive(l, E) {
                return l;
              }
            }, {
              key: "visitOther",
              value: function visitOther(l, E) {
                return l;
              }
            }]);
            return c;
          }();
          e.ValueTransformer = c, e.SyncAsync = {
            assertSync: function assertSync(l) {
              if (k(l)) throw new Error("Illegal state: value cannot be a promise");
              return l;
            },
            then: function then(l, E) {
              return k(l) ? l.then(E) : E(l);
            },
            all: function all(l) {
              return l.some(k) ? Promise.all(l) : l;
            }
          };
          function v(l) {
            throw new Error("Internal Error: ".concat(l));
          }
          e.error = v;
          function m(l, E) {
            var y = Error(l);
            return y[d] = !0, E && (y[p] = E), y;
          }
          e.syntaxError = m;
          var d = "ngSyntaxError",
            p = "ngParseErrors";
          function f(l) {
            return l[d];
          }
          e.isSyntaxError = f;
          function h(l) {
            return l[p] || [];
          }
          e.getParseErrors = h;
          function w(l) {
            return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = w;
          var T = Object.getPrototypeOf({});
          function A(l) {
            return _typeof(l) == "object" && l !== null && Object.getPrototypeOf(l) === T;
          }
          function S(l) {
            var E = "";
            for (var y = 0; y < l.length; y++) {
              var N = l.charCodeAt(y);
              if (N >= 55296 && N <= 56319 && l.length > y + 1) {
                var x = l.charCodeAt(y + 1);
                x >= 56320 && x <= 57343 && (y++, N = (N - 55296 << 10) + x - 56320 + 65536);
              }
              N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));
            }
            return E;
          }
          e.utf8Encode = S;
          function B(l) {
            if (typeof l == "string") return l;
            if (l instanceof Array) return "[" + l.map(B).join(", ") + "]";
            if (l == null) return "" + l;
            if (l.overriddenName) return "".concat(l.overriddenName);
            if (l.name) return "".concat(l.name);
            if (!l.toString) return "object";
            var E = l.toString();
            if (E == null) return "" + E;
            var y = E.indexOf("\n");
            return y === -1 ? E : E.substring(0, y);
          }
          e.stringify = B;
          function I(l) {
            return typeof l == "function" && l.hasOwnProperty("__forward_ref__") ? l() : l;
          }
          e.resolveForwardRef = I;
          function k(l) {
            return !!l && typeof l.then == "function";
          }
          e.isPromise = k;
          var P = /*#__PURE__*/_createClass(function P(l) {
            _classCallCheck(this, P);
            this.full = l;
            var E = l.split(".");
            this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
          });
          e.Version = P;
          var C = (typeof window === "undefined" ? "undefined" : _typeof(window)) < "u" && window,
            D = (typeof self === "undefined" ? "undefined" : _typeof(self)) < "u" && (typeof WorkerGlobalScope === "undefined" ? "undefined" : _typeof(WorkerGlobalScope)) < "u" && self instanceof WorkerGlobalScope && self,
            g = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) < "u" && globalThis,
            F = g || C || D;
          e.global = F;
        }
      }),
      eg = Z({
        "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js": function node_modulesAngularHtmlParserLibCompilerSrcCompile_metadataJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = Qd(),
            t = Zd(),
            s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(y) {
            return y.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a;
          var r = 0;
          function u(y) {
            if (!y || !y.reference) return null;
            var N = y.reference;
            if (N instanceof n.StaticSymbol) return N.name;
            if (N.__anonymousType) return N.__anonymousType;
            var x = t.stringify(N);
            return x.indexOf("(") >= 0 ? (x = "anonymous_".concat(r++), N.__anonymousType = x) : x = a(x), x;
          }
          e.identifierName = u;
          function i(y) {
            var N = y.reference;
            return N instanceof n.StaticSymbol ? N.filePath : "./".concat(t.stringify(N));
          }
          e.identifierModuleUrl = i;
          function o(y, N) {
            return "View_".concat(u({
              reference: y
            }), "_").concat(N);
          }
          e.viewClassName = o;
          function c(y) {
            return "RenderType_".concat(u({
              reference: y
            }));
          }
          e.rendererTypeName = c;
          function v(y) {
            return "HostView_".concat(u({
              reference: y
            }));
          }
          e.hostViewClassName = v;
          function m(y) {
            return "".concat(u({
              reference: y
            }), "NgFactory");
          }
          e.componentFactoryName = m;
          var d;
          (function (y) {
            y[y.Pipe = 0] = "Pipe", y[y.Directive = 1] = "Directive", y[y.NgModule = 2] = "NgModule", y[y.Injectable = 3] = "Injectable";
          })(d = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function p(y) {
            return y.value != null ? a(y.value) : u(y.identifier);
          }
          e.tokenName = p;
          function f(y) {
            return y.identifier != null ? y.identifier.reference : y.value;
          }
          e.tokenReference = f;
          var h = /*#__PURE__*/_createClass(function h() {
            _classCallCheck(this, h);
            var _ref15 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
              y = _ref15.moduleUrl,
              N = _ref15.styles,
              x = _ref15.styleUrls;
            this.moduleUrl = y || null, this.styles = k(N), this.styleUrls = k(x);
          });
          e.CompileStylesheetMetadata = h;
          var w = /*#__PURE__*/function () {
            function w(y) {
              _classCallCheck(this, w);
              var N = y.encapsulation,
                x = y.template,
                b = y.templateUrl,
                L = y.htmlAst,
                M = y.styles,
                j = y.styleUrls,
                $ = y.externalStylesheets,
                V = y.animations,
                q = y.ngContentSelectors,
                Y = y.interpolation,
                H = y.isInline,
                R = y.preserveWhitespaces;
              if (this.encapsulation = N, this.template = x, this.templateUrl = b, this.htmlAst = L, this.styles = k(M), this.styleUrls = k(j), this.externalStylesheets = k($), this.animations = V ? C(V) : [], this.ngContentSelectors = q || [], Y && Y.length != 2) throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Y, this.isInline = H, this.preserveWhitespaces = R;
            }
            _createClass(w, [{
              key: "toSummary",
              value: function toSummary() {
                return {
                  ngContentSelectors: this.ngContentSelectors,
                  encapsulation: this.encapsulation,
                  styles: this.styles,
                  animations: this.animations
                };
              }
            }]);
            return w;
          }();
          e.CompileTemplateMetadata = w;
          var T = /*#__PURE__*/function () {
            function T(y) {
              _classCallCheck(this, T);
              var N = y.isHost,
                x = y.type,
                b = y.isComponent,
                L = y.selector,
                M = y.exportAs,
                j = y.changeDetection,
                $ = y.inputs,
                V = y.outputs,
                q = y.hostListeners,
                Y = y.hostProperties,
                H = y.hostAttributes,
                R = y.providers,
                Q = y.viewProviders,
                ee = y.queries,
                te = y.guards,
                oe = y.viewQueries,
                W = y.entryComponents,
                X = y.template,
                ue = y.componentViewType,
                De = y.rendererType,
                ie = y.componentFactory;
              this.isHost = !!N, this.type = x, this.isComponent = b, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y, this.hostAttributes = H, this.providers = k(R), this.viewProviders = k(Q), this.queries = k(ee), this.guards = te, this.viewQueries = k(oe), this.entryComponents = k(W), this.template = X, this.componentViewType = ue, this.rendererType = De, this.componentFactory = ie;
            }
            _createClass(T, [{
              key: "toSummary",
              value: function toSummary() {
                return {
                  summaryKind: d.Directive,
                  type: this.type,
                  isComponent: this.isComponent,
                  selector: this.selector,
                  exportAs: this.exportAs,
                  inputs: this.inputs,
                  outputs: this.outputs,
                  hostListeners: this.hostListeners,
                  hostProperties: this.hostProperties,
                  hostAttributes: this.hostAttributes,
                  providers: this.providers,
                  viewProviders: this.viewProviders,
                  queries: this.queries,
                  guards: this.guards,
                  viewQueries: this.viewQueries,
                  entryComponents: this.entryComponents,
                  changeDetection: this.changeDetection,
                  template: this.template && this.template.toSummary(),
                  componentViewType: this.componentViewType,
                  rendererType: this.rendererType,
                  componentFactory: this.componentFactory
                };
              }
            }], [{
              key: "create",
              value: function create(y) {
                var N = y.isHost,
                  x = y.type,
                  b = y.isComponent,
                  L = y.selector,
                  M = y.exportAs,
                  j = y.changeDetection,
                  $ = y.inputs,
                  V = y.outputs,
                  q = y.host,
                  Y = y.providers,
                  H = y.viewProviders,
                  R = y.queries,
                  Q = y.guards,
                  ee = y.viewQueries,
                  te = y.entryComponents,
                  oe = y.template,
                  W = y.componentViewType,
                  X = y.rendererType,
                  ue = y.componentFactory,
                  De = {},
                  ie = {},
                  G = {};
                q != null && Object.keys(q).forEach(function (le) {
                  var ge = q[le],
                    Ae = le.match(s);
                  Ae === null ? G[le] = ge : Ae[1] != null ? ie[Ae[1]] = ge : Ae[2] != null && (De[Ae[2]] = ge);
                });
                var z = {};
                $ != null && $.forEach(function (le) {
                  var ge = t.splitAtColon(le, [le, le]);
                  z[ge[0]] = ge[1];
                });
                var U = {};
                return V != null && V.forEach(function (le) {
                  var ge = t.splitAtColon(le, [le, le]);
                  U[ge[0]] = ge[1];
                }), new T({
                  isHost: N,
                  type: x,
                  isComponent: !!b,
                  selector: L,
                  exportAs: M,
                  changeDetection: j,
                  inputs: z,
                  outputs: U,
                  hostListeners: De,
                  hostProperties: ie,
                  hostAttributes: G,
                  providers: Y,
                  viewProviders: H,
                  queries: R,
                  guards: Q,
                  viewQueries: ee,
                  entryComponents: te,
                  template: oe,
                  componentViewType: W,
                  rendererType: X,
                  componentFactory: ue
                });
              }
            }]);
            return T;
          }();
          e.CompileDirectiveMetadata = T;
          var A = /*#__PURE__*/function () {
            function A(y) {
              _classCallCheck(this, A);
              var N = y.type,
                x = y.name,
                b = y.pure;
              this.type = N, this.name = x, this.pure = !!b;
            }
            _createClass(A, [{
              key: "toSummary",
              value: function toSummary() {
                return {
                  summaryKind: d.Pipe,
                  type: this.type,
                  name: this.name,
                  pure: this.pure
                };
              }
            }]);
            return A;
          }();
          e.CompilePipeMetadata = A;
          var S = /*#__PURE__*/_createClass(function S() {
            _classCallCheck(this, S);
          });
          e.CompileShallowModuleMetadata = S;
          var B = /*#__PURE__*/function () {
            function B(y) {
              _classCallCheck(this, B);
              var N = y.type,
                x = y.providers,
                b = y.declaredDirectives,
                L = y.exportedDirectives,
                M = y.declaredPipes,
                j = y.exportedPipes,
                $ = y.entryComponents,
                V = y.bootstrapComponents,
                q = y.importedModules,
                Y = y.exportedModules,
                H = y.schemas,
                R = y.transitiveModule,
                Q = y.id;
              this.type = N || null, this.declaredDirectives = k(b), this.exportedDirectives = k(L), this.declaredPipes = k(M), this.exportedPipes = k(j), this.providers = k(x), this.entryComponents = k($), this.bootstrapComponents = k(V), this.importedModules = k(q), this.exportedModules = k(Y), this.schemas = k(H), this.id = Q || null, this.transitiveModule = R || null;
            }
            _createClass(B, [{
              key: "toSummary",
              value: function toSummary() {
                var y = this.transitiveModule;
                return {
                  summaryKind: d.NgModule,
                  type: this.type,
                  entryComponents: y.entryComponents,
                  providers: y.providers,
                  modules: y.modules,
                  exportedDirectives: y.exportedDirectives,
                  exportedPipes: y.exportedPipes
                };
              }
            }]);
            return B;
          }();
          e.CompileNgModuleMetadata = B;
          var I = /*#__PURE__*/function () {
            function I() {
              _classCallCheck(this, I);
              this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
            }
            _createClass(I, [{
              key: "addProvider",
              value: function addProvider(y, N) {
                this.providers.push({
                  provider: y,
                  module: N
                });
              }
            }, {
              key: "addDirective",
              value: function addDirective(y) {
                this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));
              }
            }, {
              key: "addExportedDirective",
              value: function addExportedDirective(y) {
                this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));
              }
            }, {
              key: "addPipe",
              value: function addPipe(y) {
                this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));
              }
            }, {
              key: "addExportedPipe",
              value: function addExportedPipe(y) {
                this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));
              }
            }, {
              key: "addModule",
              value: function addModule(y) {
                this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));
              }
            }, {
              key: "addEntryComponent",
              value: function addEntryComponent(y) {
                this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));
              }
            }]);
            return I;
          }();
          e.TransitiveCompileNgModuleMetadata = I;
          function k(y) {
            return y || [];
          }
          var P = /*#__PURE__*/_createClass(function P(y, N) {
            _classCallCheck(this, P);
            var x = N.useClass,
              b = N.useValue,
              L = N.useExisting,
              M = N.useFactory,
              j = N.deps,
              $ = N.multi;
            this.token = y, this.useClass = x || null, this.useValue = b, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!$;
          });
          e.ProviderMeta = P;
          function C(y) {
            return y.reduce(function (N, x) {
              var b = Array.isArray(x) ? C(x) : x;
              return N.concat(b);
            }, []);
          }
          e.flatten = C;
          function D(y) {
            return y.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function g(y, N, x) {
            var b;
            return x.isInline ? N.type.reference instanceof n.StaticSymbol ? b = "".concat(N.type.reference.filePath, ".").concat(N.type.reference.name, ".html") : b = "".concat(u(y), "/").concat(u(N.type), ".html") : b = x.templateUrl, N.type.reference instanceof n.StaticSymbol ? b : D(b);
          }
          e.templateSourceUrl = g;
          function F(y, N) {
            var x = y.moduleUrl.split(/\/\\/g),
              b = x[x.length - 1];
            return D("css/".concat(N).concat(b, ".ngstyle.js"));
          }
          e.sharedStylesheetJitUrl = F;
          function l(y) {
            return D("".concat(u(y.type), "/module.ngfactory.js"));
          }
          e.ngModuleJitUrl = l;
          function E(y, N) {
            return D("".concat(u(y), "/").concat(u(N.type), ".ngfactory.js"));
          }
          e.templateJitUrl = E;
        }
      }),
      tg = Z({
        "node_modules/angular-html-parser/lib/compiler/src/parse_util.js": function node_modulesAngularHtmlParserLibCompilerSrcParse_utilJs(e) {
          "use strict";

          re(), Object.defineProperty(e, "__esModule", {
            value: !0
          });
          var n = Yd(),
            t = eg(),
            s = /*#__PURE__*/function () {
              function s(v, m, d, p) {
                _classCallCheck(this, s);
                this.file = v, this.offset = m, this.line = d, this.col = p;
              }
              _createClass(s, [{
                key: "toString",
                value: function toString() {
                  return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
                }
              }, {
                key: "moveBy",
                value: function moveBy(v) {
                  var m = this.file.content,
                    d = m.length,
                    p = this.offset,
                    f = this.line,
                    h = this.col;
                  for (; p > 0 && v < 0;) {
                    if (p--, v++, m.charCodeAt(p) == n.$LF) {
                      f--;
                      var T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                      h = T > 0 ? p - T : p;
                    } else h--;
                  }
                  for (; p < d && v > 0;) {
                    var _w11 = m.charCodeAt(p);
                    p++, v--, _w11 == n.$LF ? (f++, h = 0) : h++;
                  }
                  return new s(this.file, p, f, h);
                }
              }, {
                key: "getContext",
                value: function getContext(v, m) {
                  var d = this.file.content,
                    p = this.offset;
                  if (p != null) {
                    p > d.length - 1 && (p = d.length - 1);
                    var f = p,
                      _h6 = 0,
                      _w12 = 0;
                    for (; _h6 < v && p > 0 && (p--, _h6++, !(d[p] == "\n" && ++_w12 == m));) {
                      ;
                    }
                    for (_h6 = 0, _w12 = 0; _h6 < v && f < d.length - 1 && (f++, _h6++, !(d[f] == "\n" && ++_w12 == m));) {
                      ;
                    }
                    return {
                      before: d.substring(p, this.offset),
                      after: d.substring(this.offset, f + 1)
                    };
                  }
                  return null;
                }
              }]);
              return s;
            }();
          e.ParseLocation = s;
          var a = /*#__PURE__*/_createClass(function a(v, m) {
            _classCallCheck(this, a);
            this.content = v, this.url = m;
          });
          e.ParseSourceFile = a;
          var r = /*#__PURE__*/function () {
            function r(v, m) {
              _classCallCheck(this, r);
              var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = v, this.end = m, this.details = d;
            }
            _createClass(r, [{
              key: "toString",
              value: function toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            }]);
            return r;
          }();
          e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function (v) {
            v[v.WARNING = 0] = "WARNING", v[v.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = /*#__PURE__*/function () {
            function i(v, m) {
              _classCallCheck(this, i);
              var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = v, this.msg = m, this.level = d;
            }
            _createClass(i, [{
              key: "contextualMessage",
              value: function contextualMessage() {
                var v = this.span.start.getContext(100, 3);
                return v ? "".concat(this.msg, ' ("').concat(v.before, "[").concat(u[this.level], " ->]").concat(v.after, '")') : this.msg;
              }
            }, {
              key: "toString",
              value: function toString() {
                var v = this.span.details ? ", ".concat(this.span.details) : "";
                return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(v);
              }
            }]);
            return i;
          }();
          e.ParseError = i;
          function o(v, m) {
            var d = t.identifierModuleUrl(m),
              p = d != null ? "in ".concat(v, " ").concat(t.identifierName(m), " in ").concat(d) : "in ".concat(v, " ").concat(t.identifierName(m)),
              f = new a("", p);
            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.typeSourceSpan = o;
          function c(v, m, d) {
            var p = "in ".concat(v, " ").concat(m, " in ").concat(d),
              f = new a("", p);
            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = c;
        }
      }),
      rg = Z({
        "src/language-html/print-preprocess.js": function srcLanguageHtmlPrintPreprocessJs(e, n) {
          "use strict";

          re();
          var _tg = tg(),
            t = _tg.ParseSourceSpan,
            _qt = qt(),
            s = _qt.htmlTrim,
            a = _qt.getLeadingAndTrailingHtmlWhitespace,
            r = _qt.hasHtmlWhitespace,
            u = _qt.canHaveInterpolation,
            i = _qt.getNodeCssStyleDisplay,
            o = _qt.isDanglingSpaceSensitiveNode,
            c = _qt.isIndentationSensitiveNode,
            v = _qt.isLeadingSpaceSensitiveNode,
            m = _qt.isTrailingSpaceSensitiveNode,
            d = _qt.isWhitespaceSensitiveNode,
            p = _qt.isVueScriptTag,
            f = [w, T, S, I, k, D, P, C, g, B, F];
          function h(l, E) {
            var _iterator50 = _createForOfIteratorHelper(f),
              _step50;
            try {
              for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                var y = _step50.value;
                y(l, E);
              }
            } catch (err) {
              _iterator50.e(err);
            } finally {
              _iterator50.f();
            }
            return l;
          }
          function w(l) {
            l.walk(function (E) {
              if (E.type === "element" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === "text" && E.children[0].value[0] === "\n") {
                var y = E.children[0];
                y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);
              }
            });
          }
          function T(l) {
            var E = function E(y) {
              return y.type === "element" && y.prev && y.prev.type === "ieConditionalStartComment" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === "ieConditionalEndComment" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;
            };
            l.walk(function (y) {
              if (y.children) for (var N = 0; N < y.children.length; N++) {
                var x = y.children[N];
                if (!E(x)) continue;
                var b = x.prev,
                  L = x.firstChild;
                y.removeChild(b), N--;
                var M = new t(b.sourceSpan.start, L.sourceSpan.end),
                  j = new t(M.start, x.sourceSpan.end);
                x.condition = b.condition, x.sourceSpan = j, x.startSourceSpan = M, x.removeChild(L);
              }
            });
          }
          function A(l, E, y) {
            l.walk(function (N) {
              if (N.children) for (var x = 0; x < N.children.length; x++) {
                var b = N.children[x];
                if (b.type !== "text" && !E(b)) continue;
                b.type !== "text" && (b.type = "text", b.value = y(b));
                var L = b.prev;
                !L || L.type !== "text" || (L.value += b.value, L.sourceSpan = new t(L.sourceSpan.start, b.sourceSpan.end), N.removeChild(b), x--);
              }
            });
          }
          function S(l) {
            return A(l, function (E) {
              return E.type === "cdata";
            }, function (E) {
              return "<![CDATA[".concat(E.value, "]]>");
            });
          }
          function B(l) {
            var E = function E(y) {
              return y.type === "element" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === "text" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === "text" && y.next && y.next.type === "text";
            };
            l.walk(function (y) {
              if (y.children) for (var N = 0; N < y.children.length; N++) {
                var x = y.children[N];
                if (!E(x)) continue;
                var b = x.prev,
                  L = x.next;
                b.value += "<".concat(x.rawName, ">") + x.firstChild.value + "</".concat(x.rawName, ">") + L.value, b.sourceSpan = new t(b.sourceSpan.start, L.sourceSpan.end), b.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x), N--, y.removeChild(L);
              }
            });
          }
          function I(l, E) {
            if (E.parser === "html") return;
            var y = /\{\{([\s\S]+?)\}\}/;
            l.walk(function (N) {
              if (!!u(N)) {
                var _iterator51 = _createForOfIteratorHelper(N.children),
                  _step51;
                try {
                  for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
                    var x = _step51.value;
                    if (x.type !== "text") continue;
                    var b = x.sourceSpan.start,
                      L = null,
                      M = x.value.split(y);
                    for (var j = 0; j < M.length; j++, b = L) {
                      var $ = M[j];
                      if (j % 2 === 0) {
                        L = b.moveBy($.length), $.length > 0 && N.insertChildBefore(x, {
                          type: "text",
                          value: $,
                          sourceSpan: new t(b, L)
                        });
                        continue;
                      }
                      L = b.moveBy($.length + 4), N.insertChildBefore(x, {
                        type: "interpolation",
                        sourceSpan: new t(b, L),
                        children: $.length === 0 ? [] : [{
                          type: "text",
                          value: $,
                          sourceSpan: new t(b.moveBy(2), L.moveBy(-2))
                        }]
                      });
                    }
                    N.removeChild(x);
                  }
                } catch (err) {
                  _iterator51.e(err);
                } finally {
                  _iterator51.f();
                }
              }
            });
          }
          function k(l) {
            l.walk(function (E) {
              if (!E.children) return;
              if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === "text" && s(E.children[0].value).length === 0) {
                E.hasDanglingSpaces = E.children.length > 0, E.children = [];
                return;
              }
              var y = d(E),
                N = c(E);
              if (!y) for (var x = 0; x < E.children.length; x++) {
                var b = E.children[x];
                if (b.type !== "text") continue;
                var _a5 = a(b.value),
                  L = _a5.leadingWhitespace,
                  M = _a5.text,
                  j = _a5.trailingWhitespace,
                  $ = b.prev,
                  V = b.next;
                M ? (b.value = M, b.sourceSpan = new t(b.sourceSpan.start.moveBy(L.length), b.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = !0), b.hasLeadingSpaces = !0), j && (b.hasTrailingSpaces = !0, V && (V.hasLeadingSpaces = !0))) : (E.removeChild(b), x--, (L || j) && ($ && ($.hasTrailingSpaces = !0), V && (V.hasLeadingSpaces = !0)));
              }
              E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;
            });
          }
          function P(l) {
            l.walk(function (E) {
              E.isSelfClosing = !E.children || E.type === "element" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);
            });
          }
          function C(l, E) {
            l.walk(function (y) {
              y.type === "element" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));
            });
          }
          function D(l, E) {
            l.walk(function (y) {
              y.cssDisplay = i(y, E);
            });
          }
          function g(l, E) {
            l.walk(function (y) {
              var N = y.children;
              if (!!N) {
                if (N.length === 0) {
                  y.isDanglingSpaceSensitive = o(y);
                  return;
                }
                var _iterator52 = _createForOfIteratorHelper(N),
                  _step52;
                try {
                  for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                    var _x5 = _step52.value;
                    _x5.isLeadingSpaceSensitive = v(_x5, E), _x5.isTrailingSpaceSensitive = m(_x5, E);
                  }
                } catch (err) {
                  _iterator52.e(err);
                } finally {
                  _iterator52.f();
                }
                for (var x = 0; x < N.length; x++) {
                  var b = N[x];
                  b.isLeadingSpaceSensitive = (x === 0 || b.prev.isTrailingSpaceSensitive) && b.isLeadingSpaceSensitive, b.isTrailingSpaceSensitive = (x === N.length - 1 || b.next.isLeadingSpaceSensitive) && b.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function F(l, E) {
            if (E.parser === "vue") {
              var y = l.children.find(function (x) {
                return p(x, E);
              });
              if (!y) return;
              var N = y.attrMap.lang;
              (N === "ts" || N === "typescript") && (E.__should_parse_vue_template_with_ts = !0);
            }
          }
          n.exports = h;
        }
      }),
      ng = Z({
        "src/language-html/pragma.js": function srcLanguageHtmlPragmaJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return "<!-- @format -->\n\n" + a.replace(/^\s*\n/, "");
          }
          n.exports = {
            hasPragma: t,
            insertPragma: s
          };
        }
      }),
      Yn = Z({
        "src/language-html/loc.js": function srcLanguageHtmlLocJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          n.exports = {
            locStart: t,
            locEnd: s
          };
        }
      }),
      er = Z({
        "src/language-html/print/tag.js": function srcLanguageHtmlPrintTagJs(e, n) {
          "use strict";

          re();
          var t = Xt(),
            _Ue42 = Ue(),
            s = _Ue42.isNonEmptyArray,
            _Oe46 = Oe(),
            _Oe46$builders = _Oe46.builders,
            a = _Oe46$builders.indent,
            r = _Oe46$builders.join,
            u = _Oe46$builders.line,
            i = _Oe46$builders.softline,
            o = _Oe46$builders.hardline,
            c = _Oe46.utils.replaceTextEndOfLine,
            _Yn = Yn(),
            v = _Yn.locStart,
            m = _Yn.locEnd,
            _qt2 = qt(),
            d = _qt2.isTextLikeNode,
            p = _qt2.getLastDescendant,
            f = _qt2.isPreLikeNode,
            h = _qt2.hasPrettierIgnore,
            w = _qt2.shouldPreserveContent,
            T = _qt2.isVueSfcBlock;
          function A(q, Y) {
            return [q.isSelfClosing ? "" : S(q, Y), B(q, Y)];
          }
          function S(q, Y) {
            return q.lastChild && l(q.lastChild) ? "" : [I(q, Y), P(q, Y)];
          }
          function B(q, Y) {
            return (q.next ? g(q.next) : F(q.parent)) ? "" : [C(q, Y), k(q, Y)];
          }
          function I(q, Y) {
            return F(q) ? C(q.lastChild, Y) : "";
          }
          function k(q, Y) {
            return l(q) ? P(q.parent, Y) : E(q) ? $(q.next) : "";
          }
          function P(q, Y) {
            if (t(!q.isSelfClosing), D(q, Y)) return "";
            switch (q.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (q.hasHtmComponentClosingTag) return "<//";
              default:
                return "</".concat(q.rawName);
            }
          }
          function C(q, Y) {
            if (D(q, Y)) return "";
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (q.isSelfClosing) return "/>";
              default:
                return ">";
            }
          }
          function D(q, Y) {
            return !q.isSelfClosing && !q.endSourceSpan && (h(q) || w(q.parent, Y));
          }
          function g(q) {
            return q.prev && q.prev.type !== "docType" && !d(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function F(q) {
            return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d(p(q.lastChild)) && !f(q);
          }
          function l(q) {
            return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d(p(q));
          }
          function E(q) {
            return q.next && !d(q.next) && d(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;
          }
          function y(q) {
            var Y = q.trim().match(/^prettier\x2Dignore\x2Dattribute(?:\s+([\s\S]+))?$/);
            return Y ? Y[1] ? Y[1].split(/\s+/) : !0 : !1;
          }
          function N(q) {
            return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function x(q, Y, H) {
            var R = q.getValue();
            if (!s(R.attrs)) return R.isSelfClosing ? " " : "";
            var Q = R.prev && R.prev.type === "comment" && y(R.prev.value),
              ee = typeof Q == "boolean" ? function () {
                return Q;
              } : Array.isArray(Q) ? function (De) {
                return Q.includes(De.rawName);
              } : function () {
                return !1;
              },
              te = q.map(function (De) {
                var ie = De.getValue();
                return ee(ie) ? c(Y.originalText.slice(v(ie), m(ie))) : H();
              }, "attrs"),
              oe = R.type === "element" && R.fullName === "script" && R.attrs.length === 1 && R.attrs[0].fullName === "src" && R.children.length === 0,
              X = Y.singleAttributePerLine && R.attrs.length > 1 && !T(R, Y) ? o : u,
              ue = [a([oe ? " " : u, r(X, te)])];
            return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe ? ue.push(R.isSelfClosing ? " " : "") : ue.push(Y.bracketSameLine ? R.isSelfClosing ? " " : "" : R.isSelfClosing ? u : i), ue;
          }
          function b(q) {
            return q.firstChild && N(q.firstChild) ? "" : V(q);
          }
          function L(q, Y, H) {
            var R = q.getValue();
            return [M(R, Y), x(q, Y, H), R.isSelfClosing ? "" : b(R)];
          }
          function M(q, Y) {
            return q.prev && E(q.prev) ? "" : [j(q, Y), $(q)];
          }
          function j(q, Y) {
            return N(q) ? V(q.parent) : g(q) ? C(q.prev, Y) : "";
          }
          function $(q) {
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return "<!--[if ".concat(q.condition);
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (q.condition) return "<!--[if ".concat(q.condition, "]><!--><").concat(q.rawName);
              default:
                return "<".concat(q.rawName);
            }
          }
          function V(q) {
            switch (t(!q.isSelfClosing), q.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (q.condition) return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          n.exports = {
            printClosingTag: A,
            printClosingTagStart: S,
            printClosingTagStartMarker: P,
            printClosingTagEndMarker: C,
            printClosingTagSuffix: k,
            printClosingTagEnd: B,
            needsToBorrowLastChildClosingTagEndMarker: F,
            needsToBorrowParentClosingTagStartMarker: l,
            needsToBorrowPrevClosingTagEndMarker: g,
            printOpeningTag: L,
            printOpeningTagStart: M,
            printOpeningTagPrefix: j,
            printOpeningTagStartMarker: $,
            printOpeningTagEndMarker: V,
            needsToBorrowNextOpeningTagStartMarker: E,
            needsToBorrowParentOpeningTagEndMarker: N
          };
        }
      }),
      ug = Z({
        "node_modules/parse-srcset/src/parse-srcset.js": function node_modulesParseSrcsetSrcParseSrcsetJs(e, n) {
          re(), function (t, s) {
            typeof define == "function" && define.amd ? define([], s) : _typeof(n) == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
          }(e, function () {
            return function (t, s) {
              var a = s && s.logger || console;
              function r(P) {
                return P === " " || P === "	" || P === "\n" || P === "\f" || P === "\r";
              }
              function u(P) {
                var C,
                  D = P.exec(t.substring(S));
                if (D) return C = D[0], S += C.length, C;
              }
              for (var i = t.length, o = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, v = /^[^ \t\n\r\u000c]+/, m = /[,]+$/, d = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, w, T, A, S = 0, B = [];;) {
                if (u(c), S >= i) return B;
                f = u(v), h = [], f.slice(-1) === "," ? (f = f.replace(m, ""), k()) : I();
              }
              function I() {
                for (u(o), w = "", T = "in descriptor";;) {
                  if (A = t.charAt(S), T === "in descriptor") {
                    if (r(A)) w && (h.push(w), w = "", T = "after descriptor");else if (A === ",") {
                      S += 1, w && h.push(w), k();
                      return;
                    } else if (A === "(") w = w + A, T = "in parens";else if (A === "") {
                      w && h.push(w), k();
                      return;
                    } else w = w + A;
                  } else if (T === "in parens") {
                    if (A === ")") w = w + A, T = "in descriptor";else if (A === "") {
                      h.push(w), k();
                      return;
                    } else w = w + A;
                  } else if (T === "after descriptor" && !r(A)) if (A === "") {
                    k();
                    return;
                  } else T = "in descriptor", S -= 1;
                  S += 1;
                }
              }
              function k() {
                var P = !1,
                  C,
                  D,
                  g,
                  F,
                  l = {},
                  E,
                  y,
                  N,
                  x,
                  b;
                for (F = 0; F < h.length; F++) {
                  E = h[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x = parseInt(N, 10), b = parseFloat(N), d.test(N) && y === "w" ? ((C || D) && (P = !0), x === 0 ? P = !0 : C = x) : p.test(N) && y === "x" ? ((C || D || g) && (P = !0), b < 0 ? P = !0 : D = b) : d.test(N) && y === "h" ? ((g || D) && (P = !0), x === 0 ? P = !0 : g = x) : P = !0;
                }
                P ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + E + "'.") : (l.url = f, C && (l.w = C), D && (l.d = D), g && (l.h = g), B.push(l));
              }
            };
          });
        }
      }),
      sg = Z({
        "src/language-html/syntax-attribute.js": function srcLanguageHtmlSyntaxAttributeJs(e, n) {
          "use strict";

          re();
          var t = ug(),
            _Oe47 = Oe(),
            _Oe47$builders = _Oe47.builders,
            s = _Oe47$builders.ifBreak,
            a = _Oe47$builders.join,
            r = _Oe47$builders.line;
          function u(o) {
            var c = t(o, {
                logger: {
                  error: function error(I) {
                    throw new Error(I);
                  }
                }
              }),
              v = c.some(function (I) {
                var k = I.w;
                return k;
              }),
              m = c.some(function (I) {
                var k = I.h;
                return k;
              }),
              d = c.some(function (I) {
                var k = I.d;
                return k;
              });
            if (v + m + d > 1) throw new Error("Mixed descriptor in srcset is not supported");
            var p = v ? "w" : m ? "h" : "d",
              f = v ? "w" : m ? "h" : "x",
              h = function h(I) {
                return Math.max.apply(Math, _toConsumableArray(I));
              },
              w = c.map(function (I) {
                return I.url;
              }),
              T = h(w.map(function (I) {
                return I.length;
              })),
              A = c.map(function (I) {
                return I[p];
              }).map(function (I) {
                return I ? I.toString() : "";
              }),
              S = A.map(function (I) {
                var k = I.indexOf(".");
                return k === -1 ? I.length : k;
              }),
              B = h(S);
            return a([",", r], w.map(function (I, k) {
              var P = [I],
                C = A[k];
              if (C) {
                var D = T - I.length + 1,
                  g = B - S[k],
                  F = " ".repeat(D + g);
                P.push(s(F, " "), C + f);
              }
              return P;
            }));
          }
          function i(o) {
            return o.trim().split(/\s+/).join(" ");
          }
          n.exports = {
            printImgSrcset: u,
            printClassNames: i
          };
        }
      }),
      ig = Z({
        "src/language-html/syntax-vue.js": function srcLanguageHtmlSyntaxVueJs(e, n) {
          "use strict";

          re();
          var _Oe48 = Oe(),
            t = _Oe48.builders.group;
          function s(i, o) {
            var _a6 = a(i),
              c = _a6.left,
              v = _a6.operator,
              m = _a6.right;
            return [t(o("function _(".concat(c, ") {}"), {
              parser: "babel",
              __isVueForBindingLeft: !0
            })), " ", v, " ", o(m, {
              parser: "__js_expression"
            }, {
              stripTrailingHardline: !0
            })];
          }
          function a(i) {
            var o = /([\s\S]*?)\s+(in|of)\s+([\s\S]*)/,
              c = /,([^,\]}]*)(?:,([^,\]}]*))?$/,
              v = /^\(|\)$/g,
              m = i.match(o);
            if (!m) return;
            var d = {};
            if (d.for = m[3].trim(), !d.for) return;
            var p = m[1].trim().replace(v, ""),
              f = p.match(c);
            f ? (d.alias = p.replace(c, ""), d.iterator1 = f[1].trim(), f[2] && (d.iterator2 = f[2].trim())) : d.alias = p;
            var h = [d.alias, d.iterator1, d.iterator2];
            if (!h.some(function (w, T) {
              return !w && (T === 0 || h.slice(T + 1).some(Boolean));
            })) return {
              left: h.filter(Boolean).join(","),
              operator: m[2],
              right: d.for
            };
          }
          function r(i, o) {
            return o("function _(".concat(i, ") {}"), {
              parser: "babel",
              __isVueBindings: !0
            });
          }
          function u(i) {
            var o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/,
              c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/,
              v = i.trim();
            return o.test(v) || c.test(v);
          }
          n.exports = {
            isVueEventBindingExpression: u,
            printVueFor: s,
            printVueBindings: r
          };
        }
      }),
      ho = Z({
        "src/language-html/get-node-content.js": function srcLanguageHtmlGetNodeContentJs(e, n) {
          "use strict";

          re();
          var _er = er(),
            t = _er.needsToBorrowParentClosingTagStartMarker,
            s = _er.printClosingTagStartMarker,
            a = _er.needsToBorrowLastChildClosingTagEndMarker,
            r = _er.printClosingTagEndMarker,
            u = _er.needsToBorrowParentOpeningTagEndMarker,
            i = _er.printOpeningTagEndMarker;
          function o(c, v) {
            var m = c.startSourceSpan.end.offset;
            c.firstChild && u(c.firstChild) && (m -= i(c).length);
            var d = c.endSourceSpan.start.offset;
            return c.lastChild && t(c.lastChild) ? d += s(c, v).length : a(c) && (d -= r(c.lastChild, v).length), v.originalText.slice(m, d);
          }
          n.exports = o;
        }
      }),
      ag = Z({
        "src/language-html/embed.js": function srcLanguageHtmlEmbedJs(e, n) {
          "use strict";

          re();
          var _Oe49 = Oe(),
            _Oe49$builders = _Oe49.builders,
            t = _Oe49$builders.breakParent,
            s = _Oe49$builders.group,
            a = _Oe49$builders.hardline,
            r = _Oe49$builders.indent,
            u = _Oe49$builders.line,
            i = _Oe49$builders.fill,
            o = _Oe49$builders.softline,
            _Oe49$utils = _Oe49.utils,
            c = _Oe49$utils.mapDoc,
            v = _Oe49$utils.replaceTextEndOfLine,
            m = Xn(),
            _er2 = er(),
            d = _er2.printClosingTag,
            p = _er2.printClosingTagSuffix,
            f = _er2.needsToBorrowPrevClosingTagEndMarker,
            h = _er2.printOpeningTagPrefix,
            w = _er2.printOpeningTag,
            _sg = sg(),
            T = _sg.printImgSrcset,
            A = _sg.printClassNames,
            _ig = ig(),
            S = _ig.printVueFor,
            B = _ig.printVueBindings,
            I = _ig.isVueEventBindingExpression,
            _qt3 = qt(),
            k = _qt3.isScriptLikeTag,
            P = _qt3.isVueNonHtmlBlock,
            C = _qt3.inferScriptParser,
            D = _qt3.htmlTrimPreserveIndentation,
            g = _qt3.dedentString,
            F = _qt3.unescapeQuoteEntities,
            l = _qt3.isVueSlotAttribute,
            E = _qt3.isVueSfcBindingsAttribute,
            y = _qt3.getTextValueParts,
            N = ho();
          function x(L, M, j) {
            var $ = function $(te) {
                return new RegExp(te.join("|")).test(L.fullName);
              },
              V = function V() {
                return F(L.value);
              },
              q = !1,
              Y = function Y(te, oe) {
                var W = te.type === "NGRoot" ? te.node.type === "NGMicrosyntax" && te.node.body.length === 1 && te.node.body[0].type === "NGMicrosyntaxExpression" ? te.node.body[0].expression : te.node : te.type === "JsExpressionRoot" ? te.node : te;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || oe.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (q = !0);
              },
              H = function H(te) {
                return s(te);
              },
              R = function R(te) {
                var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                return s([r([o, te]), oe ? o : ""]);
              },
              Q = function Q(te) {
                return q ? H(te) : R(te);
              },
              ee = function ee(te, oe) {
                return M(te, Object.assign({
                  __onHtmlBindingRoot: Y,
                  __embeddedInHtml: !0
                }, oe));
              };
            if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source")) return R(T(V()));
            if (L.fullName === "class" && !j.parentParser) {
              var te = V();
              if (!te.includes("{{")) return A(te);
            }
            if (L.fullName === "style" && !j.parentParser) {
              var _te2 = V();
              if (!_te2.includes("{{")) return R(ee(_te2, {
                parser: "css",
                __isHTMLStyleAttribute: !0
              }));
            }
            if (j.parser === "vue") {
              if (L.fullName === "v-for") return S(V(), ee);
              if (l(L) || E(L, j)) return B(V(), ee);
              var _te3 = ["^@", "^v-on:"],
                oe = ["^:", "^v-bind:"],
                W = ["^v-"];
              if ($(_te3)) {
                var X = V(),
                  ue = I(X) ? "__js_expression" : j.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Q(ee(X, {
                  parser: ue
                }));
              }
              if ($(oe)) return Q(ee(V(), {
                parser: "__vue_expression"
              }));
              if ($(W)) return Q(ee(V(), {
                parser: "__js_expression"
              }));
            }
            if (j.parser === "angular") {
              var _te4 = function _te4(G, z) {
                  return ee(G, Object.assign(Object.assign({}, z), {}, {
                    trailingComma: "none"
                  }));
                },
                _oe2 = ["^\\*"],
                _W4 = ["^\\(.+\\)$", "^on-"],
                _X2 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"],
                _ue2 = ["^i18n(-.+)?$"];
              if ($(_W4)) return Q(_te4(V(), {
                parser: "__ng_action"
              }));
              if ($(_X2)) return Q(_te4(V(), {
                parser: "__ng_binding"
              }));
              if ($(_ue2)) {
                var G = V().trim();
                return R(i(y(L, G)), !G.includes("@@"));
              }
              if ($(_oe2)) return Q(_te4(V(), {
                parser: "__ng_directive"
              }));
              var De = /\{\{([\s\S]+?)\}\}/,
                ie = V();
              if (De.test(ie)) {
                var _G4 = [];
                var _iterator53 = _createForOfIteratorHelper(ie.split(De).entries()),
                  _step53;
                try {
                  for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
                    var _step53$value = _slicedToArray(_step53.value, 2),
                      z = _step53$value[0],
                      U = _step53$value[1];
                    if (z % 2 === 0) _G4.push(v(U));else try {
                      _G4.push(s(["{{", r([u, _te4(U, {
                        parser: "__ng_interpolation",
                        __isInHtmlInterpolation: !0
                      })]), u, "}}"]));
                    } catch (_unused10) {
                      _G4.push("{{", v(U), "}}");
                    }
                  }
                } catch (err) {
                  _iterator53.e(err);
                } finally {
                  _iterator53.f();
                }
                return s(_G4);
              }
            }
            return null;
          }
          function b(L, M, j, $) {
            var V = L.getValue();
            switch (V.type) {
              case "element":
                {
                  if (k(V) || V.type === "interpolation") return;
                  if (!V.isSelfClosing && P(V, $)) {
                    var q = C(V, $);
                    if (!q) return;
                    var Y = N(V, $),
                      H = /^\s*$/.test(Y),
                      R = "";
                    return H || (R = j(D(Y), {
                      parser: q,
                      __embeddedInHtml: !0
                    }, {
                      stripTrailingHardline: !0
                    }), H = R === ""), [h(V, $), s(w(L, $, M)), H ? "" : a, R, H ? "" : a, d(V, $), p(V, $)];
                  }
                  break;
                }
              case "text":
                {
                  if (k(V.parent)) {
                    var _q3 = C(V.parent, $);
                    if (_q3) {
                      var _Y3 = _q3 === "markdown" ? g(V.value.replace(/^[^\S\n]*\n/, "")) : V.value,
                        _H4 = {
                          parser: _q3,
                          __embeddedInHtml: !0
                        };
                      if ($.parser === "html" && _q3 === "babel") {
                        var _R = "script",
                          Q = V.parent.attrMap;
                        Q && (Q.type === "module" || Q.type === "text/babel" && Q["data-type"] === "module") && (_R = "module"), _H4.__babelSourceType = _R;
                      }
                      return [t, h(V, $), j(_Y3, _H4, {
                        stripTrailingHardline: !0
                      }), p(V, $)];
                    }
                  } else if (V.parent.type === "interpolation") {
                    var _q4 = {
                      __isInHtmlInterpolation: !0,
                      __embeddedInHtml: !0
                    };
                    return $.parser === "angular" ? (_q4.parser = "__ng_interpolation", _q4.trailingComma = "none") : $.parser === "vue" ? _q4.parser = $.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : _q4.parser = "__js_expression", [r([u, j(V.value, _q4, {
                      stripTrailingHardline: !0
                    })]), V.parent.next && f(V.parent.next) ? " " : u];
                  }
                  break;
                }
              case "attribute":
                {
                  if (!V.value) break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, "=", V.value];
                  if ($.parser === "lwc" && /^\{[\s\S]*\}$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, "=", V.value];
                  var _q5 = x(V, function (Y, H) {
                    return j(Y, Object.assign({
                      __isInHtmlAttribute: !0,
                      __embeddedInHtml: !0
                    }, H), {
                      stripTrailingHardline: !0
                    });
                  }, $);
                  if (_q5) return [V.rawName, '="', s(c(_q5, function (Y) {
                    return typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y;
                  })), '"'];
                  break;
                }
              case "front-matter":
                return m(V, j);
            }
          }
          n.exports = b;
        }
      }),
      vo = Z({
        "src/language-html/print/children.js": function srcLanguageHtmlPrintChildrenJs(e, n) {
          "use strict";

          re();
          var _Oe50 = Oe(),
            _Oe50$builders = _Oe50.builders,
            t = _Oe50$builders.breakParent,
            s = _Oe50$builders.group,
            a = _Oe50$builders.ifBreak,
            r = _Oe50$builders.line,
            u = _Oe50$builders.softline,
            i = _Oe50$builders.hardline,
            o = _Oe50.utils.replaceTextEndOfLine,
            _Yn2 = Yn(),
            c = _Yn2.locStart,
            v = _Yn2.locEnd,
            _qt4 = qt(),
            m = _qt4.forceBreakChildren,
            d = _qt4.forceNextEmptyLine,
            p = _qt4.isTextLikeNode,
            f = _qt4.hasPrettierIgnore,
            h = _qt4.preferHardlineAsLeadingSpaces,
            _er3 = er(),
            w = _er3.printOpeningTagPrefix,
            T = _er3.needsToBorrowNextOpeningTagStartMarker,
            A = _er3.printOpeningTagStartMarker,
            S = _er3.needsToBorrowPrevClosingTagEndMarker,
            B = _er3.printClosingTagEndMarker,
            I = _er3.printClosingTagSuffix,
            k = _er3.needsToBorrowParentClosingTagStartMarker;
          function P(g, F, l) {
            var E = g.getValue();
            return f(E) ? [w(E, F)].concat(_toConsumableArray(o(F.originalText.slice(c(E) + (E.prev && T(E.prev) ? A(E).length : 0), v(E) - (E.next && S(E.next) ? B(E, F).length : 0)))), [I(E, F)]) : l();
          }
          function C(g, F) {
            return p(g) && p(F) ? g.isTrailingSpaceSensitive ? g.hasTrailingSpaces ? h(F) ? i : r : "" : h(F) ? i : u : T(g) && (f(F) || F.firstChild || F.isSelfClosing || F.type === "element" && F.attrs.length > 0) || g.type === "element" && g.isSelfClosing && S(F) ? "" : !F.isLeadingSpaceSensitive || h(F) || S(F) && g.lastChild && k(g.lastChild) && g.lastChild.lastChild && k(g.lastChild.lastChild) ? i : F.hasLeadingSpaces ? r : u;
          }
          function D(g, F, l) {
            var E = g.getValue();
            if (m(E)) return [t].concat(_toConsumableArray(g.map(function (N) {
              var x = N.getValue(),
                b = x.prev ? C(x.prev, x) : "";
              return [b ? [b, d(x.prev) ? i : ""] : "", P(N, F, l)];
            }, "children")));
            var y = E.children.map(function () {
              return Symbol("");
            });
            return g.map(function (N, x) {
              var b = N.getValue();
              if (p(b)) {
                if (b.prev && p(b.prev)) {
                  var Y = C(b.prev, b);
                  if (Y) return d(b.prev) ? [i, i, P(N, F, l)] : [Y, P(N, F, l)];
                }
                return P(N, F, l);
              }
              var L = [],
                M = [],
                j = [],
                $ = [],
                V = b.prev ? C(b.prev, b) : "",
                q = b.next ? C(b, b.next) : "";
              return V && (d(b.prev) ? L.push(i, i) : V === i ? L.push(i) : p(b.prev) ? M.push(V) : M.push(a("", u, {
                groupId: y[x - 1]
              }))), q && (d(b) ? p(b.next) && $.push(i, i) : q === i ? p(b.next) && $.push(i) : j.push(q)), [].concat(L, [s([].concat(M, [s([P(N, F, l)].concat(j), {
                id: y[x]
              })]))], $);
            }, "children");
          }
          n.exports = {
            printChildren: D
          };
        }
      }),
      og = Z({
        "src/language-html/print/element.js": function srcLanguageHtmlPrintElementJs(e, n) {
          "use strict";

          re();
          var _Oe51 = Oe(),
            _Oe51$builders = _Oe51.builders,
            t = _Oe51$builders.breakParent,
            s = _Oe51$builders.dedentToRoot,
            a = _Oe51$builders.group,
            r = _Oe51$builders.ifBreak,
            u = _Oe51$builders.indentIfBreak,
            i = _Oe51$builders.indent,
            o = _Oe51$builders.line,
            c = _Oe51$builders.softline,
            v = _Oe51.utils.replaceTextEndOfLine,
            m = ho(),
            _qt5 = qt(),
            d = _qt5.shouldPreserveContent,
            p = _qt5.isScriptLikeTag,
            f = _qt5.isVueCustomBlock,
            h = _qt5.countParents,
            w = _qt5.forceBreakContent,
            _er4 = er(),
            T = _er4.printOpeningTagPrefix,
            A = _er4.printOpeningTag,
            S = _er4.printClosingTagSuffix,
            B = _er4.printClosingTag,
            I = _er4.needsToBorrowPrevClosingTagEndMarker,
            k = _er4.needsToBorrowLastChildClosingTagEndMarker,
            _vo = vo(),
            P = _vo.printChildren;
          function C(D, g, F) {
            var l = D.getValue();
            if (d(l, g)) return [T(l, g), a(A(D, g, F))].concat(_toConsumableArray(v(m(l, g))), _toConsumableArray(B(l, g)), [S(l, g)]);
            var E = l.children.length === 1 && l.firstChild.type === "interpolation" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces,
              y = Symbol("element-attr-group-id"),
              N = function N(M) {
                return a([a(A(D, g, F), {
                  id: y
                }), M, B(l, g)]);
              },
              x = function x(M) {
                return E ? u(M, {
                  groupId: y
                }) : (p(l) || f(l, g)) && l.parent.type === "root" && g.parser === "vue" && !g.vueIndentScriptAndStyle ? M : i(M);
              },
              b = function b() {
                return E ? r(c, "", {
                  groupId: y
                }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s(c) : c;
              },
              L = function L() {
                return (l.next ? I(l.next) : k(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? " " : "" : E ? r(c, "", {
                  groupId: y
                }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === "comment" || l.lastChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(g.tabWidth * h(D, function (j) {
                  return j.parent && j.parent.type !== "root";
                }), "}$")).test(l.lastChild.value) ? "" : c;
              };
            return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : "") : N([w(l) ? t : "", x([b(), P(D, g, F)]), L()]);
          }
          n.exports = {
            printElement: C
          };
        }
      }),
      lg = Z({
        "src/language-html/printer-html.js": function srcLanguageHtmlPrinterHtmlJs(e, n) {
          "use strict";

          re();
          var _Oe52 = Oe(),
            _Oe52$builders = _Oe52.builders,
            t = _Oe52$builders.fill,
            s = _Oe52$builders.group,
            a = _Oe52$builders.hardline,
            r = _Oe52$builders.literalline,
            _Oe52$utils = _Oe52.utils,
            u = _Oe52$utils.cleanDoc,
            i = _Oe52$utils.getDocParts,
            o = _Oe52$utils.isConcat,
            c = _Oe52$utils.replaceTextEndOfLine,
            v = zd(),
            _qt6 = qt(),
            m = _qt6.countChars,
            d = _qt6.unescapeQuoteEntities,
            p = _qt6.getTextValueParts,
            f = rg(),
            _ng = ng(),
            h = _ng.insertPragma,
            _Yn3 = Yn(),
            w = _Yn3.locStart,
            T = _Yn3.locEnd,
            A = ag(),
            _er5 = er(),
            S = _er5.printClosingTagSuffix,
            B = _er5.printClosingTagEnd,
            I = _er5.printOpeningTagPrefix,
            k = _er5.printOpeningTagStart,
            _og = og(),
            P = _og.printElement,
            _vo2 = vo(),
            C = _vo2.printChildren;
          function D(g, F, l) {
            var E = g.getValue();
            switch (E.type) {
              case "front-matter":
                return c(E.raw);
              case "root":
                return F.__onHtmlRoot && F.__onHtmlRoot(E), [s(C(g, F, l)), a];
              case "element":
              case "ieConditionalComment":
                return P(g, F, l);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [k(E), B(E)];
              case "interpolation":
                return [k(E, F)].concat(_toConsumableArray(g.map(l, "children")), [B(E, F)]);
              case "text":
                {
                  if (E.parent.type === "interpolation") {
                    var N = /\n[^\S\n]*$/,
                      x = N.test(E.value),
                      b = x ? E.value.replace(N, "") : E.value;
                    return [].concat(_toConsumableArray(c(b)), [x ? a : ""]);
                  }
                  var y = u([I(E, F)].concat(_toConsumableArray(p(E)), [S(E, F)]));
                  return o(y) || y.type === "fill" ? t(i(y)) : y;
                }
              case "docType":
                return [s([k(E, F), " ", E.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(E, F)];
              case "comment":
                return [I(E, F)].concat(_toConsumableArray(c(F.originalText.slice(w(E), T(E)), r)), [S(E, F)]);
              case "attribute":
                {
                  if (E.value === null) return E.rawName;
                  var _y4 = d(E.value),
                    _N4 = m(_y4, "'"),
                    _x6 = m(_y4, '"'),
                    _b9 = _N4 < _x6 ? "'" : '"';
                  return [E.rawName, "=", _b9].concat(_toConsumableArray(c(_b9 === '"' ? _y4.replace(/"/g, "&quot;") : _y4.replace(/'/g, "&apos;"))), [_b9]);
                }
              default:
                throw new Error("Unexpected node type ".concat(E.type));
            }
          }
          n.exports = {
            preprocess: f,
            print: D,
            insertPragma: h,
            massageAstNode: v,
            embed: A
          };
        }
      }),
      cg = Z({
        "src/language-html/options.js": function srcLanguageHtmlOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot(),
            s = "HTML";
          n.exports = {
            bracketSameLine: t.bracketSameLine,
            htmlWhitespaceSensitivity: {
              since: "1.15.0",
              category: s,
              type: "choice",
              default: "css",
              description: "How to handle whitespaces in HTML.",
              choices: [{
                value: "css",
                description: "Respect the default value of CSS display property."
              }, {
                value: "strict",
                description: "Whitespaces are considered sensitive."
              }, {
                value: "ignore",
                description: "Whitespaces are considered insensitive."
              }]
            },
            singleAttributePerLine: t.singleAttributePerLine,
            vueIndentScriptAndStyle: {
              since: "1.19.0",
              category: s,
              type: "boolean",
              default: !1,
              description: "Indent script and style tags in Vue files."
            }
          };
        }
      }),
      pg = Z({
        "src/language-html/parsers.js": function srcLanguageHtmlParsersJs() {
          re();
        }
      }),
      xn = Z({
        "node_modules/linguist-languages/data/HTML.json": function node_modulesLinguistLanguagesDataHTMLJson(e, n) {
          n.exports = {
            name: "HTML",
            type: "markup",
            tmScope: "text.html.basic",
            aceMode: "html",
            codemirrorMode: "htmlmixed",
            codemirrorMimeType: "text/html",
            color: "#e34c26",
            aliases: ["xhtml"],
            extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"],
            languageId: 146
          };
        }
      }),
      fg = Z({
        "node_modules/linguist-languages/data/Vue.json": function node_modulesLinguistLanguagesDataVueJson(e, n) {
          n.exports = {
            name: "Vue",
            type: "markup",
            color: "#41b883",
            extensions: [".vue"],
            tmScope: "text.html.vue",
            aceMode: "html",
            languageId: 391
          };
        }
      }),
      Dg = Z({
        "src/language-html/index.js": function srcLanguageHtmlIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = lg(),
            a = cg(),
            r = pg(),
            u = [t(xn(), function () {
              return {
                name: "Angular",
                since: "1.15.0",
                parsers: ["angular"],
                vscodeLanguageIds: ["html"],
                extensions: [".component.html"],
                filenames: []
              };
            }), t(xn(), function (o) {
              return {
                since: "1.15.0",
                parsers: ["html"],
                vscodeLanguageIds: ["html"],
                extensions: [].concat(_toConsumableArray(o.extensions), [".mjml"])
              };
            }), t(xn(), function () {
              return {
                name: "Lightning Web Components",
                since: "1.17.0",
                parsers: ["lwc"],
                vscodeLanguageIds: ["html"],
                extensions: [],
                filenames: []
              };
            }), t(fg(), function () {
              return {
                since: "1.10.0",
                parsers: ["vue"],
                vscodeLanguageIds: ["vue"]
              };
            })],
            i = {
              html: s
            };
          n.exports = {
            languages: u,
            printers: i,
            options: a,
            parsers: r
          };
        }
      }),
      mg = Z({
        "src/language-yaml/pragma.js": function srcLanguageYamlPragmaJs(e, n) {
          "use strict";

          re();
          function t(r) {
            return /^\s*@(?:prettier|format)\s*$/.test(r);
          }
          function s(r) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
          }
          function a(r) {
            return "# @format\n\n".concat(r);
          }
          n.exports = {
            isPragma: t,
            hasPragma: s,
            insertPragma: a
          };
        }
      }),
      dg = Z({
        "src/language-yaml/loc.js": function srcLanguageYamlLocJs(e, n) {
          "use strict";

          re();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          n.exports = {
            locStart: t,
            locEnd: s
          };
        }
      }),
      gg = Z({
        "src/language-yaml/embed.js": function srcLanguageYamlEmbedJs(e, n) {
          "use strict";

          re();
          function t(s, a, r, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath)) return r(u.originalText, Object.assign(Object.assign({}, u), {}, {
              parser: "json"
            }));
          }
          n.exports = t;
        }
      }),
      Mt = Z({
        "src/language-yaml/utils.js": function srcLanguageYamlUtilsJs(e, n) {
          "use strict";

          re();
          var _Ue43 = Ue(),
            t = _Ue43.getLast,
            s = _Ue43.isNonEmptyArray;
          function a(C, D) {
            var g = 0,
              F = C.stack.length - 1;
            for (var l = 0; l < F; l++) {
              var E = C.stack[l];
              r(E) && D(E) && g++;
            }
            return g;
          }
          function r(C, D) {
            return C && typeof C.type == "string" && (!D || D.includes(C.type));
          }
          function u(C, D, g) {
            return D("children" in C ? Object.assign(Object.assign({}, C), {}, {
              children: C.children.map(function (F) {
                return u(F, D, C);
              })
            }) : C, g);
          }
          function i(C, D, g) {
            Object.defineProperty(C, D, {
              get: g,
              enumerable: !1
            });
          }
          function o(C, D) {
            var g = 0,
              F = D.length;
            for (var l = C.position.end.offset - 1; l < F; l++) {
              var E = D[l];
              if (E === "\n" && g++, g === 1 && /\S/.test(E)) return !1;
              if (g === 2) return !0;
            }
            return !1;
          }
          function c(C) {
            switch (C.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return !1;
            }
            var g = C.stack.length;
            for (var F = 1; F < g; F++) {
              var l = C.stack[F],
                E = C.stack[F - 1];
              if (Array.isArray(E) && typeof l == "number" && l !== E.length - 1) return !1;
            }
            return !0;
          }
          function v(C) {
            return s(C.children) ? v(t(C.children)) : C;
          }
          function m(C) {
            return C.value.trim() === "prettier-ignore";
          }
          function d(C) {
            var D = C.getValue();
            if (D.type === "documentBody") {
              var g = C.getParentNode();
              return S(g.head) && m(t(g.head.endComments));
            }
            return h(D) && m(t(D.leadingComments));
          }
          function p(C) {
            return !s(C.children) && !f(C);
          }
          function f(C) {
            return h(C) || w(C) || T(C) || A(C) || S(C);
          }
          function h(C) {
            return s(C == null ? void 0 : C.leadingComments);
          }
          function w(C) {
            return s(C == null ? void 0 : C.middleComments);
          }
          function T(C) {
            return C == null ? void 0 : C.indicatorComment;
          }
          function A(C) {
            return C == null ? void 0 : C.trailingComment;
          }
          function S(C) {
            return s(C == null ? void 0 : C.endComments);
          }
          function B(C) {
            var D = [],
              g;
            var _iterator54 = _createForOfIteratorHelper(C.split(/( +)/)),
              _step54;
            try {
              for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
                var F = _step54.value;
                F !== " " ? g === " " ? D.push(F) : D.push((D.pop() || "") + F) : g === void 0 && D.unshift(""), g = F;
              }
            } catch (err) {
              _iterator54.e(err);
            } finally {
              _iterator54.f();
            }
            return g === " " && D.push((D.pop() || "") + " "), D[0] === "" && (D.shift(), D.unshift(" " + (D.shift() || ""))), D;
          }
          function I(C, D, g) {
            var F = D.split("\n").map(function (l, E, y) {
              return E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart();
            });
            return g.proseWrap === "preserve" ? F.map(function (l) {
              return l.length === 0 ? [] : [l];
            }) : F.map(function (l) {
              return l.length === 0 ? [] : B(l);
            }).reduce(function (l, E, y) {
              return y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C === "quoteDouble" && t(t(l)).endsWith("\\")) ? [].concat(_toConsumableArray(l.slice(0, -1)), [[].concat(_toConsumableArray(t(l)), _toConsumableArray(E))]) : [].concat(_toConsumableArray(l), [E]);
            }, []).map(function (l) {
              return g.proseWrap === "never" ? [l.join(" ")] : l;
            });
          }
          function k(C, D) {
            var g = D.parentIndent,
              F = D.isLastDescendant,
              l = D.options,
              E = C.position.start.line === C.position.end.line ? "" : l.originalText.slice(C.position.start.offset, C.position.end.offset).match(/^[^\n]*\n([\s\S]*)$/)[1],
              y;
            if (C.indent === null) {
              var b = E.match( /*#__PURE__*/_wrapRegExp(/^( *)[^\n\r ]/m, {
                leadingSpace: 1
              }));
              y = b ? b.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else y = C.indent - 1 + g;
            var N = E.split("\n").map(function (b) {
              return b.slice(y);
            });
            if (l.proseWrap === "preserve" || C.type === "blockLiteral") return x(N.map(function (b) {
              return b.length === 0 ? [] : [b];
            }));
            return x(N.map(function (b) {
              return b.length === 0 ? [] : B(b);
            }).reduce(function (b, L, M) {
              return M !== 0 && N[M - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(b)) ? [].concat(_toConsumableArray(b.slice(0, -1)), [[].concat(_toConsumableArray(t(b)), _toConsumableArray(L))]) : [].concat(_toConsumableArray(b), [L]);
            }, []).map(function (b) {
              return b.reduce(function (L, M) {
                return L.length > 0 && /\s$/.test(t(L)) ? [].concat(_toConsumableArray(L.slice(0, -1)), [t(L) + " " + M]) : [].concat(_toConsumableArray(L), [M]);
              }, []);
            }).map(function (b) {
              return l.proseWrap === "never" ? [b.join(" ")] : b;
            }));
            function x(b) {
              if (C.chomping === "keep") return t(b).length === 0 ? b.slice(0, -1) : b;
              var L = 0;
              for (var M = b.length - 1; M >= 0 && b[M].length === 0; M--) {
                L++;
              }
              return L === 0 ? b : L >= 2 && !F ? b.slice(0, -(L - 1)) : b.slice(0, -L);
            }
          }
          function P(C) {
            if (!C) return !0;
            switch (C.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return !0;
              default:
                return !1;
            }
          }
          n.exports = {
            getLast: t,
            getAncestorCount: a,
            isNode: r,
            isEmptyNode: p,
            isInlineNode: P,
            mapNode: u,
            defineShortcut: i,
            isNextLineEmpty: o,
            isLastDescendantNode: c,
            getBlockValueLineContents: k,
            getFlowScalarLineContents: I,
            getLastDescendantNode: v,
            hasPrettierIgnore: d,
            hasLeadingComments: h,
            hasMiddleComments: w,
            hasIndicatorComment: T,
            hasTrailingComment: A,
            hasEndComments: S
          };
        }
      }),
      yg = Z({
        "src/language-yaml/print-preprocess.js": function srcLanguageYamlPrintPreprocessJs(e, n) {
          "use strict";

          re();
          var _Mt = Mt(),
            t = _Mt.defineShortcut,
            s = _Mt.mapNode;
          function a(u) {
            return s(u, r);
          }
          function r(u) {
            switch (u.type) {
              case "document":
                t(u, "head", function () {
                  return u.children[0];
                }), t(u, "body", function () {
                  return u.children[1];
                });
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", function () {
                  return u.children[0];
                });
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", function () {
                  return u.children[0];
                }), t(u, "value", function () {
                  return u.children[1];
                });
                break;
            }
            return u;
          }
          n.exports = a;
        }
      }),
      jr = Z({
        "src/language-yaml/print/misc.js": function srcLanguageYamlPrintMiscJs(e, n) {
          "use strict";

          re();
          var _Oe53 = Oe(),
            _Oe53$builders = _Oe53.builders,
            t = _Oe53$builders.softline,
            s = _Oe53$builders.align,
            _Mt2 = Mt(),
            a = _Mt2.hasEndComments,
            r = _Mt2.isNextLineEmpty,
            u = _Mt2.isNode,
            i = new WeakMap();
          function o(m, d) {
            var p = m.getValue(),
              f = m.stack[0],
              h;
            return i.has(f) ? h = i.get(f) : (h = new Set(), i.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, d) && !c(m.getParentNode())) ? t : "";
          }
          function c(m) {
            return a(m) && !u(m, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function v(m, d) {
            return s(" ".repeat(m), d);
          }
          n.exports = {
            alignWithSpaces: v,
            shouldPrintEndComments: c,
            printNextEmptyLine: o
          };
        }
      }),
      hg = Z({
        "src/language-yaml/print/flow-mapping-sequence.js": function srcLanguageYamlPrintFlowMappingSequenceJs(e, n) {
          "use strict";

          re();
          var _Oe54 = Oe(),
            _Oe54$builders = _Oe54.builders,
            t = _Oe54$builders.ifBreak,
            s = _Oe54$builders.line,
            a = _Oe54$builders.softline,
            r = _Oe54$builders.hardline,
            u = _Oe54$builders.join,
            _Mt3 = Mt(),
            i = _Mt3.isEmptyNode,
            o = _Mt3.getLast,
            c = _Mt3.hasEndComments,
            _jr = jr(),
            v = _jr.printNextEmptyLine,
            m = _jr.alignWithSpaces;
          function d(f, h, w) {
            var T = f.getValue(),
              A = T.type === "flowMapping",
              S = A ? "{" : "[",
              B = A ? "}" : "]",
              I = a;
            A && T.children.length > 0 && w.bracketSpacing && (I = s);
            var k = o(T.children),
              P = k && k.type === "flowMappingItem" && i(k.key) && i(k.value);
            return [S, m(w.tabWidth, [I, p(f, h, w), w.trailingComma === "none" ? "" : t(","), c(T) ? [r, u(r, f.map(h, "endComments"))] : ""]), P ? "" : I, B];
          }
          function p(f, h, w) {
            var T = f.getValue();
            return f.map(function (S, B) {
              return [h(), B === T.children.length - 1 ? "" : [",", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? v(S, w.originalText) : ""]];
            }, "children");
          }
          n.exports = {
            printFlowMapping: d,
            printFlowSequence: d
          };
        }
      }),
      vg = Z({
        "src/language-yaml/print/mapping-item.js": function srcLanguageYamlPrintMappingItemJs(e, n) {
          "use strict";

          re();
          var _Oe55 = Oe(),
            _Oe55$builders = _Oe55.builders,
            t = _Oe55$builders.conditionalGroup,
            s = _Oe55$builders.group,
            a = _Oe55$builders.hardline,
            r = _Oe55$builders.ifBreak,
            u = _Oe55$builders.join,
            i = _Oe55$builders.line,
            _Mt4 = Mt(),
            o = _Mt4.hasLeadingComments,
            c = _Mt4.hasMiddleComments,
            v = _Mt4.hasTrailingComment,
            m = _Mt4.hasEndComments,
            d = _Mt4.isNode,
            p = _Mt4.isEmptyNode,
            f = _Mt4.isInlineNode,
            _jr2 = jr(),
            h = _jr2.alignWithSpaces;
          function w(B, I, k, P, C) {
            var D = B.key,
              g = B.value,
              F = p(D),
              l = p(g);
            if (F && l) return ": ";
            var E = P("key"),
              y = A(B) ? " " : "";
            if (l) return B.type === "flowMappingItem" && I.type === "flowMapping" ? E : B.type === "mappingItem" && T(D.content, C) && !v(D.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [E, y, ":"] : ["? ", h(2, E)];
            var N = P("value");
            if (F) return [": ", h(2, N)];
            if (o(g) || !f(D.content)) return ["? ", h(2, E), a, u("", k.map(P, "value", "leadingComments").map(function ($) {
              return [$, a];
            })), ": ", h(2, N)];
            if (S(D.content) && !o(D.content) && !c(D.content) && !v(D.content) && !m(D) && !o(g.content) && !c(g.content) && !m(g) && T(g.content, C)) return [E, y, ": ", N];
            var x = Symbol("mappingKey"),
              b = s([r("? "), s(h(2, E), {
                id: x
              })]),
              L = [a, ": ", h(2, N)],
              M = [y, ":"];
            o(g.content) || m(g) && g.content && !d(g.content, ["mapping", "sequence"]) || I.type === "mapping" && v(D.content) && f(g.content) || d(g.content, ["mapping", "sequence"]) && g.content.tag === null && g.content.anchor === null ? M.push(a) : g.content && M.push(i), M.push(N);
            var j = h(C.tabWidth, M);
            return T(D.content, C) && !o(D.content) && !c(D.content) && !m(D) ? t([[E, j]]) : t([[b, r(L, j, {
              groupId: x
            })]]);
          }
          function T(B, I) {
            if (!B) return !0;
            switch (B.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return !0;
              default:
                return !1;
            }
            if (I.proseWrap === "preserve") return B.position.start.line === B.position.end.line;
            if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset))) return !1;
            switch (I.proseWrap) {
              case "never":
                return !B.value.includes("\n");
              case "always":
                return !/[\n ]/.test(B.value);
              default:
                return !1;
            }
          }
          function A(B) {
            return B.key.content && B.key.content.type === "alias";
          }
          function S(B) {
            if (!B) return !0;
            switch (B.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return B.position.start.line === B.position.end.line;
              case "alias":
                return !0;
              default:
                return !1;
            }
          }
          n.exports = w;
        }
      }),
      Cg = Z({
        "src/language-yaml/print/block.js": function srcLanguageYamlPrintBlockJs(e, n) {
          "use strict";

          re();
          var _Oe56 = Oe(),
            _Oe56$builders = _Oe56.builders,
            t = _Oe56$builders.dedent,
            s = _Oe56$builders.dedentToRoot,
            a = _Oe56$builders.fill,
            r = _Oe56$builders.hardline,
            u = _Oe56$builders.join,
            i = _Oe56$builders.line,
            o = _Oe56$builders.literalline,
            c = _Oe56$builders.markAsRoot,
            v = _Oe56.utils.getDocParts,
            _Mt5 = Mt(),
            m = _Mt5.getAncestorCount,
            d = _Mt5.getBlockValueLineContents,
            p = _Mt5.hasIndicatorComment,
            f = _Mt5.isLastDescendantNode,
            h = _Mt5.isNode,
            _jr3 = jr(),
            w = _jr3.alignWithSpaces;
          function T(A, S, B) {
            var I = A.getValue(),
              k = m(A, function (F) {
                return h(F, ["sequence", "mapping"]);
              }),
              P = f(A),
              C = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && C.push(I.indent.toString()), I.chomping !== "clip" && C.push(I.chomping === "keep" ? "+" : "-"), p(I) && C.push(" ", S("indicatorComment"));
            var D = d(I, {
                parentIndent: k,
                isLastDescendant: P,
                options: B
              }),
              g = [];
            var _iterator55 = _createForOfIteratorHelper(D.entries()),
              _step55;
            try {
              for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
                var _step55$value = _slicedToArray(_step55.value, 2),
                  F = _step55$value[0],
                  l = _step55$value[1];
                F === 0 && g.push(r), g.push(a(v(u(i, l)))), F !== D.length - 1 ? g.push(l.length === 0 ? r : c(o)) : I.chomping === "keep" && P && g.push(s(l.length === 0 ? r : o));
              }
            } catch (err) {
              _iterator55.e(err);
            } finally {
              _iterator55.f();
            }
            return I.indent === null ? C.push(t(w(B.tabWidth, g))) : C.push(s(w(I.indent - 1 + k, g))), C;
          }
          n.exports = T;
        }
      }),
      Eg = Z({
        "src/language-yaml/printer-yaml.js": function srcLanguageYamlPrinterYamlJs(e, n) {
          "use strict";

          re();
          var _Oe57 = Oe(),
            _Oe57$builders = _Oe57.builders,
            t = _Oe57$builders.breakParent,
            s = _Oe57$builders.fill,
            a = _Oe57$builders.group,
            r = _Oe57$builders.hardline,
            u = _Oe57$builders.join,
            i = _Oe57$builders.line,
            o = _Oe57$builders.lineSuffix,
            c = _Oe57$builders.literalline,
            _Oe57$utils = _Oe57.utils,
            v = _Oe57$utils.getDocParts,
            m = _Oe57$utils.replaceTextEndOfLine,
            _Ue44 = Ue(),
            d = _Ue44.isPreviousLineEmpty,
            _mg = mg(),
            p = _mg.insertPragma,
            f = _mg.isPragma,
            _dg = dg(),
            h = _dg.locStart,
            w = gg(),
            _Mt6 = Mt(),
            T = _Mt6.getFlowScalarLineContents,
            A = _Mt6.getLastDescendantNode,
            S = _Mt6.hasLeadingComments,
            B = _Mt6.hasMiddleComments,
            I = _Mt6.hasTrailingComment,
            k = _Mt6.hasEndComments,
            P = _Mt6.hasPrettierIgnore,
            C = _Mt6.isLastDescendantNode,
            D = _Mt6.isNode,
            g = _Mt6.isInlineNode,
            F = yg(),
            _jr4 = jr(),
            l = _jr4.alignWithSpaces,
            E = _jr4.printNextEmptyLine,
            y = _jr4.shouldPrintEndComments,
            _hg = hg(),
            N = _hg.printFlowMapping,
            x = _hg.printFlowSequence,
            b = vg(),
            L = Cg();
          function M(R, Q, ee) {
            var te = R.getValue(),
              oe = [];
            te.type !== "mappingValue" && S(te) && oe.push([u(r, R.map(ee, "leadingComments")), r]);
            var W = te.tag,
              X = te.anchor;
            W && oe.push(ee("tag")), W && X && oe.push(" "), X && oe.push(ee("anchor"));
            var ue = "";
            D(te, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !C(R) && (ue = E(R, Q.originalText)), (W || X) && (D(te, ["sequence", "mapping"]) && !B(te) ? oe.push(r) : oe.push(" ")), B(te) && oe.push([te.middleComments.length === 1 ? "" : r, u(r, R.map(ee, "middleComments")), r]);
            var De = R.getParentNode();
            return P(R) ? oe.push(m(Q.originalText.slice(te.position.start.offset, te.position.end.offset).trimEnd(), c)) : oe.push(a(j(te, De, R, Q, ee))), I(te) && !D(te, ["document", "documentHead"]) && oe.push(o([te.type === "mappingValue" && !te.content ? "" : " ", De.type === "mappingKey" && R.getParentNode(2).type === "mapping" && g(te) ? "" : t, ee("trailingComment")])), y(te) && oe.push(l(te.type === "sequenceItem" ? 2 : 0, [r, u(r, R.map(function (ie) {
              return [d(Q.originalText, ie.getValue(), h) ? r : "", ee()];
            }, "endComments"))])), oe.push(ue), oe;
          }
          function j(R, Q, ee, te, oe) {
            switch (R.type) {
              case "root":
                {
                  var W = R.children,
                    X = [];
                  ee.each(function (De, ie) {
                    var G = W[ie],
                      z = W[ie + 1];
                    ie !== 0 && X.push(r), X.push(oe()), V(G, z) ? (X.push(r, "..."), I(G) && X.push(" ", oe("trailingComment"))) : z && !I(z.head) && X.push(r, "---");
                  }, "children");
                  var ue = A(R);
                  return (!D(ue, ["blockLiteral", "blockFolded"]) || ue.chomping !== "keep") && X.push(r), X;
                }
              case "document":
                {
                  var _W5 = Q.children[ee.getName() + 1],
                    _X3 = [];
                  return q(R, _W5, Q, te) === "head" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && _X3.push(oe("head")), I(R.head) ? _X3.push(["---", " ", oe(["head", "trailingComment"])]) : _X3.push("---")), $(R) && _X3.push(oe("body")), u(r, _X3);
                }
              case "documentHead":
                return u(r, [].concat(_toConsumableArray(ee.map(oe, "children")), _toConsumableArray(ee.map(oe, "endComments"))));
              case "documentBody":
                {
                  var _W6 = R.children,
                    _X4 = R.endComments,
                    _ue3 = "";
                  if (_W6.length > 0 && _X4.length > 0) {
                    var De = A(R);
                    D(De, ["blockFolded", "blockLiteral"]) ? De.chomping !== "keep" && (_ue3 = [r, r]) : _ue3 = r;
                  }
                  return [u(r, ee.map(oe, "children")), _ue3, u(r, ee.map(oe, "endComments"))];
                }
              case "directive":
                return ["%", u(" ", [R.name].concat(_toConsumableArray(R.parameters)))];
              case "comment":
                return ["#", R.value];
              case "alias":
                return ["*", R.value];
              case "tag":
                return te.originalText.slice(R.position.start.offset, R.position.end.offset);
              case "anchor":
                return ["&", R.value];
              case "plain":
                return Y(R.type, te.originalText.slice(R.position.start.offset, R.position.end.offset), te);
              case "quoteDouble":
              case "quoteSingle":
                {
                  var _W7 = "'",
                    _X5 = '"',
                    _ue4 = te.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);
                  if (R.type === "quoteSingle" && _ue4.includes("\\") || R.type === "quoteDouble" && /\\[^"]/.test(_ue4)) {
                    var ie = R.type === "quoteDouble" ? _X5 : _W7;
                    return [ie, Y(R.type, _ue4, te), ie];
                  }
                  if (_ue4.includes(_X5)) return [_W7, Y(R.type, R.type === "quoteDouble" ? _ue4.replace(/\\"/g, _X5).replace(/'/g, _W7.repeat(2)) : _ue4, te), _W7];
                  if (_ue4.includes(_W7)) return [_X5, Y(R.type, R.type === "quoteSingle" ? _ue4.replace(/''/g, _W7) : _ue4, te), _X5];
                  var _De = te.singleQuote ? _W7 : _X5;
                  return [_De, Y(R.type, _ue4, te), _De];
                }
              case "blockFolded":
              case "blockLiteral":
                return L(ee, oe, te);
              case "mapping":
              case "sequence":
                return u(r, ee.map(oe, "children"));
              case "sequenceItem":
                return ["- ", l(2, R.content ? oe("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return R.content ? oe("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return b(R, Q, ee, oe, te);
              case "flowMapping":
                return N(ee, oe, te);
              case "flowSequence":
                return x(ee, oe, te);
              case "flowSequenceItem":
                return oe("content");
              default:
                throw new Error("Unexpected node type ".concat(R.type));
            }
          }
          function $(R) {
            return R.body.children.length > 0 || k(R.body);
          }
          function V(R, Q) {
            return I(R) || Q && (Q.head.children.length > 0 || k(Q.head));
          }
          function q(R, Q, ee, te) {
            return ee.children[0] === R && /---(?:\s|$)/.test(te.originalText.slice(h(R), h(R) + 4)) || R.head.children.length > 0 || k(R.head) || I(R.head) ? "head" : V(R, Q) ? !1 : Q ? "root" : !1;
          }
          function Y(R, Q, ee) {
            var te = T(R, Q, ee);
            return u(r, te.map(function (oe) {
              return s(v(u(i, oe)));
            }));
          }
          function H(R, Q) {
            if (D(Q)) switch (delete Q.position, Q.type) {
              case "comment":
                if (f(Q.value)) return null;
                break;
              case "quoteDouble":
              case "quoteSingle":
                Q.type = "quote";
                break;
            }
          }
          n.exports = {
            preprocess: F,
            embed: w,
            print: M,
            massageAstNode: H,
            insertPragma: p
          };
        }
      }),
      Fg = Z({
        "src/language-yaml/options.js": function srcLanguageYamlOptionsJs(e, n) {
          "use strict";

          re();
          var t = Ot();
          n.exports = {
            bracketSpacing: t.bracketSpacing,
            singleQuote: t.singleQuote,
            proseWrap: t.proseWrap
          };
        }
      }),
      Ag = Z({
        "src/language-yaml/parsers.js": function srcLanguageYamlParsersJs() {
          re();
        }
      }),
      Sg = Z({
        "node_modules/linguist-languages/data/YAML.json": function node_modulesLinguistLanguagesDataYAMLJson(e, n) {
          n.exports = {
            name: "YAML",
            type: "data",
            color: "#cb171e",
            tmScope: "source.yaml",
            aliases: ["yml"],
            extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"],
            filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"],
            aceMode: "yaml",
            codemirrorMode: "yaml",
            codemirrorMimeType: "text/x-yaml",
            languageId: 407
          };
        }
      }),
      xg = Z({
        "src/language-yaml/index.js": function srcLanguageYamlIndexJs(e, n) {
          "use strict";

          re();
          var t = Bt(),
            s = Eg(),
            a = Fg(),
            r = Ag(),
            u = [t(Sg(), function (i) {
              return {
                since: "1.14.0",
                parsers: ["yaml"],
                vscodeLanguageIds: ["yaml", "ansible", "home-assistant"],
                filenames: [].concat(_toConsumableArray(i.filenames.filter(function (o) {
                  return o !== "yarn.lock";
                })), [".prettierrc", ".stylelintrc"])
              };
            })];
          n.exports = {
            languages: u,
            printers: {
              yaml: s
            },
            options: a,
            parsers: r
          };
        }
      }),
      bg = Z({
        "src/languages.js": function srcLanguagesJs(e, n) {
          "use strict";

          re(), n.exports = [id(), Sd(), Pd(), Md(), Ud(), Dg(), xg()];
        }
      });
    re();
    var _ya = ya(),
      Tg = _ya.version,
      kt = Sm(),
      _Mn3 = Mn(),
      Bg = _Mn3.getSupportInfo,
      Ng = xm(),
      wg = bg(),
      _g = Oe();
    function bt(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return function () {
        for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) {
          s[a] = arguments[a];
        }
        var r = s[n] || {},
          u = r.plugins || [];
        return s[n] = Object.assign(Object.assign({}, r), {}, {
          plugins: [].concat(_toConsumableArray(wg), _toConsumableArray(Array.isArray(u) ? u : Object.values(u)))
        }), e.apply(void 0, s);
      };
    }
    var bn = bt(kt.formatWithCursor);
    Co.exports = {
      formatWithCursor: bn,
      format: function format(e, n) {
        return bn(e, n).formatted;
      },
      check: function check(e, n) {
        var _bn = bn(e, n),
          t = _bn.formatted;
        return t === e;
      },
      doc: _g,
      getSupportInfo: bt(Bg, 0),
      version: Tg,
      util: Ng,
      __debug: {
        parse: bt(kt.parse),
        formatAST: bt(kt.formatAST),
        formatDoc: bt(kt.formatDoc),
        printToDoc: bt(kt.printToDoc),
        printDocToString: bt(kt.printDocToString)
      }
    };
  });
  return Pg();
});
},{}],"index.js":[function(require,module,exports) {
"use strict";

require("core-js/modules/es6.array.copy-within.js");
require("core-js/modules/es6.array.fill.js");
require("core-js/modules/es6.array.filter.js");
require("core-js/modules/es6.array.find.js");
require("core-js/modules/es6.array.find-index.js");
require("core-js/modules/es7.array.flat-map.js");
require("core-js/modules/es6.array.from.js");
require("core-js/modules/es7.array.includes.js");
require("core-js/modules/es6.array.iterator.js");
require("core-js/modules/es6.array.map.js");
require("core-js/modules/es6.array.of.js");
require("core-js/modules/es6.array.slice.js");
require("core-js/modules/es6.array.sort.js");
require("core-js/modules/es6.array.species.js");
require("core-js/modules/es6.date.to-primitive.js");
require("core-js/modules/es6.function.has-instance.js");
require("core-js/modules/es6.function.name.js");
require("core-js/modules/es6.map.js");
require("core-js/modules/es6.math.acosh.js");
require("core-js/modules/es6.math.asinh.js");
require("core-js/modules/es6.math.atanh.js");
require("core-js/modules/es6.math.cbrt.js");
require("core-js/modules/es6.math.clz32.js");
require("core-js/modules/es6.math.cosh.js");
require("core-js/modules/es6.math.expm1.js");
require("core-js/modules/es6.math.fround.js");
require("core-js/modules/es6.math.hypot.js");
require("core-js/modules/es6.math.imul.js");
require("core-js/modules/es6.math.log1p.js");
require("core-js/modules/es6.math.log10.js");
require("core-js/modules/es6.math.log2.js");
require("core-js/modules/es6.math.sign.js");
require("core-js/modules/es6.math.sinh.js");
require("core-js/modules/es6.math.tanh.js");
require("core-js/modules/es6.math.trunc.js");
require("core-js/modules/es6.number.constructor.js");
require("core-js/modules/es6.number.epsilon.js");
require("core-js/modules/es6.number.is-finite.js");
require("core-js/modules/es6.number.is-integer.js");
require("core-js/modules/es6.number.is-nan.js");
require("core-js/modules/es6.number.is-safe-integer.js");
require("core-js/modules/es6.number.max-safe-integer.js");
require("core-js/modules/es6.number.min-safe-integer.js");
require("core-js/modules/es6.number.parse-float.js");
require("core-js/modules/es6.number.parse-int.js");
require("core-js/modules/es6.object.assign.js");
require("core-js/modules/es7.object.define-getter.js");
require("core-js/modules/es7.object.define-setter.js");
require("core-js/modules/es7.object.entries.js");
require("core-js/modules/es6.object.freeze.js");
require("core-js/modules/es6.object.get-own-property-descriptor.js");
require("core-js/modules/es7.object.get-own-property-descriptors.js");
require("core-js/modules/es6.object.get-own-property-names.js");
require("core-js/modules/es6.object.get-prototype-of.js");
require("core-js/modules/es7.object.lookup-getter.js");
require("core-js/modules/es7.object.lookup-setter.js");
require("core-js/modules/es6.object.prevent-extensions.js");
require("core-js/modules/es6.object.to-string.js");
require("core-js/modules/es6.object.is.js");
require("core-js/modules/es6.object.is-frozen.js");
require("core-js/modules/es6.object.is-sealed.js");
require("core-js/modules/es6.object.is-extensible.js");
require("core-js/modules/es6.object.keys.js");
require("core-js/modules/es6.object.seal.js");
require("core-js/modules/es6.object.set-prototype-of.js");
require("core-js/modules/es7.object.values.js");
require("core-js/modules/es6.promise.js");
require("core-js/modules/es7.promise.finally.js");
require("core-js/modules/es6.reflect.apply.js");
require("core-js/modules/es6.reflect.construct.js");
require("core-js/modules/es6.reflect.define-property.js");
require("core-js/modules/es6.reflect.delete-property.js");
require("core-js/modules/es6.reflect.get.js");
require("core-js/modules/es6.reflect.get-own-property-descriptor.js");
require("core-js/modules/es6.reflect.get-prototype-of.js");
require("core-js/modules/es6.reflect.has.js");
require("core-js/modules/es6.reflect.is-extensible.js");
require("core-js/modules/es6.reflect.own-keys.js");
require("core-js/modules/es6.reflect.prevent-extensions.js");
require("core-js/modules/es6.reflect.set.js");
require("core-js/modules/es6.reflect.set-prototype-of.js");
require("core-js/modules/es6.regexp.constructor.js");
require("core-js/modules/es6.regexp.flags.js");
require("core-js/modules/es6.regexp.match.js");
require("core-js/modules/es6.regexp.replace.js");
require("core-js/modules/es6.regexp.split.js");
require("core-js/modules/es6.regexp.search.js");
require("core-js/modules/es6.regexp.to-string.js");
require("core-js/modules/es6.set.js");
require("core-js/modules/es6.symbol.js");
require("core-js/modules/es7.symbol.async-iterator.js");
require("core-js/modules/es6.string.anchor.js");
require("core-js/modules/es6.string.big.js");
require("core-js/modules/es6.string.blink.js");
require("core-js/modules/es6.string.bold.js");
require("core-js/modules/es6.string.code-point-at.js");
require("core-js/modules/es6.string.ends-with.js");
require("core-js/modules/es6.string.fixed.js");
require("core-js/modules/es6.string.fontcolor.js");
require("core-js/modules/es6.string.fontsize.js");
require("core-js/modules/es6.string.from-code-point.js");
require("core-js/modules/es6.string.includes.js");
require("core-js/modules/es6.string.italics.js");
require("core-js/modules/es6.string.iterator.js");
require("core-js/modules/es6.string.link.js");
require("core-js/modules/es7.string.pad-start.js");
require("core-js/modules/es7.string.pad-end.js");
require("core-js/modules/es6.string.raw.js");
require("core-js/modules/es6.string.repeat.js");
require("core-js/modules/es6.string.small.js");
require("core-js/modules/es6.string.starts-with.js");
require("core-js/modules/es6.string.strike.js");
require("core-js/modules/es6.string.sub.js");
require("core-js/modules/es6.string.sup.js");
require("core-js/modules/es7.string.trim-left.js");
require("core-js/modules/es7.string.trim-right.js");
require("core-js/modules/es6.typed.array-buffer.js");
require("core-js/modules/es6.typed.int8-array.js");
require("core-js/modules/es6.typed.uint8-array.js");
require("core-js/modules/es6.typed.uint8-clamped-array.js");
require("core-js/modules/es6.typed.int16-array.js");
require("core-js/modules/es6.typed.uint16-array.js");
require("core-js/modules/es6.typed.int32-array.js");
require("core-js/modules/es6.typed.uint32-array.js");
require("core-js/modules/es6.typed.float32-array.js");
require("core-js/modules/es6.typed.float64-array.js");
require("core-js/modules/es6.weak-map.js");
require("core-js/modules/es6.weak-set.js");
require("core-js/modules/web.timers.js");
require("core-js/modules/web.immediate.js");
require("core-js/modules/web.dom.iterable.js");
require("regenerator-runtime/runtime.js");
var _authentication = require("./authentication");
var _update = require("./update");
var _getFixture = require("./getFixture");
var _prettier = require("prettier");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
//BUTTONS
var loginBtn = document.querySelector('.nav__el--login');
var signUpBtn = document.querySelector('.nav__el--cta ');
var logoutBtn = document.querySelector('.nav__el--logout');
var modalCloseBtns = document.querySelectorAll('.close');
var resetPassBtn = document.querySelector('.reset-password');
var deleteAcc = document.querySelector('.side-nav li:nth-child(2) a');

//MODALS
var loginModal = document.getElementById('login__modal');
var signupModal = document.getElementById('cta__modal');
var passResetModal = document.getElementById('passReset__modal');
var dropdownContents = document.querySelector('.dropdown-content');
var dropdownContent = document.querySelectorAll('.filterOption');
var fixturesContainer = document.querySelector('.container__fixtures');

//FORMS
var signUpForm = document.querySelector('.form--signup');
var loginForm = document.querySelector('.form--login');
var resetPassForm = document.querySelector('.form--resetPassword');
var msg = document.querySelectorAll('.login-signup-msg span');
var sumbitScores = document.getElementById('submit__score');
var saveSettings = document.getElementById('btn--save-setting');
var savePassword = document.getElementById('btn--save-password');
var updateStats = document.getElementById('update_stats');
var individualGames = document.querySelectorAll('.game');
var newPasswordSet = document.querySelector('.form--newPassword');
var teamLogo = document.querySelector('.team-logo');
var dropDownFilter = document.querySelector('.filter-icon');

//Functions
var addListenertoLogo = function addListenertoLogo() {
  document.querySelectorAll('.team-logo').forEach(function (el) {
    return el.addEventListener('click', /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
        var team;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                e.preventDefault();
                team = e.target.closest('div').dataset.team;
                _context.next = 4;
                return (0, _getFixture.getAvgStats)(team);
              case 4:
                document.getElementById('average_stats').style.backdropFilter = 'blur(5px)';
                document.getElementById('average_stats').style.display = 'flex';
              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
};
var openModal = function openModal(modal) {
  modal.style.display = 'flex';
  modal.style.backdropFilter = 'blur(5px)';
};
var closeModal = function closeModal(modal) {
  return modal.style.display = 'none';
};
var updateBtnText = function updateBtnText(el, text) {
  return el.textContent = text;
};
var filter = function filter(team1) {
  var team2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  individualGames.forEach(function (game) {
    if (game.dataset.fixture.includes(team1) && game.dataset.fixture.includes(team2)) {
      document.querySelector("[data-gameday=\"".concat(game.dataset.gameday, "\"]")).style.display = 'flex';
      game.style.display = 'flex';
    }
  });
};

//EventListeners
signUpForm === null || signUpForm === void 0 ? void 0 : signUpForm.addEventListener('submit', /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {
    var email, name, password, passwordConfirm;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            e.preventDefault();
            email = document.getElementById('emailSignup').value;
            name = document.getElementById('name').value;
            password = document.getElementById('passwordSignup').value;
            passwordConfirm = document.getElementById('passwordConfirm').value;
            updateBtnText(e.target.querySelector('button'), 'Creating Account...');
            _context2.next = 8;
            return (0, _authentication.signUp)(name, email, password, passwordConfirm);
          case 8:
            updateBtnText(e.target.querySelector('button'), 'Sign up');
          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
loginForm === null || loginForm === void 0 ? void 0 : loginForm.addEventListener('submit', /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(e) {
    var email, password;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            e.preventDefault();
            email = document.getElementById('email').value;
            password = document.getElementById('password').value;
            updateBtnText(e.target.querySelector('button'), 'Logging in...');
            _context3.next = 6;
            return (0, _authentication.login)(email, password);
          case 6:
            updateBtnText(e.target.querySelector('button'), 'Login');
          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());
resetPassForm === null || resetPassForm === void 0 ? void 0 : resetPassForm.addEventListener('submit', /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(e) {
    var email;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            e.preventDefault();
            email = document.getElementById('emailReset').value;
            updateBtnText(e.target.querySelector('button'), 'sending reset token...');
            _context4.next = 5;
            return (0, _authentication.reset)(email);
          case 5:
            closeModal(passResetModal);
            updateBtnText(e.target.querySelector('button'), 'reset');
          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());
msg === null || msg === void 0 ? void 0 : msg.forEach(function (el) {
  return el === null || el === void 0 ? void 0 : el.addEventListener('click', function (e) {
    closeModal(e.target.closest('.modal'));
    e.target.closest('.modal').id === 'login__modal' ? openModal(signupModal) : openModal(loginModal);
  });
});
logoutBtn === null || logoutBtn === void 0 ? void 0 : logoutBtn.addEventListener('click', _authentication.logout);
resetPassBtn === null || resetPassBtn === void 0 ? void 0 : resetPassBtn.addEventListener('click', function (e) {
  e.preventDefault();
  closeModal(loginModal);
  openModal(passResetModal);
});
[loginBtn, signUpBtn].forEach(function (el) {
  return el === null || el === void 0 ? void 0 : el.addEventListener('click', function (e) {
    e.preventDefault();
    var type = e.target.classList.value.split('--')[1];
    openModal(document.getElementById("".concat(type, "__modal")));
  });
});
deleteAcc === null || deleteAcc === void 0 ? void 0 : deleteAcc.addEventListener('click', function (e) {
  e.preventDefault();
  (0, _authentication.deleteAccount)();
});
modalCloseBtns.forEach(function (closeBtn) {
  closeBtn === null || closeBtn === void 0 ? void 0 : closeBtn.addEventListener('click', function (e) {
    e.preventDefault();
    closeModal(e.target.closest('.modal'));
  });
});
sumbitScores === null || sumbitScores === void 0 ? void 0 : sumbitScores.addEventListener('click', /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(e) {
    var update;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            e.preventDefault();
            updateBtnText(document.getElementById('submit__score'), 'Updating...');
            update = [];
            document.querySelectorAll('.fixture--update').forEach(function (el) {
              var tempObj = {};
              tempObj.HomeTeam = el.children[0].dataset.team;
              tempObj.AwayTeam = el.children[4].dataset.team;
              tempObj.HomeTeamScore = el.children[1].value;
              tempObj.AwayTeamScore = el.children[3].value;
              tempObj.Status = el.children[5].value || el.children[5].children[0].textContent;
              update.push(tempObj);
            });
            _context5.next = 6;
            return (0, _update.updateScores)(update);
          case 6:
            updateBtnText(document.getElementById('submit__score'), 'Save Updates');
          case 7:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return function (_x5) {
    return _ref5.apply(this, arguments);
  };
}());
saveSettings === null || saveSettings === void 0 ? void 0 : saveSettings.addEventListener('click', /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {
    var form;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            e.preventDefault();
            form = new FormData();
            form.append('name', document.getElementById('details_name').value);
            form.append('email', document.getElementById('details_email').value);
            form.append('photo', document.getElementById('photo').files[0]);
            updateBtnText(document.getElementById('btn--save-setting'), 'Updating...');
            _context6.next = 8;
            return (0, _update.updateDetails)(form);
          case 8:
            updateBtnText(document.getElementById('btn--save-setting'), 'Update Details');
          case 9:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return function (_x6) {
    return _ref6.apply(this, arguments);
  };
}());
savePassword === null || savePassword === void 0 ? void 0 : savePassword.addEventListener('click', /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(e) {
    var currentPassword, password, passwordConfirm;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            e.preventDefault();
            currentPassword = document.getElementById('password-current').value;
            password = document.getElementById('password').value;
            passwordConfirm = document.getElementById('password-confirm').value;
            updateBtnText(document.getElementById('btn--save-password'), 'Saving...');
            _context7.next = 7;
            return (0, _update.updatePassword)({
              currentPassword: currentPassword,
              password: password,
              passwordConfirm: passwordConfirm
            });
          case 7:
            updateBtnText(document.getElementById('btn--save-password'), 'Save Password');
          case 8:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return function (_x7) {
    return _ref7.apply(this, arguments);
  };
}());
updateStats === null || updateStats === void 0 ? void 0 : updateStats.addEventListener('click', /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(e) {
    var fixtureIds;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            e.preventDefault();
            fixtureIds = [];
            document.querySelectorAll('article').forEach(function (el) {
              return fixtureIds.push(JSON.parse(el.dataset.json));
            });
            updateBtnText(document.getElementById('update_stats'), 'Updating...');
            _context8.next = 6;
            return (0, _update.updateStatistics)(fixtureIds);
          case 6:
            updateBtnText(document.getElementById('update_stats'), 'Update Stats');
          case 7:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return function (_x8) {
    return _ref8.apply(this, arguments);
  };
}());
dropDownFilter === null || dropDownFilter === void 0 ? void 0 : dropDownFilter.addEventListener('click', function (e) {
  e.preventDefault();
  dropdownContents.classList.toggle('show');
});
individualGames === null || individualGames === void 0 ? void 0 : individualGames.forEach(function (btn) {
  return btn.addEventListener('click', /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(e) {
      var _e$target$closest$dat, _e$target$closest$dat2, HomeTeam, AwayTeam;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              e.preventDefault();
              _e$target$closest$dat = e.target.closest('div').dataset.fixture.split('vs'), _e$target$closest$dat2 = _slicedToArray(_e$target$closest$dat, 2), HomeTeam = _e$target$closest$dat2[0], AwayTeam = _e$target$closest$dat2[1];
              _context9.next = 4;
              return (0, _getFixture.getFixture)(HomeTeam, AwayTeam);
            case 4:
              addListenertoLogo();
            case 5:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return function (_x9) {
      return _ref9.apply(this, arguments);
    };
  }());
});
newPasswordSet === null || newPasswordSet === void 0 ? void 0 : newPasswordSet.addEventListener('submit', function (e) {
  e.preventDefault();
  var token = document.getElementById('token').value;
  var password = document.getElementById('passwordReset').value;
  var passwordConfirm = document.getElementById('passwordConfirmReset').value;
  (0, _authentication.setNewPassword)({
    token: token,
    password: password,
    passwordConfirm: passwordConfirm
  });
});
dropdownContent.forEach(function (listItem) {
  listItem === null || listItem === void 0 ? void 0 : listItem.addEventListener('change', function (e) {
    var _document$querySelect, _document$querySelect2;
    e.preventDefault();
    fixturesContainer.childNodes.forEach(function (e) {
      return e.style.display = 'none';
    });
    document.querySelectorAll('input[type=checkbox]').forEach(function (el) {
      return el.disabled = false;
    });
    if (document.querySelectorAll(':checked').length === 2) {
      document.querySelectorAll('input[type=checkbox]').forEach(function (el) {
        if (!el.checked) el.disabled = true;
      });
    }
    if (document.querySelectorAll(':checked').length === 0) {
      fixturesContainer.childNodes.forEach(function (e) {
        return e.style.display = 'flex';
      });
      return;
    }
    var x = (_document$querySelect = document.querySelectorAll(':checked')[0]) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.nextSibling.textContent;
    var y = (_document$querySelect2 = document.querySelectorAll(':checked')[1]) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.nextSibling.textContent;
    if (x || y) filter(x, y);
  });
});
if (teamLogo) addListenertoLogo();
},{"core-js/modules/es6.array.copy-within.js":"../../node_modules/core-js/modules/es6.array.copy-within.js","core-js/modules/es6.array.fill.js":"../../node_modules/core-js/modules/es6.array.fill.js","core-js/modules/es6.array.filter.js":"../../node_modules/core-js/modules/es6.array.filter.js","core-js/modules/es6.array.find.js":"../../node_modules/core-js/modules/es6.array.find.js","core-js/modules/es6.array.find-index.js":"../../node_modules/core-js/modules/es6.array.find-index.js","core-js/modules/es7.array.flat-map.js":"../../node_modules/core-js/modules/es7.array.flat-map.js","core-js/modules/es6.array.from.js":"../../node_modules/core-js/modules/es6.array.from.js","core-js/modules/es7.array.includes.js":"../../node_modules/core-js/modules/es7.array.includes.js","core-js/modules/es6.array.iterator.js":"../../node_modules/core-js/modules/es6.array.iterator.js","core-js/modules/es6.array.map.js":"../../node_modules/core-js/modules/es6.array.map.js","core-js/modules/es6.array.of.js":"../../node_modules/core-js/modules/es6.array.of.js","core-js/modules/es6.array.slice.js":"../../node_modules/core-js/modules/es6.array.slice.js","core-js/modules/es6.array.sort.js":"../../node_modules/core-js/modules/es6.array.sort.js","core-js/modules/es6.array.species.js":"../../node_modules/core-js/modules/es6.array.species.js","core-js/modules/es6.date.to-primitive.js":"../../node_modules/core-js/modules/es6.date.to-primitive.js","core-js/modules/es6.function.has-instance.js":"../../node_modules/core-js/modules/es6.function.has-instance.js","core-js/modules/es6.function.name.js":"../../node_modules/core-js/modules/es6.function.name.js","core-js/modules/es6.map.js":"../../node_modules/core-js/modules/es6.map.js","core-js/modules/es6.math.acosh.js":"../../node_modules/core-js/modules/es6.math.acosh.js","core-js/modules/es6.math.asinh.js":"../../node_modules/core-js/modules/es6.math.asinh.js","core-js/modules/es6.math.atanh.js":"../../node_modules/core-js/modules/es6.math.atanh.js","core-js/modules/es6.math.cbrt.js":"../../node_modules/core-js/modules/es6.math.cbrt.js","core-js/modules/es6.math.clz32.js":"../../node_modules/core-js/modules/es6.math.clz32.js","core-js/modules/es6.math.cosh.js":"../../node_modules/core-js/modules/es6.math.cosh.js","core-js/modules/es6.math.expm1.js":"../../node_modules/core-js/modules/es6.math.expm1.js","core-js/modules/es6.math.fround.js":"../../node_modules/core-js/modules/es6.math.fround.js","core-js/modules/es6.math.hypot.js":"../../node_modules/core-js/modules/es6.math.hypot.js","core-js/modules/es6.math.imul.js":"../../node_modules/core-js/modules/es6.math.imul.js","core-js/modules/es6.math.log1p.js":"../../node_modules/core-js/modules/es6.math.log1p.js","core-js/modules/es6.math.log10.js":"../../node_modules/core-js/modules/es6.math.log10.js","core-js/modules/es6.math.log2.js":"../../node_modules/core-js/modules/es6.math.log2.js","core-js/modules/es6.math.sign.js":"../../node_modules/core-js/modules/es6.math.sign.js","core-js/modules/es6.math.sinh.js":"../../node_modules/core-js/modules/es6.math.sinh.js","core-js/modules/es6.math.tanh.js":"../../node_modules/core-js/modules/es6.math.tanh.js","core-js/modules/es6.math.trunc.js":"../../node_modules/core-js/modules/es6.math.trunc.js","core-js/modules/es6.number.constructor.js":"../../node_modules/core-js/modules/es6.number.constructor.js","core-js/modules/es6.number.epsilon.js":"../../node_modules/core-js/modules/es6.number.epsilon.js","core-js/modules/es6.number.is-finite.js":"../../node_modules/core-js/modules/es6.number.is-finite.js","core-js/modules/es6.number.is-integer.js":"../../node_modules/core-js/modules/es6.number.is-integer.js","core-js/modules/es6.number.is-nan.js":"../../node_modules/core-js/modules/es6.number.is-nan.js","core-js/modules/es6.number.is-safe-integer.js":"../../node_modules/core-js/modules/es6.number.is-safe-integer.js","core-js/modules/es6.number.max-safe-integer.js":"../../node_modules/core-js/modules/es6.number.max-safe-integer.js","core-js/modules/es6.number.min-safe-integer.js":"../../node_modules/core-js/modules/es6.number.min-safe-integer.js","core-js/modules/es6.number.parse-float.js":"../../node_modules/core-js/modules/es6.number.parse-float.js","core-js/modules/es6.number.parse-int.js":"../../node_modules/core-js/modules/es6.number.parse-int.js","core-js/modules/es6.object.assign.js":"../../node_modules/core-js/modules/es6.object.assign.js","core-js/modules/es7.object.define-getter.js":"../../node_modules/core-js/modules/es7.object.define-getter.js","core-js/modules/es7.object.define-setter.js":"../../node_modules/core-js/modules/es7.object.define-setter.js","core-js/modules/es7.object.entries.js":"../../node_modules/core-js/modules/es7.object.entries.js","core-js/modules/es6.object.freeze.js":"../../node_modules/core-js/modules/es6.object.freeze.js","core-js/modules/es6.object.get-own-property-descriptor.js":"../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","core-js/modules/es7.object.get-own-property-descriptors.js":"../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","core-js/modules/es6.object.get-own-property-names.js":"../../node_modules/core-js/modules/es6.object.get-own-property-names.js","core-js/modules/es6.object.get-prototype-of.js":"../../node_modules/core-js/modules/es6.object.get-prototype-of.js","core-js/modules/es7.object.lookup-getter.js":"../../node_modules/core-js/modules/es7.object.lookup-getter.js","core-js/modules/es7.object.lookup-setter.js":"../../node_modules/core-js/modules/es7.object.lookup-setter.js","core-js/modules/es6.object.prevent-extensions.js":"../../node_modules/core-js/modules/es6.object.prevent-extensions.js","core-js/modules/es6.object.to-string.js":"../../node_modules/core-js/modules/es6.object.to-string.js","core-js/modules/es6.object.is.js":"../../node_modules/core-js/modules/es6.object.is.js","core-js/modules/es6.object.is-frozen.js":"../../node_modules/core-js/modules/es6.object.is-frozen.js","core-js/modules/es6.object.is-sealed.js":"../../node_modules/core-js/modules/es6.object.is-sealed.js","core-js/modules/es6.object.is-extensible.js":"../../node_modules/core-js/modules/es6.object.is-extensible.js","core-js/modules/es6.object.keys.js":"../../node_modules/core-js/modules/es6.object.keys.js","core-js/modules/es6.object.seal.js":"../../node_modules/core-js/modules/es6.object.seal.js","core-js/modules/es6.object.set-prototype-of.js":"../../node_modules/core-js/modules/es6.object.set-prototype-of.js","core-js/modules/es7.object.values.js":"../../node_modules/core-js/modules/es7.object.values.js","core-js/modules/es6.promise.js":"../../node_modules/core-js/modules/es6.promise.js","core-js/modules/es7.promise.finally.js":"../../node_modules/core-js/modules/es7.promise.finally.js","core-js/modules/es6.reflect.apply.js":"../../node_modules/core-js/modules/es6.reflect.apply.js","core-js/modules/es6.reflect.construct.js":"../../node_modules/core-js/modules/es6.reflect.construct.js","core-js/modules/es6.reflect.define-property.js":"../../node_modules/core-js/modules/es6.reflect.define-property.js","core-js/modules/es6.reflect.delete-property.js":"../../node_modules/core-js/modules/es6.reflect.delete-property.js","core-js/modules/es6.reflect.get.js":"../../node_modules/core-js/modules/es6.reflect.get.js","core-js/modules/es6.reflect.get-own-property-descriptor.js":"../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","core-js/modules/es6.reflect.get-prototype-of.js":"../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js","core-js/modules/es6.reflect.has.js":"../../node_modules/core-js/modules/es6.reflect.has.js","core-js/modules/es6.reflect.is-extensible.js":"../../node_modules/core-js/modules/es6.reflect.is-extensible.js","core-js/modules/es6.reflect.own-keys.js":"../../node_modules/core-js/modules/es6.reflect.own-keys.js","core-js/modules/es6.reflect.prevent-extensions.js":"../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js","core-js/modules/es6.reflect.set.js":"../../node_modules/core-js/modules/es6.reflect.set.js","core-js/modules/es6.reflect.set-prototype-of.js":"../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js","core-js/modules/es6.regexp.constructor.js":"../../node_modules/core-js/modules/es6.regexp.constructor.js","core-js/modules/es6.regexp.flags.js":"../../node_modules/core-js/modules/es6.regexp.flags.js","core-js/modules/es6.regexp.match.js":"../../node_modules/core-js/modules/es6.regexp.match.js","core-js/modules/es6.regexp.replace.js":"../../node_modules/core-js/modules/es6.regexp.replace.js","core-js/modules/es6.regexp.split.js":"../../node_modules/core-js/modules/es6.regexp.split.js","core-js/modules/es6.regexp.search.js":"../../node_modules/core-js/modules/es6.regexp.search.js","core-js/modules/es6.regexp.to-string.js":"../../node_modules/core-js/modules/es6.regexp.to-string.js","core-js/modules/es6.set.js":"../../node_modules/core-js/modules/es6.set.js","core-js/modules/es6.symbol.js":"../../node_modules/core-js/modules/es6.symbol.js","core-js/modules/es7.symbol.async-iterator.js":"../../node_modules/core-js/modules/es7.symbol.async-iterator.js","core-js/modules/es6.string.anchor.js":"../../node_modules/core-js/modules/es6.string.anchor.js","core-js/modules/es6.string.big.js":"../../node_modules/core-js/modules/es6.string.big.js","core-js/modules/es6.string.blink.js":"../../node_modules/core-js/modules/es6.string.blink.js","core-js/modules/es6.string.bold.js":"../../node_modules/core-js/modules/es6.string.bold.js","core-js/modules/es6.string.code-point-at.js":"../../node_modules/core-js/modules/es6.string.code-point-at.js","core-js/modules/es6.string.ends-with.js":"../../node_modules/core-js/modules/es6.string.ends-with.js","core-js/modules/es6.string.fixed.js":"../../node_modules/core-js/modules/es6.string.fixed.js","core-js/modules/es6.string.fontcolor.js":"../../node_modules/core-js/modules/es6.string.fontcolor.js","core-js/modules/es6.string.fontsize.js":"../../node_modules/core-js/modules/es6.string.fontsize.js","core-js/modules/es6.string.from-code-point.js":"../../node_modules/core-js/modules/es6.string.from-code-point.js","core-js/modules/es6.string.includes.js":"../../node_modules/core-js/modules/es6.string.includes.js","core-js/modules/es6.string.italics.js":"../../node_modules/core-js/modules/es6.string.italics.js","core-js/modules/es6.string.iterator.js":"../../node_modules/core-js/modules/es6.string.iterator.js","core-js/modules/es6.string.link.js":"../../node_modules/core-js/modules/es6.string.link.js","core-js/modules/es7.string.pad-start.js":"../../node_modules/core-js/modules/es7.string.pad-start.js","core-js/modules/es7.string.pad-end.js":"../../node_modules/core-js/modules/es7.string.pad-end.js","core-js/modules/es6.string.raw.js":"../../node_modules/core-js/modules/es6.string.raw.js","core-js/modules/es6.string.repeat.js":"../../node_modules/core-js/modules/es6.string.repeat.js","core-js/modules/es6.string.small.js":"../../node_modules/core-js/modules/es6.string.small.js","core-js/modules/es6.string.starts-with.js":"../../node_modules/core-js/modules/es6.string.starts-with.js","core-js/modules/es6.string.strike.js":"../../node_modules/core-js/modules/es6.string.strike.js","core-js/modules/es6.string.sub.js":"../../node_modules/core-js/modules/es6.string.sub.js","core-js/modules/es6.string.sup.js":"../../node_modules/core-js/modules/es6.string.sup.js","core-js/modules/es7.string.trim-left.js":"../../node_modules/core-js/modules/es7.string.trim-left.js","core-js/modules/es7.string.trim-right.js":"../../node_modules/core-js/modules/es7.string.trim-right.js","core-js/modules/es6.typed.array-buffer.js":"../../node_modules/core-js/modules/es6.typed.array-buffer.js","core-js/modules/es6.typed.int8-array.js":"../../node_modules/core-js/modules/es6.typed.int8-array.js","core-js/modules/es6.typed.uint8-array.js":"../../node_modules/core-js/modules/es6.typed.uint8-array.js","core-js/modules/es6.typed.uint8-clamped-array.js":"../../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","core-js/modules/es6.typed.int16-array.js":"../../node_modules/core-js/modules/es6.typed.int16-array.js","core-js/modules/es6.typed.uint16-array.js":"../../node_modules/core-js/modules/es6.typed.uint16-array.js","core-js/modules/es6.typed.int32-array.js":"../../node_modules/core-js/modules/es6.typed.int32-array.js","core-js/modules/es6.typed.uint32-array.js":"../../node_modules/core-js/modules/es6.typed.uint32-array.js","core-js/modules/es6.typed.float32-array.js":"../../node_modules/core-js/modules/es6.typed.float32-array.js","core-js/modules/es6.typed.float64-array.js":"../../node_modules/core-js/modules/es6.typed.float64-array.js","core-js/modules/es6.weak-map.js":"../../node_modules/core-js/modules/es6.weak-map.js","core-js/modules/es6.weak-set.js":"../../node_modules/core-js/modules/es6.weak-set.js","core-js/modules/web.timers.js":"../../node_modules/core-js/modules/web.timers.js","core-js/modules/web.immediate.js":"../../node_modules/core-js/modules/web.immediate.js","core-js/modules/web.dom.iterable.js":"../../node_modules/core-js/modules/web.dom.iterable.js","regenerator-runtime/runtime.js":"../../node_modules/regenerator-runtime/runtime.js","./authentication":"authentication.js","./update":"update.js","./getFixture":"getFixture.js","prettier":"../../node_modules/prettier/standalone.js"}],"../../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "51253" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] â¨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] ð¨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ð¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/bundle.js.map